Servers used for configuaration in Microservices development with Spring boot
-Service Registry
-Admin Server
-API Gateway

Development flow:
-From backend to UI
-API Gatewway acts as a mediator between FrontEnd and BackEnd

-Spring Core provides IOC and DI, to develop classes with loosely coupling
-Use Interface to provide common methods(increases readability)
Dependency Injection: Injecting dependent object into target object using target class variable/setter/constructor
-Different Types of Injection
--Constructor Injection
--Setter Injection
--Field Injection

What if we perform both constructor Injection and Setter Injection-->First construction injection will happen. then, it will
initialize the variable then setter injection will happen and it will reinitialize the same variable so final value be setter injection value
Note: Setter injection will override construction injection

In Spring, IOC is responsible for Dependency Injection
IOC manages and collaborate object(i.e Creating and injecting object). IOC is a principle which is used to manage and collaborate dependencies among the objects in the application
For IOC container, we need to provide Java Classes as input as it don't know which is target class. Along with Java classes we have to provide configuration(through Xml or annotartions)
IOC will load classes and then create object and will perform DI(i.e it provides spring beans-->Class which is managed by IOC)

Ways to Start the IOC
-BeanFactory(Outdated)
-ApplicationContext(interface)

Class managed by IOC is called as Spring Bean

ApplicationContext ctx = new ClassPathXmlApplicationContext(String xmlFilePath);


Beans.xml-----> should be created in src/main/java
-----------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
    <bean id="credit" class="com.alchemist.beans.CreditCardPayment"/>
    <bean id="debit" class="com.alchemist.beans.DebitCardPayment"/>
    <bean id="payment" class="com.alchemist.beans.PaymentService">
    <!-- to avoid Nullpointer exception as PaymentService don't have by default constructor-->
       <!--constructor-arg name="payment" ref="debit"/-->----------------This is the constructor injection
       <!--constructor-arg name="payment" ref="credit"/-->
       <property name="iPayment" ref="credit"/>--------------------------- this is how settter injection done, property name should be interface referece variable
     </bean>
</beans>
-----------------------------------------------------------------------------
Note: 'ref' attribute represents which object should be injected
-Field injection is only possible with Annotations

Spring Bean Scope-->Decides how many objects should be crated for spring bean class
-Singleton(Default)--> Every Spring Bean is Singleton, whenever we start IOC container, by default it will create objects for singlton bens and when we call getBean()(everytime it checks scope when we call this method) then it will create object for others(for memory management)
-Prototype--->Every time new object will be created
-Request
-Session
Note: Request and Session scopes are used in Spring web MVC

Syntax:
    <bean id="car" class="com.alchemist.beans.CarService" scope="prototype">
       <constructor-arg name="car" ref="petrol"/>
     </bean>

Manual Wiring--> injecting dependent object into target objects with 'ref' attribute is Manual Wiring
Autowiring-->To identify objects and injecting into the Target objects
works on below modes
-byName--->for setter injection--->based on bean id of bean matching with interface variable
-byType--->for setter injection--->based on type of variable, dependent bean will be identified(bean id doesn't matter)
-Constructor
-none

Syntax:
--byName--->identity dependent based on variable name matching with bean id
<bean id="car" class="com.alchemist.beans.CarService" autowire="byName">
--When we write 'autowire' attribute in the bean definition, that bean will be considered as Target Class

--byType--->identity dependent bean based on variable type
  autowire-candidate="false"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" autowire-candidate="false"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">
     </bean>
  primary="true"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" primary="true"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <!--bean id="car" class="com.alchemist.beans.CarService" autowire="byName"-->
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">

--constructor--->First it will check byName, then goes for byType, we can use primary="true" for any bean which we want to inject
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="constructor">
     </bean>

Spring Annotations: Annotations are used to provide metadata
---------------------------------------------------------------------------
@Configuration:->Instead of XML, java class can be marked as Configuration
@Component,@Service,@Repository-->To represent java class as spring bean class
@Scope-->To represent scope of the bean
@Qualifier-->When multiple beans of same type, it is used to identity bean based on the given name for DI
@Autowired:-->used to enable auto-wiring in a class
@Primary-->To give priority for the bean for auto-wiring
@Bean:-->The @Bean annotation in Spring Boot is used to declare a method that produces a bean to be managed by the Spring IoC (Inversion of Control) container. This annotation is typically used within a @Configuration class, which signifies that the class's primary purpose is to define bean definitions. @Component auto-detects your beans, @Bean explicitly 
declares them.For third-party library classes or when you need custom instantiation logic
@ComponentScan(basePackages={"com.alchemist","edu.scaler"})-->It is the process of identifying spring bean classes available in project based on base packages name
Note:--Class that communicates with db is called Persistence Class/DAO Class. Whatever Exception getting from DB i.e SQLException will be truncated into our java side
--Classes which are utility like sending mail. generateReport are represented by @Component
--interfaces which has business logic get implementation class @Service annotation

-->Example name
package com.alchemist;------->Always keep Appconfig.java in base package rather than config package
@Configuration
@ComponentScan(basePackages = "com.alchemist")
public class AppConfig {

}

-eager loading-->IOC container creates object immediately from singleton beans
-lazy loading-->For Prototype ban when you create object then only object created

Autowiring with Spring Annotation(@Autowired)-->
@Autowired can be used at 3 places
-Variable level--Field injection
-Constructor level--Constructor injection
-Setter Mehtod level--Setter Injection

--Autowiring byName
-@Service
 public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

-@Repository("reportDAO")    //to do autowiring by name
 public class OracleDBReportDAO implements ReportDAO {

--Using @Qualifier
@Repository("mysqlDBDAO")
public class MysqlDBDAO implements ReportDAO {

@Repository("oracleDBDAO")
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    @Qualifier("oracleDBDAO")
    private ReportDAO reportDAO;

--Using @Primary
@Repository("oracleDBDAO")
@Primary
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

--Autowiring with Setter

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public void setReportDAO(@Qualifier("oracleDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

    public void generateReport() {
        System.out.println("ReportService - Generating Report");
        reportDAO.getData();
        System.out.println("ReportService - Report Generated");
    }

}
Note: also we can use @Primary

--Autowiring with Constructor

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public ReportService(@Qualifier("mysqlDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

Note: If we remove @Autowired here, still DI will happens as ReportService is Spring bean,i.e IOC should create object for ReportService when you have only one parameterized constructor in class @Autowired is optional. Wnen you have 2 constructors, DI will not happen withoult @Autowired
If we have one no param constructor and one Param constructor, then by default it will call 0-param constructor and DI will not happen

Spring bean life-Cycle
----------------------
init(),getData,destroy()
Bean life-Cycle methods can be executed in 3 ways
-Declarative approach(Xml file to configure)
    <!--Add attribute init-method and destroy-mehtod for Bean Lifecycle-->
    <bean id="dao" class="com.alchemist.UserDAO"
    init-method="init"
    destroy-method="destroy"
    />
	
-Programmatic approach(By using Interface)

public class UserDAO implements InitializingBean,DisposableBean{
	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

-Annotation approach
@Component
public class UserDAO{
	
	@PostConstruct
	public void init() {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	@PreDestroy
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

Main Class for all approaches
package com.alchemist;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class Application {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");---->XML Approach
		ApplicationContext context=new AnnotationConfigApplicationContext(AppConfig.class);----> annotation approach
		UserDAO dao = context.getBean(UserDAO.class);
		dao.getData();
		/*If we add this much code-->destroy() will not be executed, as in in main method no code to 
		 * to execute-->JVM shutdown i.e main method terminated--->IOC container have not got chance 
		 * to remove the object. so in order to see execution of destroy() add following code */
		ConfigurableApplicationContext ctxt = (ConfigurableApplicationContext)context;
		ctxt.close();

	}

}

@DependsOn:-->Wnen one bean dependent on another bean, we specify that DependsOn. (also this can be used in XML also)
We can specify single or multiple beans
@DependsOn("dao") 
@DependsOn(value={"dao","service"})

Ex-->Class A and Class B, Class B should fetch data from db and store into redis, then Class A will fetch data from redis. It will increase performance.
so here Class A dependent on Class B
In some cases, for creating object scanning happens according to alphabetical order--->Causes isssue

@Component("userDao") //writing the name of the bean
public class UserDao implements InitializingBean,DisposableBean{

@Service
@DependsOn("userDao")
public class UserService {
	public UserService() {
		System.out.println("Getting data from Redis...");
	}
----------------------------------------Spring Core Completed----------------------------------------------------------------------------------------------
Project Lombok-->Project Lombok is a Java library that helps you reduce boilerplate code,
i.e., the repetitive stuff like getters, setters, constructors, toString(), and equals() methods — by generating them automatically during compilation.
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.38</version>
</dependency>

| Annotation                 | Purpose                                                                                      |
| -------------------------- | -------------------------------------------------------------------------------------------- |
| `@Getter` / `@Setter`      | Creates getters and setters                                                                  |
| `@ToString`                | Generates `toString()`                                                                       |
| `@EqualsAndHashCode`       | Generates `equals()` and `hashCode()`                                                        |
| `@NoArgsConstructor`       | Generates a no-argument constructor                                                          |
| `@AllArgsConstructor`      | Generates a constructor with all fields                                                      |
| `@RequiredArgsConstructor` | Generates a constructor for final fields                                                     |
| `@Data`                    | Combines `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor` |
| `@Builder`                 | Enables the **Builder pattern**                                                              |
| `@Value`                   | Creates an **immutable class** (like `final` + all fields `private final`)                   |
| `@Slf4j`                   | Adds a logger instance automatically (`log.info("message")`)                                 |
-----------------------------------------------------------------------------------------------------------------------------

Spring Boot--->It is the Extension for Spring Framework
It is one approach, to develop Spring Based application with less configuration-->Develops Standalone, Web and Distributed i.e Microservices
Spring Boot = Spring - XML configuration + Auto Configuration + Embedded Servers + Actuator
We have following advantages-->
-Starter POM-->Simplifies Maven/Graddle build configuaration
It contains web-starter,datajpa-starter,Security-starter and mail-starter
--Auto Configuration--->Whatever common configuaration required for Spring boot will be taken care by Spring boot
e.g-->Creating db connection pool,Deploy Web Application in embeded server, Start IOC container, Component Scanning etc

Note: As Spring Boot executes from main(), war or jar doesn't matters

pom.xml------------>Add the following dependency
        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

@Service
public class ReportService {
	
	public ReportService() {
		/*
		 * this class is added to showcase that object is created by IOC when @Service
		 * annotation is added on the top of the class
		 */
		System.out.println("Report Service :: Constructor");
	}

}

--@SpringBootApplication--->@SpringBootConfiguration(-->@Configuration) + @EnableAutoConfiguration(-->AppConfig.java need not to write) + @ComponentScan

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

[32m :: Spring Boot :: [39m             [2m (v3.4.10)[0;39m

[2m2025-10-12T22:01:40.746+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m Starting Application using Java 17.0.16 with PID 9772 (D:\Projects\Spring-Boot-Projects\13-SB-first-App\target\classes started by Admin in D:\Projects\Spring-Boot-Projects\13-SB-first-App)
[2m2025-10-12T22:01:40.749+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m No active profile set, falling back to 1 default profile: "default"
[2m2025-10-12T22:01:41.406+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat initialized with port 8080 (http)
[2m2025-10-12T22:01:41.419+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.apache.catalina.core.StandardService  [0;39m [2m:[0;39m Starting service [Tomcat]
[2m2025-10-12T22:01:41.419+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.apache.catalina.core.StandardEngine   [0;39m [2m:[0;39m Starting Servlet engine: [Apache Tomcat/10.1.46]
[2m2025-10-12T22:01:41.452+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.a.c.c.C.[Tomcat].[localhost].[/]      [0;39m [2m:[0;39m Initializing Spring embedded WebApplicationContext
[2m2025-10-12T22:01:41.453+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mw.s.c.ServletWebServerApplicationContext[0;39m [2m:[0;39m Root WebApplicationContext: initialization completed in 657 ms
Report Service :: Constructor
[2m2025-10-12T22:01:41.738+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mr$InitializeUserDetailsManagerConfigurer[0;39m [2m:[0;39m Global AuthenticationManager configured with UserDetailsService bean with name inMemoryUserDetailsManager
[2m2025-10-12T22:01:41.855+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat started on port 8080 (http) with context path '/'
[2m2025-10-12T22:01:41.864+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m Started Application in 1.469 seconds (process running for 1.852)

Here in the console we can see IOC container started autoconfiguration,
Tomcat Started,Component scanning done by default,Security provided automatically

Spring Boot Actuator:---->It is a built-in module that exposes a set of production-ready endpoints (called Actuator Endpoints) to let you:
-Monitor application health
-Check configurations and environment properties
-View metrics (CPU, memory, threads, requests, etc.)
-Manage log levels at runtime
-View application beans and mappings
-Integrate with monitoring tools like Prometheus, Grafana, New Relic, etc.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

Default Endpoint-->http://localhost:8080/actuator
Common Endpoints
| Endpoint             | Description                                               |
| -------------------- | --------------------------------------------------------- |
| `/actuator/health`   | Shows application health (e.g., "UP" or "DOWN").          |
| `/actuator/info`     | Displays custom app info (version, name, etc.).           |
| `/actuator/metrics`  | Shows performance metrics like memory, CPU, GC, etc.      |
| `/actuator/beans`    | Lists all Spring Beans loaded in the context.             |
| `/actuator/env`      | Shows environment variables and configuration properties. |
| `/actuator/mappings` | Displays all HTTP mappings (useful for debugging).        |
| `/actuator/loggers`  | View and change log levels at runtime.                    |

---->application.properties
# Expose all endpoints
management.endpoints.web.exposure.include=*

# Change base path (optional)
management.endpoints.web.base-path=/manage

# Custom info endpoint data
info.app.name=PayrollApp
info.app.version=1.0.0
info.app.owner=Rohit Lavate

🧩 Use Case Example
In a real app (like your payroll or compliance system at Morningstar 👔):
-/actuator/health → used by a load balancer to check if service is alive
-/actuator/metrics/jvm.memory.used → used by Grafana to monitor memory
-/actuator/loggers → allows changing log level without restarting app

--Embedded servers
Apache Tomcat, Jetty, and Netty
| Feature             | Tomcat              | Jetty                         | Netty                          |
| ------------------- | ------------------- | ----------------------------- | ------------------------------ |
| Type                | Servlet container   | Servlet container             | NIO framework                  |
| Spring Boot default | ✅ Yes               | ❌ No                          | ❌ No                           |
| Performance         | Good                | Very good                     | Excellent                      |
| Concurrency         | Medium              | High                          | Very high                      |
| Blocking model      | Blocking            | Async (supports non-blocking) | Fully non-blocking             |
| Footprint           | Moderate            | Small                         | Small                          |
| Reactive support    | ❌                   | Partial                       | ✅ Full                         |
| Ideal for           | REST APIs, web apps | Microservices                 | Reactive, event-driven systems |

Class containing main() called as Start/Execution class/Main Class of spring boot.
Entry point for Spring boot application is run()-->It is static method(ClassName.methodName() to call).Starts IOC Container, IOC container object is return type of this method(i.e ConfigurableApplicationContext),
and also perform Component scanning
  ConfigurableApplicationContext context = SpringApplication.run(Application.class,args);
  Car c = context.getBean(Car.class);
 
--ConfigurableApplicationContext is an interface,it will provide implementation class of that class hold into variable
@SpringBootApplication
@RestController
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext context=SpringApplication.run(Application.class, args);---->Contains logic to start the IOC
		System.out.println(context.getClass().getName());
	}
}
--When we use 'web-starter'(i.e web-apps + REST API) in pom.xml----->AnnotationConfig'ServletWebServer'ApplicationContext class will be used to create object for IOC container
--For StandAlone application i.e boot-starter--->AnnotationConfigApplicationContext
--For Reactive Applications ie starter-webflux---->AnnotationConfig'ReactiveWebServer;ApplicationContext class
--If pom.xml contains--> web-starter + webflux-->Priority given to web-starter i.e among 3 web-starter gets priority

SpringBoot Banner-->3 modes as following
--Console(default)-->prints on the console
--log-->Prints on the log file
--off-->don't print banner

create a file-->src/main/resources/banner.txt
  ____             _             _       
 / ___| _ __  _ __(_)_ __  _   _| |_ ___ 
 \___ \| '_ \| '__| | '_ \| | | | __/ _ \
  ___) | |_) | |  | | | | | |_| | ||  __/
 |____/| .__/|_|  |_|_| |_|\__,_|\__\___|
       |_|        ${spring-boot.version}

Application: ${spring.application.name}------>You can use Spring placeholders:
Profile: ${spring.profiles.active}

--application.properties
spring.main.banner-mode=off--->To disable the banner
spring.main.banner-mode=log---->Setting to log file

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApplication.class);
        app.setBannerMode(Banner.Mode.OFF);
        app.run(args);
    }
}

-Dynamic custom Banner via Java Class
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApp.class);
        app.setBanner(new Banner() {
            @Override
            public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
                out.println("🌼 Custom Dynamic Banner 🌼");
                out.println("Active Profile: " + environment.getActiveProfiles()[0]);
            }
        });
        app.run(args);
    }
}

-->Internals of SpringApplication.run() step by step — 

⚙️ 1️⃣ Entry Point
SpringApplication.run(MyApp.class, args);

you’re actually calling a 'static helper' method that does this:

public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
    return new SpringApplication(primarySource).run(args);
}


So there are two main phases:
new SpringApplication(primarySource) → sets up the Spring Boot launcher.
.run(args) → starts the full lifecycle.

⚙️ 2️⃣ Phase 1: new SpringApplication()
This constructor prepares metadata about your application.
Key internals:
Detects Application type:
SERVLET → for web apps using Tomcat/Jetty.
REACTIVE → for WebFlux.
NONE → for CLI apps.

Registers ApplicationContext class to use (like AnnotationConfigServletWebServerApplicationContext).
Loads SpringApplicationRunListeners → these are “listeners” that react to lifecycle events (e.g., starting, environmentPrepared, etc.).
Initializes the main class (from the one having @SpringBootApplication).

⚙️ 3️⃣ Phase 2: run(args)
Here’s the internal flow simplified (core sequence):
🔹 Step 1: prepareEnvironment()
Creates or loads the Spring Environment (ConfigurableEnvironment)
Reads all property sources:
application.properties / application.yml
System environment variables
Command-line arguments
Applies profiles and merges configurations.

🔹 Step 2: printBanner()
Loads and prints the banner.txt (if spring.main.banner-mode ≠ off).
Uses BannerPrinter internally.

🔹 Step 3: createApplicationContext()
Creates an ApplicationContext instance based on app type:
For web apps → AnnotationConfigServletWebServerApplicationContext.
For reactive → AnnotationConfigReactiveWebServerApplicationContext.
For non-web → AnnotationConfigApplicationContext.

🔹 Step 4: prepareContext()
Loads ApplicationContextInitializers (custom setup before beans load).
Sets up environment in the context.
Publishes an event: ApplicationContextInitializedEvent.

🔹 Step 5: refreshContext()
This is the heart of Spring — triggers the entire bean creation lifecycle:
Scans packages (@ComponentScan)
Registers beans (@Bean, @Configuration, @Component)
Resolves dependency injection
Applies AOP proxies
Triggers @PostConstruct
Publishes ContextRefreshedEvent
Essentially, this is where IoC container starts and your app beans become live.

🔹 Step 6: afterRefresh()
Starts embedded web servers (Tomcat, Jetty, etc.) if it’s a web app.
Calls any ApplicationRunner or CommandLineRunner beans.

🔹 Step 7: runListeners.finished() and Context ready
Fires final events like ApplicationReadyEvent.
Returns a fully initialized ConfigurableApplicationContext.

🧠 Summary (in Simple Terms)

Here’s the flow as a quick visual:

SpringApplication.run()
│
├── Create SpringApplication object
├── Prepare Environment
├── Print Banner
├── Create ApplicationContext
├── Prepare Context
├── Refresh Context (Bean creation)
├── Run CommandLineRunner / ApplicationRunner
└── Application is READY ✅

🧩 Bonus: Key Interfaces Inside run()
| Component                                 | Purpose                                                    |
| ----------------------------------------- | ---------------------------------------------------------- |
| `SpringApplicationRunListener`            | Gets lifecycle events (startup, environmentPrepared, etc.) |
| `ApplicationContextInitializer`           | Customizes the context before beans load                   |
| `ApplicationRunner` / `CommandLineRunner` | Runs after app startup                                     |
| `SmartLifecycle`                          | Manages start/stop hooks                                   |

----->Spring Boot Startup Call Tree
SpringApplication.run(MyApp.class, args)
│
├─> SpringApplication.<init>(primarySource)
│   ├─ Detect application type (SERVLET / REACTIVE / NONE)
│   ├─ Set ApplicationContext class
│   └─ Load SpringApplicationRunListeners
│
├─> SpringApplication.run(args)
│   ├─ getRunListeners(args)
│   │   └─ Instantiate listeners from META-INF/spring.factories
│   │
│   ├─ listeners.starting()
│   │   └─ ApplicationStartingEvent
│   │
│   ├─ prepareEnvironment(listeners, args)
│   │   ├─ Create ConfigurableEnvironment (StandardEnvironment / WebEnvironment)
│   │   ├─ Load property sources:
│   │   │    ├─ application.properties / .yml
│   │   │    ├─ System env variables
│   │   │    └─ Command-line args
│   │   ├─ Apply profiles
│   │   └─ listeners.environmentPrepared(environment)
│   │
│   ├─ printBanner(environment)
│   │   └─ BannerPrinter.print(environment, sourceClass)
│   │
│   ├─ createApplicationContext()
│   │   ├─ AnnotationConfigServletWebServerApplicationContext (Web)
│   │   ├─ AnnotationConfigReactiveWebServerApplicationContext (Reactive)
│   │   └─ AnnotationConfigApplicationContext (Non-web)
│   │
│   ├─ prepareContext(context, environment, listeners)
│   │   ├─ context.setEnvironment(environment)
│   │   ├─ context.setId(...)
│   │   ├─ Apply ApplicationContextInitializers
│   │   └─ listeners.contextPrepared(context)
│   │
│   ├─ refreshContext(context)
│   │   └─ AbstractApplicationContext.refresh()
│   │       ├─ prepareBeanFactory()
│   │       ├─ postProcessBeanFactory()
│   │       ├─ invokeBeanFactoryPostProcessors()
│   │       ├─ registerBeanPostProcessors()
│   │       ├─ initMessageSource()
│   │       ├─ initApplicationEventMulticaster()
│   │       ├─ onRefresh() (hook for subclasses)
│   │       ├─ registerListeners()
│   │       ├─ finishBeanFactoryInitialization()
│   │       │    ├─ Instantiate singleton beans
│   │       │    ├─ Resolve DI
│   │       │    ├─ Apply @PostConstruct
│   │       │    └─ Apply AOP proxies
│   │       └─ finishRefresh()
│   │            └─ Publish ContextRefreshedEvent
│   │
│   ├─ afterRefresh(context, args)
│   │   ├─ Start embedded web server (if Web app)
│   │   ├─ Run ApplicationRunner beans
│   │   └─ Run CommandLineRunner beans
│   │
│   └─ listeners.finished(context, null)
│       └─ Publish ApplicationReadyEvent

Spring Boot Runners:--->
They are special interfaces that allow you to execute code once the application context is fully loaded 
but before the application starts accepting requests. They're perfect for initialization tasks, data setup, or validation checks.
Ex;-->In db their is static data, to get that data one time only when we start application is starting and save in the app.
UseCases-->Load Static table data when application starts, Delete data from staging tables(i.e Temporary table), Send notification regarding application startup
Two runners in the spring boot-->
--ApplicationRunner---->run()
--CommandLineRunner---->run()
Note: Both are functional interface, only one abstract method is available i.e run()
Key Point: Runners execute after the application context is fully refreshed but before the application is marked as fully ready (before ApplicationReadyEvent).
Spring Boot Startup:
├── Context Refresh (Bean creation, Dependency Injection)
├── Web Server Starts
├── ApplicationStartedEvent Published
├── 🏃 Runners Execute (in @Order sequence)
│   ├── CommandLineRunner @Order(1)
│   ├── ApplicationRunner @Order(2)
│   └── Other runners...
└── ApplicationReadyEvent Published (App is READY!)

@Component
public class MyApplicationRunner implements ApplicationRunner{

	@Override
	public void run(ApplicationArguments args) throws Exception {
		// TODO Auto-generated method stub
		System.out.println("ApplicationRunner run().. method");
	}

}

spring-boot-autoconfigure-x.x.x.jar---->
It contains all the pre-written configuration classes that Spring Boot uses to automatically set up:
-Data sources (JDBC, JPA, MongoDB)
-Web servers (Tomcat, Jetty, Undertow)
-Spring MVC
-Security
-Actuator
-Mail, Kafka, Redis, Quartz, etc.

META-INF/spring-factories---->Contains initializers and listeners
In the run()-->createBootStrapContext() and getRunListeners(args)-->From factories file they load classes available, they will create object and they
will call methods. These classes load configuration required for our application
SpringApplication.run()
        │
        ├── createBootstrapContext()
        │      └── DefaultBootstrapContext created
        │      └── Initializers registered (for logging, env)
        │
        ├── getRunListeners(args)
        │      └── Load EventPublishingRunListener
        │      └── Prepare lifecycle event handlers
        │
        ├── listeners.starting()
        │      └── Fire ApplicationStartingEvent
        │
        ├── prepareEnvironment()
        │      └── Load application.properties / YAML
        │
        ├── createApplicationContext()
        │      └── Instantiate main ApplicationContext
        │
        ├── refreshContext()
        │      └── Load all beans
        │
        └── callRunners()
               └── Execute CommandLineRunner / ApplicationRunner
public ConfigurableApplicationContext run(String... args) {
    long startTime = System.nanoTime();

    // 1️⃣ Create initial context
    DefaultBootstrapContext bootstrapContext = createBootstrapContext();

    ConfigurableApplicationContext context = null;
    configureHeadlessProperty();

    // 2️⃣ Create listeners for startup events
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting(bootstrapContext, this.mainApplicationClass);

    try {
        // 3️⃣ Prepare environment
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);

        // 4️⃣ Create and refresh ApplicationContext
        context = createApplicationContext();
        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments);
        refreshContext(context);

        // 5️⃣ Call CommandLineRunners / ApplicationRunners
        afterRefresh(context, applicationArguments);
        listeners.started(context);
        callRunners(context, applicationArguments);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, listeners);
    }

    listeners.ready(context);
    return context;
}

Spring Data JPA--->used to develop Persistence layer logic, Simplifies CRUD operations implemenations in project
--Java JDBC,Spring JDBC, Hibernate Framework,Spring ORM, Spring Data JPA-->Ways to develop persistence logic
--In Spring Data JPA, we need to write 0 methods to perform CRUD operations, uses Hibernate framework internally.(If performance is crucial for application,
then directly go with JDBC as it will execute query directly on db)
Java App--->Spring Data JPA(Hibrenate ORM-->JDBC)-->DB
--If you want everything in object format, then go with Hibernate framework/Spring Data JPA
Note: If we have 5000 DB tables then, we have to create 5000 DAO classes. Every dao class should contains 4 common methods so it will become 20000 methods 
with same logic(This is not recommended--->To avoid boilerplate code we use Spring Data JPA)
--In Spring Data JPA-->DAO is called as Repository, and it provided Repository interfaces as follows
CrudRepository(CRUD operations method)
JpaRepository(CRUD operations method + Pagination + Sorting + QBE)
--data-jpa-starter
Driver will be loaded
Connection will be created
SessionFactory will be created
Transaction will be happening

Repository (I)
   ↑
   └── CrudRepository (I)        --> (12 methods)
           ↑
           └── PagingAndSortingRepository (I)
                   ↑
                   └── JpaRepository (I)
                           ↑
                           └── QueryByExampleExecutor (I)

JpaRepository is grandchild of CrudRepository
| Interface                      | Extends From                                       | Purpose                                                                               |
| ------------------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Repository**                 | —                                                  | Marker interface (root of Spring Data hierarchy).                                     |
| **CrudRepository**             | Repository                                         | Provides CRUD operations like `save()`, `findById()`, `delete()`, etc. (≈12 methods). |
| **PagingAndSortingRepository** | CrudRepository                                     | Adds pagination and sorting support (`findAll(Pageable)`, `findAll(Sort)`).           |
| **JpaRepository**              | PagingAndSortingRepository, QueryByExampleExecutor | Adds JPA-specific methods like `flush()`, `saveAndFlush()`, and batch operations.     |
| **QueryByExampleExecutor**     | —                                                  | Provides methods for Query by Example (QBE) functionality.                            |
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--CrudRepository 
| Method                  | Signature                                                 | Description                                                   | Example                               |
| :---------------------- | :-------------------------------------------------------- | :------------------------------------------------------------ | :------------------------------------ |
| **save**                | `<S extends T> S save(S entity)`                          | Saves a single entity. Inserts if new, updates if ID exists.  | `repo.save(emp);`                     |
| **saveAll**             | `<S extends T> Iterable<S> saveAll(Iterable<S> entities)` | Saves all entities in batch. Inserts new, updates existing.   | `repo.saveAll(listOfEmployees);`      |
| **findById**            | `Optional<T> findById(ID id)`                             | Retrieves entity by ID. Returns `Optional` to avoid nulls.    | `repo.findById(1L);`                  |
| **existsById**          | `boolean existsById(ID id)`                               | Checks if an entity with the given ID exists.                 | `repo.existsById(5L);`                |
| **findAll**             | `Iterable<T> findAll()`                                   | Retrieves all entities in the repository.                     | `repo.findAll();`                     |
| **findAllById**         | `Iterable<T> findAllById(Iterable<ID> ids)`               | Retrieves all entities for the given IDs.                     | `repo.findAllById(List.of(1L,2L));`   |
| **count**               | `long count()`                                            | Returns the total number of entities in the repository.       | `repo.count();`                       |
| **deleteById**          | `void deleteById(ID id)`                                  | Deletes the entity with the given ID.                         | `repo.deleteById(3L);`                |
| **delete**              | `void delete(T entity)`                                   | Deletes the given entity.                                     | `repo.delete(emp);`                   |
| **deleteAllById**       | `void deleteAllById(Iterable<? extends ID> ids)`          | Deletes all entities for the given IDs.                       | `repo.deleteAllById(List.of(1L,2L));` |
| **deleteAll(entities)** | `void deleteAll(Iterable<? extends T> entities)`          | Deletes all given entities in batch.                          | `repo.deleteAll(listOfEmployees);`    |
| **deleteAll()**         | `void deleteAll()`                                        | Deletes **all entities** in the repository. Use with caution. | `repo.deleteAll();`                   |

🔹 Notes:
save():If entity ID is null or not in DB → insert.(First Select Query then insert query)-->Polymorphic method
If entity ID exists in DB → update.
findById() returns Optional<T> → helps avoid NullPointerException.
findAll() and count() → useful for pagination & reporting.
Deletion methods are safe, but deleteAll() removes everything — be careful.
While executing findAll()-->It executing select query
                            Retrieving records in form of ResultSet
							Moving Cursor of ResultSet
							Taking each row from ResultSet and setting it to Entity Object
							Adding Entity object to Collection and Returning
							
Requirement:-->Retrieve books whose price>=200-->Non Primary key columns
Solution--> findBy methods
        --> Custom Quries
		
findBy methods	
| Method                         | Generated SQL      | Description               |
| :----------------------------- | :----------------- | :------------------------ |
| `findByName(String name)`      | `WHERE name = ?`   | Finds all with exact name |
| `findByRole(String role)`      | `WHERE role = ?`   | Finds by role             |
| `findById(Long id)`            | `WHERE id = ?`     | Finds by ID               |
| `findBySalary(Double salary)`  | `WHERE salary = ?` | Finds by salary           |
| `findByActive(boolean active)` | `WHERE active = ?` | Finds by boolean column   |
----------------------------------------------------------------------------------
| Interface                      | Extends From                                       | Purpose                                                                               |
| ------------------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Repository**                 | —                                                  | Marker interface (root of Spring Data hierarchy).                                     |
| **CrudRepository**             | Repository                                         | Provides CRUD operations like `save()`, `findById()`, `delete()`, etc. (≈12 methods). |
| **PagingAndSortingRepository** | CrudRepository                                     | Adds pagination and sorting support (`findAll(Pageable)`, `findAll(Sort)`).           |
| **JpaRepository**              | PagingAndSortingRepository, QueryByExampleExecutor | Adds JPA-specific methods like `flush()`, `saveAndFlush()`, and batch operations.     |
| **QueryByExampleExecutor**     | —                                                  | Provides methods for Query by Example (QBE) functionality.                            |
--findBy methods are used to perfrom only select operations
--Using non primary key columns we can select records
--In findBy methods, method name is very important-->based on method name JPA will construct the query for execution
Note:findBy method should represent Entity class variables

Custom Queries--> If we want to execute our own query, we can write in 2 ways-->@Query annotation
-HQL Queries(Hibernate Query Language)--->Independent of db i.e can't execute on db directly
-Native SQL Queries(Ex--> select * from book)
Note:-->We can write custom query to update and delete,but not insert(direct insert not supported). Insert from one table to other table is supported.
| Type            | Annotation                      | Description                         | Example                                              |
| --------------- | ------------------------------- | ----------------------------------- | ---------------------------------------------------- |
| Derived Query   | —                               | Auto-generated based on method name | `findByName(String name)`                            |
| JPQL Query      | `@Query`                        | Uses entity and field names         | `@Query("SELECT e FROM Employee e WHERE e.id=:id")`  |
| Native Query    | `@Query(..., nativeQuery=true)` | Uses table and column names         | `@Query("SELECT * FROM employee", nativeQuery=true)` |
| Modifying Query | `@Modifying` + `@Transactional` | For UPDATE/DELETE/INSERT            | `@Query("DELETE FROM Employee e WHERE e.id=:id")`    |
| Named Query     | `@NamedQuery`                   | Predefined query inside Entity      | Defined in entity, used in repo                      |
| Projection      | `@Query` with interface         | Select specific columns only        | `SELECT e.name, e.salary`                            |
| Dynamic Query   | SpEL + `@Query`                 | Evaluate expressions at runtime     | `:#{#param}`                                         |
| Joins           | `@Query`                        | For relational fetching             | `JOIN e.department d`                                |
--------------------------------------------------------------------------------------------------------------------------------------------------
--HQL vs SQL
| **Feature**                      | **HQL (Hibernate Query Language)**                    | **SQL (Structured Query Language)**                      |
| -------------------------------- | ----------------------------------------------------- | -------------------------------------------------------- |
| **Full Form**                    | Hibernate Query Language                              | Structured Query Language                                |
| **Works On**                     | Java **entities and their properties**                | **Database tables and columns**                          |
| **Abstraction Level**            | Object-oriented (ORM layer)                           | Relational (Database layer)                              |
| **Language Type**                | Object-based query language                           | Database query language                                  |
| **Dependency on Database**       | Independent (portable across databases)               | Dependent (vendor-specific syntax may vary)              |
| **Return Type**                  | Entity objects or projections                         | ResultSet (raw database rows)                            |
| **Mapping**                      | Automatically mapped to entity classes                | Manual mapping needed (unless ORM used)                  |
| **Case Sensitivity**             | Entity names and field names are case-sensitive       | Table/column names depend on DB vendor                   |
| **Joins**                        | Uses entity relationships (e.g., `JOIN e.department`) | Uses explicit joins (e.g., `JOIN department ON ...`)     |
| **Data Retrieval**               | Returns persistent objects                            | Returns raw data (rows and columns)                      |
| **Query Example**                | `FROM Employee e WHERE e.salary > 50000`              | `SELECT * FROM employee WHERE salary > 50000`            |
| **Updates & Deletes**            | Supported (`UPDATE`, `DELETE`) but on entities        | Fully supported (`UPDATE`, `DELETE`) on tables           |
| **Aggregations**                 | Supported (`COUNT`, `SUM`, etc.)                      | Supported (`COUNT`, `SUM`, etc.)                         |
| **Named Parameters**             | Supported (`:paramName`)                              | Positional parameters (`?`) mostly used                  |
| **Automatic Conversion**         | Yes — Hibernate converts HQL to SQL internally        | No — SQL executes as written                             |
| **Portability**                  | High — works with any DB supported by Hibernate       | Low — syntax may differ across DBs                       |
| **Performance Tuning**           | Controlled by Hibernate                               | Controlled by database directly                          |
| **Use Case**                     | Ideal for standard CRUD, entity-based queries         | Ideal for complex, DB-specific queries and optimizations |
| **Supports Native DB Functions** | Limited                                               | Fully supported                                          |
| **Relationship Navigation**      | Easy (uses mapped associations)                       | Manual joins required                                    |
| **Ease of Use**                  | Easier and cleaner for ORM-based apps                 | Requires SQL and schema knowledge                        |
| **Example in Hibernate**         | `session.createQuery("FROM Employee").list();`        | `session.createNativeQuery("SELECT * FROM employee");`   |

--When to use
| **Scenario**                                       | **Recommended Query Type** |
| -------------------------------------------------- | -------------------------- |
| CRUD operations using entities                     | HQL                        |
| Complex joins using entity relationships           | HQL                        |
| Vendor-specific SQL functions or stored procedures | SQL                        |
| Reporting and analytics queries                    | SQL                        |
| Cross-database portability required                | HQL                        |
| Heavy performance tuning or DB optimizations       | SQL                        |


public interface BookRepository extends CrudRepository<Book, Integer> {
	
	public List<Book> findByBookPriceGreaterThan(Double price);
	
	//nateive query
	@Query(value="select * from book", nativeQuery=true)
	public List<Book> getAllBooks();
	
	//HQL Query
	@Query("from Book")
	public List<Book> getBooks();

}
-Dialect class converts HQL queries to SQL Queries i.e maintenance wise HQL queries are good-->Every DB have it's own dialect class
Ex:==OracleDialect,MySQLDialect,DB2Dialect,PostgresDialect etc...
Note: Dialect class will be loaded along with DB driver class
1000 HQL Queries--->MysQL dialect-->MysQLDB
1000 HQL Queries--->Oracle dialect-->OracleDB
i.e we can change db effortlessely.
Example
=======
select * from book(Table in db)==========from Book(Entity Class)
select * from book where book_price=200(book_price is column name)====from book where bookPrice=200(here bookPrice is variable)
selct book_name from book=====select bookName form Book
| **Term**       | **Meaning**                                  | **Affects**       | **SQL Clause** | **Example**                         |
| -------------- | -------------------------------------------- | ----------------- | -------------- | ----------------------------------- |
| **Selection**  | Filters specific **rows** based on condition | Number of rows    | `WHERE`        | `SELECT * FROM emp WHERE dept='HR'` |
| **Projection** | Selects specific **columns** from a table    | Number of columns | `SELECT`       | `SELECT name, salary FROM emp`      |

--JpaRepository:-->
| **Aspect**                    | **Description / Example**                                                                                                                                                                                                                                                                                                                   |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**                | `JpaRepository` is an interface in Spring Data JPA that provides **CRUD operations + JPA-specific methods**. It extends `PagingAndSortingRepository` and CrudRepository`.                                                                                                                                                                  |
| **Basic Syntax**              | `java<br>@Repository<br>public interface BookRepository extends JpaRepository<Book, Integer> { }<br>`<br>Book = entity class, Integer = primary key type                                                                                                                                                                                    |
| **Built-in Methods**          | `save(entity)`, `findById(id)`, `findAll()`, `delete(entity)`, `count()`, `existsById(id)`                                                                                                                                                                                                                                                  |
| **Derived Query Methods**     | Spring generates queries from method names:<br>`List<Book> findByBookName(String name);`<br>`List<Book> findByBookPriceGreaterThan(Double price);`<br>`List<Book> findByBookNameContaining(String keyword);`                                                                                                                                |
| **Custom Queries (`@Query`)** | JPQL: <br>`java<br>@Query("SELECT b FROM Book b WHERE b.bookPrice > :price")<br>List<Book> findExpensiveBooks(@Param("price") Double price);<br>`<br>Native SQL: <br>`java<br>@Query(value = "SELECT * FROM book WHERE book_price > :price", nativeQuery = true)<br>List<Book> findExpensiveBooksNative(@Param("price") Double price);<br>` |
| **Paging & Sorting**          | Inherited from `PagingAndSortingRepository`:<br>`Page<Book> findAll(Pageable pageable);`<br>`List<Book> findAll(Sort sort);`<br>Example:<br>`Pageable pageable = PageRequest.of(0, 5, Sort.by("bookPrice").descending());`<br>`Page<Book> page = bookRepository.findAll(pageable);`                                                         |
| **Key Interfaces**            | `CrudRepository` → basic CRUD<br>`PagingAndSortingRepository` → pagination & sorting<br>`JpaRepository` → JPA-specific methods + all above                                                                                                                                                                                                  |
| **Advantages**                | ✅ No implementation needed — Spring generates it<br>✅ Supports derived queries<br>✅ Supports custom JPQL/native queries<br>✅ Built-in pagination and sorting                                                                                                                                                                                |

Note:
findAll()---->Retrieves all the records
Page<Book> findAll(Pageable pageable)------>Retrieves record with pagination
List<Book> findAll(Sort sort)----->Retrieves records wit sorting

Example.of() lets you build dynamic queries without writing JPQL or method names.
You create a probe (sample entity) with some fields set, and Spring Data JPA finds matching records.

@SpringBootApplication
public class Application {

    private final EmpRepository empRepository;

    Application(EmpRepository empRepository) {
        this.empRepository = empRepository;
    }

	public static void main(String[] args) {
		ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
		EmpRepository empRepo = context.getBean(EmpRepository.class);
		System.out.println("EmpRepository Bean is: " + empRepo.getClass().getName());

		/*
		 * Employee e1 = new Employee();
		 * 
		 * e1.setEmpName("John Doe"); e1.setEmpSalary(50000.0); e1.setEmpGender("Male");
		 * e1.setEmpDept("IT"); empRepo.save(e1);--------------------------------------------->when save() executed ID and create_Date field in the db gets updated
		 * 
		 * e1.setEmpName("Jane Smith"); e1.setEmpSalary(30000.0);
		 * e1.setEmpGender("Female"); e1.setEmpDept("HR");
		 * 
		 * Employee e2 = new Employee(); e2.setEmpName("Alice Johnson");
		 * e2.setEmpSalary(35000.0); e2.setEmpGender("Female"); e2.setEmpDept("HR");
		 * 
		 * Employee e3 = new Employee(); e3.setEmpName("Bob Brown");
		 * e3.setEmpSalary(40000.0); e3.setEmpGender("Male"); e3.setEmpDept("IT");
		 * 
		 * empRepo.saveAll( java.util.List.of(e1, e2, e3) );
		 * System.out.println("Employees saved successfully!");
		 */

		List<Employee> listbySalaryDesc = empRepo.getEmployeeBySalaryDesc();
		listbySalaryDesc.forEach(System.out::println);
		System.out.println("-----------------------------------------------------");
		
		// ascending order by bookName
		Sort sortByNameAsc = Sort.by("empName").ascending();
		//List<Employee> empAsc = empRepo.findAll(Sort.by("empName").ascending());
		List<Employee> empAsc = empRepo.findAll(sortByNameAsc);
		empAsc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//Sort sortByDeptDesc = Sort.by("empDept").descending();
		Sort sortByDeptDesc = Sort.by(Sort.Direction.DESC, "empDept");
		List<Employee> empDeptDesc = empRepo.findAll(sortByDeptDesc);
		empDeptDesc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//sorting based on multiple fields
		//Sort sortByDeptAscAndSalaryDesc = Sort.by("empDept","empSalary").ascending();
		Sort sortByDeptAscAndSalaryDesc = Sort.by("empDept").ascending()
                .and(Sort.by("empSalary").descending());
		List<Employee> empDeptAscAndSalaryDesc = empRepo.findAll(sortByDeptAscAndSalaryDesc);
		empDeptAscAndSalaryDesc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		int pageNumber = 0; // first page
		PageRequest page = PageRequest.of(pageNumber, 2);
		Page<Employee> empPage = empRepo.findAll(page);
		List<Employee> empList = empPage.getContent();
		empList.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		int peNum = 0; // first page
		PageRequest pg = PageRequest.of(peNum, 3, Sort.by("empName").ascending());
		Page<Employee> empPg = empRepo.findAll(pg);
		List<Employee> empLst = empPg.getContent();
		empLst.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//to filter according to the column name--->i.e where clause
		 Employee emp = new Employee();
		 emp.setEmpDept("IT");   // We want to find all employees from IT dept
		 Example<Employee> example = Example.of(emp);
		 List<Employee> result = empRepo.findAll(example);
		 result.forEach(System.out::println);
		 System.out.println("------------------------------------------------------");
		 
		 Employee e =new Employee();
		 e.setEmpDept("HR");
		 e.setEmpGender("Male");
		 Example ex = Example.of(e);
		 List<Employee> res = empRepo.findAll(ex);
		 res.forEach(System.out::println);
		 System.out.println("------------------------------------------------------");
		 
		 ExampleMatcher matcher = ExampleMatcher.matching()
			        .withIgnoreCase("empName")
			        .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);
			Employee e2 = new Employee();
			e2.setEmpName("swapnil"); // will match "Swaobuk", "Swapnila", "Mr. Swapnil" etc.
			Example<Employee> exemp = Example.of(e2, matcher);
			List<Employee> output = empRepo.findAll(exemp);
			output.forEach(System.out::println);
	
	}

}
------------------------------------------------------
	@CreationTimestamp
	@Column(name="date_created",updatable = false)
	private LocalDateTime dateCreated;
	
	@Column(name="last_updated", insertable = false)
	@UpdateTimestamp
	private LocalDateTime lastUpdated;
------------------------------------------------------
--Primary Key constraint is combination of following 2 constraints--->(Without Pk-->IdentifierGenerationException)
Unique
Not Null

Note: User should only enter Non Primary key value, Primary key should be generated by us i.e application. That is when Generator comes into picture

--IdentifierGenerationException occurs when Hibernate fails to generate a primary key (ID) for an entity during the persist() or save() operation.
| **Cause**                              | **Description**                                                                    | **Example**                                                                                  | **Fix / Solution**                                                                                                |
| -------------------------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **1. Missing @GeneratedValue**         | You annotated the ID with `@Id` but didn’t tell Hibernate *how* to generate it.    | `java @Id private Integer id; `                                                              | Add a generation strategy:<br>`java @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; ` |
| **2. Unsupported Generation Strategy** | The chosen strategy doesn’t match your DB capabilities.                            | Using `SEQUENCE` in MySQL (which doesn’t support sequences).                                 | Use `IDENTITY` for MySQL.<br>Use `SEQUENCE` for Oracle/PostgreSQL.                                                |
| **3. Manually assigned ID not set**    | If you didn’t use `@GeneratedValue`, Hibernate expects you to set the ID manually. | `java @Id private Integer id;` and not setting `id`.                                         | Either set the ID manually or use `@GeneratedValue`.                                                              |
| **4. Sequence/Table not found**        | The sequence or table used for ID generation doesn’t exist in the DB.              | `java @SequenceGenerator(name="seq", sequenceName="user_seq")` but `user_seq` doesn’t exist. | Manually create the sequence in DB, or let Hibernate create it using `spring.jpa.hibernate.ddl-auto=update`.      |
| **5. Wrong column mapping**            | The ID column name doesn’t match the actual DB column.                             | DB column is `book_id`, but entity says `id`.                                                | Add `@Column(name="book_id")` above your ID field.                                                                |
| **6. Embeddable ID issues**            | When using `@EmbeddedId` or `@IdClass`, Hibernate can’t determine ID properly.     | Incorrectly mapped composite key.                                                            | Ensure all key fields are properly annotated and present in both ID class and entity.                             |


## 🧩 JPA Built-in Generation Strategies

| STRATEGY        | DATABASE SUPPORT                     | PERFORMANCE | BATCH INSERT | CODE EXAMPLE                                                                                                          | USE CASES                                   | PROS                              | CONS                             |
|-----------------|--------------------------------------|-------------|---------------|----------------------------------------------------------------------------------------------------------------------|---------------------------------------------|-----------------------------------|----------------------------------|
| **AUTO (Default)** | All databases                      | Varies      | Varies        | `@GeneratedValue(strategy = GenerationType.AUTO)`                                                                    | Database portability, simple projects       | Database agnostic, easy setup     | Unpredictable behavior across DBs |
| **IDENTITY**    | MySQL, SQL Server, PostgreSQL, H2, DB2 | Good        | ❌             | `@GeneratedValue(strategy = GenerationType.IDENTITY)`                                                                | Simple auto-increment fields, small apps    | Simple, widely supported          | No batch inserts, pre-insert select |
| **SEQUENCE**    | Oracle, PostgreSQL, H2, DB2          | Excellent   | ✅             | ```java                                                                                                              |
|                 |                                      |             |               | @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "seq")                                              |
|                 |                                      |             |               | @SequenceGenerator(name = "seq", sequenceName = "user_seq")                                                         |
|                 |                                      |             |               | ```                                                                                                                 | High-performance enterprise apps            | Best performance, batch supported | Database-specific                 |
| **TABLE**       | All databases                        | Fair        | ✅             | ```java                                                                                                              |
|                 |                                      |             |               | @GeneratedValue(strategy = GenerationType.TABLE, generator = "tab")                                                 |
|                 |                                      |             |               | @TableGenerator(name = "tab", table = "id_gen")                                                                     |
|                 |                                      |             |               | ```                                                                                                                 | Legacy systems, no sequence support         | Database independent              | Slower, table locking issues      |

Note: For SEQUENCE, the table will be created for storing next_val. and IDNTITY support for AUTO-INCREMENT(in console query contains auto_increment).TABLE maintains seperate table for PK
see console for TABLE-->same way check for other --->3 queries for each operation-->degrades the performance
Hibernate: select tbl.next_val from hibernate_sequences tbl where tbl.sequence_name=? for update
Hibernate: update hibernate_sequences set next_val=?  where next_val=? and sequence_name=?
Hibernate: insert into book (book_name,book_price,book_id) values (?,?,
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Why Use Wrapper Classes Instead of Primitive Types
| **Aspect**          | **Primitive Type (`int`, `long`)**   | **Wrapper Type (`Integer`, `Long`)**   | **Explanation**                                                                                                                               |
| ------------------- | ------------------------------------ | -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| **Default Value**   | Always has a default (e.g. `0`)      | Can be `null`                          | Hibernate uses `null` to detect *new (unsaved)* entities. If ID = 0, Hibernate gets confused and may try to **update** instead of **insert**. |
| **Nullability**     | Cannot be `null`                     | Can be `null`                          | Database columns are often nullable — primitives cannot represent null.                                                                       |
| **ID Generation**   | Causes issues with `@GeneratedValue` | Works perfectly with `@GeneratedValue` | Hibernate expects the ID to be `null` before insert, so it can generate one.                                                                  |
| **Optional Values** | Always initialized                   | Can be optional                        | Some business fields may not always have a value at creation time.                                                                            |
| **Boxing/Unboxing** | Not needed                           | Automatic                              | Negligible impact, but safer for ORM frameworks.                                                                                              |

Custom Generator---->We should implement Generator interface which has generate().
eg:-->OD1,OD2,OD3,....--->Prefix(Fixed=OD) + Suffix(Number-->Variable and increment by 1)

public class OrderIdGenerator implements IdentifierGenerator{

	@Override
	public Serializable generate(SharedSessionContractImplementor session, Object object) {
		
		String prefix = "OD";
		String suffix = "";
		try {
			Connection connection = session.getJdbcConnectionAccess().obtainConnection();
			Statement statement = connection.createStatement();
			String query = "SELECT ORDER_ID_SEQ.NEXTVAL as nextval FROM DUAL";
			ResultSet result = statement.executeQuery(query);
			if(result.next()) {
				int seqVal = result.getInt(1);
				suffix = String.valueOf(seqVal);
			}
		}catch (Exception e) {
			e.printStackTrace();
		}
		return prefix + suffix;
	}

}

Composite Primary Key--->
@Data
@Embeddable
public class AccountPK {
	
	private String accNum;
	
	private String accType;

}

@Entity
@Table(name = "account_tbl")
@Data
public class Account {
	
	private String holderName;
	
	private String branch;
	
	@EmbeddedId
	private AccountPK accountPK;

}

public interface AccountRepository extends JpaRepository<Account, AccountPK> {

}

Note:Generators are not applicable for composite primary key. If you have composite primary key, you have to set values manually.
The Class which is representing composite keys should implement Serializable interface(Marker interface-->Used to give special instructions to JVM)

Profiles in Spring Boot-->
Every project will have multiple environments(Platform which used to run our application)-->DEV ENV,STG ENV, SIT ENV, PROD ENV
Environment contains-->Server(Linux VM),DB Server,Log Server etc. Every environment has its own DB and every DB will have seperate configuartion properties(uname,password,url etc)
If we want to deploy our code to multiple environments then we have to change datasource properties in the application.prooperties file-->Chance of mistake
So to avoid mistakes, concept of profile comes in spring boot-->Profiles are used to configure environment specific properties
application.properties contains--->DB Properties,SMTP properties,Kafka properties,Redis properties,REST API endpoint URLs
src/main/resources/
 ├── application.properties              # Default (active if no profile set)
 ├── application-dev.properties           # For dev
 ├── application-test.properties          # For testing
 └── application-prod.properties          # For production
 
--->Spring WebMVC----->simplifies Web Application Development process
 Dependency--->spring-boot-starter-web-->provides support for MVC based web application, RESTFul Services, Embedded container(Tomcat)
 Advantages-->It supports form binding(Form Data binds to Java Object)
              Flexibility in Form Binding(Type conversion-->convert data in particular data type)
			  Multiple presentation technologies(JSP and Thymeleaf)
			  Form tag library(Ready Made tag supports)
			  
MVC Architecture Flow
Client Request → DispatcherServlet → Controller → Service → DAO → Database
       ↑                                              ↓
Client Response ← View ← Model ← Controller ← Service ←

---->Detailed Flow
CLIENT REQUEST
    ↓
DispatcherServlet (Front Controller/Framework Servelet)---->Responsible for performing Pre-Processing and Post-Processing
    ↓
Handler Mapping (Finds appropriate controller)---->As multiple controllers, DispatcherServlet doesn't know which method responsible to handle request, so it will give request to HandlerMapper it will scans url mapping and give that detail back to DispatcherServlet. DispatcherServelet will go to that Controller class and Controller method
    ↓
Controller (Processes request)
    ↓
Service Layer (Business logic)
    ↓
DAO/Repository (Data access)
    ↓
Database
    ↑
Controller ← Service ← DAO (Return data)
    ↓
Model (Adds data)
    ↓
View Resolver (Finds view template)
    ↓
View (JSP/Thymeleaf) + Model
    ↓
CLIENT RESPONSE

┌─────────────────────────────────────────────────────────────────────────┐
│                            CLIENT BROWSER                               │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ HTTP Request (URL, Form Data, Parameters)
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                        DispatcherServlet                                │
│  (Front Controller - Single entry point for all requests)               │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │
                                ↓ Delegates to appropriate components
┌─────────────────────────────────────────────────────────────────────────┐
│                         Handler Mapping                                 │
│  (Maps request to appropriate Controller)                               │
│  - @RequestMapping, @GetMapping, @PostMapping etc.                     │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Returns HandlerExecutionChain
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                         Controller                                      │
│  (Processes business logic)                                             │
│  - @Controller, @RestController                                         │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Calls Service Layer
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                         Service Layer                                   │
│  (Business logic implementation)                                        │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Calls DAO/Repository
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                    DAO/Repository Layer                                 │
│  (Data access operations)                                               │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Interacts with Database
                                ↓
                          ┌───────────┐
                          │ DATABASE  │
                          └───────────┘
                                ↑
                                │ Returns data
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                         Controller                                      │
│  (Prepares Model data)                                                  │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Returns ModelAndView or ResponseEntity(Model-->Represents data in key-value format, View-->Logical File Name)
								|(Note -->Controllers are loosely coupled with Presentation technology as Multiple presentation techniques are their-->To identify presentation technology it will talk to view resolver)
								| (ViewResolver identifies where is the view file in the project and what is the view technology(i.e Presentation Technology)
                                ↓
								
┌─────────────────────────────────────────────────────────────────────────┐
│                         View Resolver                                   │
│  (Resolves view name to actual view template)                           │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Returns View object
								| (After Identifying it will give that info to DispatcherServelet, which will send model data to View Component)
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                            View                                         │
│  (Renders response using template + model data)                         │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Rendered HTML/JSON/XML(i.e render model data in the view file and give it to DispatcherServelet)
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                        DispatcherServlet                                │
│  (Sends response to client)                                             │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ HTTP Response
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                            CLIENT BROWSER                               │
└─────────────────────────────────────────────────────────────────────────┘
-------------------------------------------------------------------------------------
┌─────────────────────────────────────────────────────────────┐
│                        CLIENT                               │
│                                                             │
│                    HTTP Request  →→→→→→→→→→→→→→→→→→→→→→→→   │
│                                                             │
│                    ←←←←←←←←←←←←←←←←←←←← HTTP Response       │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                    DispatcherServlet                        │
│                                                             │
│          ↗ Pre-processing                                   │
│          ↖ Post-processing                                  │
└─────────────────────────┬───────────────────────────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
          ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   Handler       │ │    Controller    │ │   View Resolver │
│   Mapping       │ │                 │ │                 │
└─────────────────┘ └─────────────────┘ └─────────────────┘
          │               │                       │
          │               │                       │
          ▼               ▼                       ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  URL to Controller│ │  Business Logic │ │ Logical to     │
│   Mapping        │ │   Processing    │ │ Physical View  │
└─────────────────┘ └─────────────────┘ └─────────────────┘
                                          │
                                          │
                                          ▼
                                 ┌─────────────────┐
                                 │      View       │
                                 │  (JSP/HTML/etc) │
                                 └─────────────────┘
								 
To Create Spring MVC app we need to add following dependencies-->
--spring-boot-starter-web
--spring-boot-devtools
--tomcat-embed-jasper(Only when using JSP as Presentation Technology, but spring supports Thymeleaf)<----Add externally

-Application.java          ← Main Spring Boot app
-ServletInitializer.java   ← WAR entry point--->i.e Required for Web Application Execution
configure(): Entry point for servlet container
application.sources(): Specifies the main configuration class

--How ServletInitializer Works
Deployment Flow:
External Tomcat Startup
        ↓
Servlet Container looks for web.xml or ServletInitializer
        ↓
ServletInitializer.configure() method is called
        ↓
Spring Application Context is created
        ↓
Your Spring Boot Application starts
        ↓
Controllers and Services are initialized

--Form Tag Library
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

+---------------------+--------------------------------------+------------------------------------------------------------+
| Tag                 | Description                          | Syntax Example                                             |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:form>         | Main form container, binds to        | <form:form method="POST" modelAttribute="book">            |
|                     | command object                       |                                                            |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:input>        | Text input field                     | <form:input path="bookName"/>                              |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:password>     | Password input field                 | <form:password path="password"/>                            |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:textarea>     | Multi-line text input                | <form:textarea path="description" rows="5"/>                |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:select>       | Dropdown select box                  | <form:select path="category">                              |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:option>       | Single option in select              | <form:option value="FICTION">Fiction</form:option>          |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:options>      | Multiple options from collection     | <form:options items="${categories}"/>                       |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:radiobutton>  | Radio button input                   | <form:radiobutton path="type" value="EBOOK"/>               |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:checkbox>     | Checkbox input                       | <form:checkbox path="features" value="HARDBACK"/>           |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:errors>       | Display validation errors            | <form:errors path="bookName" cssClass="error"/>             |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:hidden>       | Hidden input field                   | <form:hidden path="bookId"/>                                |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:label>        | Form field label                     | <form:label path="bookName">Book Name</form:label>          |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:button>       | Button element                       | <form:button type="submit">Save</form:button>               |
+---------------------+--------------------------------------+------------------------------------------------------------+

modelAttribute--->maps form data to class mapping(Entity class is different)
Path Attribute--->Map fields to class variables

When you first load the page, you don’t have user input yet. So, you give Spring an empty object — like a placeholder — for the form to bind to.
@Controller
public class StudentController {
	
	@GetMapping("/")
	public String loadIndexPage(Model model) {
		Student sObj = new Student();
		model.addAttribute("student",sObj);
		return null;
	}

}

For every HTTP request, Spring MVC creates a new Model object.
This is by design for thread safety and request isolation
Static data (like dropdown options) should be reused via constants
Dynamic data (like form objects) should be created fresh each time
HTTP Request → DispatcherServlet → Controller Method → NEW Model → Response
      ↓               ↓                   ↓            ↓         ↓
   Request 1       HandlerMapping      @GetMapping   Model 1   Response 1
   Request 2       HandlerMapping      @GetMapping   Model 2   Response 2
   Request 3       HandlerMapping      @GetMapping   Model 3   Response 3
   
Model is map(key-value pair). From first method once, whatever data you passing to model, view will be accessing that data in view page, once view page is 
loaded, that model object will be deleted from container. so we have to set those 3 lines of code in 2nd method. But it is not recommended to write it in 
2 places. so write it in 1 method and call it in two places

@Controller
public class StudentController {
	@Autowired
	private StudentService service;
	
	@GetMapping("/")
	public String loadIndexPage(Model model) {
		init(model);
		return "index";
	}
	
	//@InitBinder-->not working
	@ModelAttribute
	public void init(Model model) {
		model.addAttribute("student",new Student());
		model.addAttribute("courses", service.getCourses());
		model.addAttribute("prefTimings", service.getTimings());
	}
	
	//Endpoint to save student record	
	@PostMapping("/save")
	public String handSubmitBtm(Student s, Model model) {
		boolean isSaved = service.saveStudent(s);
		if(isSaved) {
			model.addAttribute("msg", "Data Saved....");
		}
		init(model);
		return "index";	
	}

}

@Controller
public class ProductController {
	
	@Autowired
	private ProductRepository repo;
	
	@GetMapping("/")
	public String loadForm(Model model) {
		model.addAttribute("p",new ProductEntity());
		return "index";	
	}
	
	@PostMapping("/product")
	public String handleSave(@ModelAttribute("p") ProductEntity p,Model model) {
		p = repo.save(p);
		if(p.getPid()!=null) {
		model.addAttribute("msg","Data Saved....");
		}
		return "index";
	}
}
-----------------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Home Page</title>
	</head>
	<body>
		<h2>Product Info</h2>
		<p><font color="green">${msg}</font></p>
		<form:form action="product" modelAttribute="p" method="POST">
			<table>
				<tr>
					<td>Name:</td>
					<td><form:input path="name"/></td>
				</tr>
				<tr>
					<td>Price:</td>
					<td><form:input path="price"/></td>
				</tr>
				<tr>
					<td>Quantity:</td>
					<td><form:input path="qty"/></td>
				</tr>
				<tr>
					<td></td>
					<td><input type="submit" value="save"></td>
				</tr>
			</table>
		</form:form>
		<a href="products">View Products</a>
	</bdoy>
</html>
--------------------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Products Page</title>
	</head>
	<body>
		<table>
			<thead>
				<tr>
					<th>S.NO</th>
					<th>Name</th>
					<th>Price</th>
					<th>Quantity</th>
				</tr>
			</thead>
			<tbody>
				<c:forEach items="${products}" var="product" varStatus="status">
					<tr>
						<td>${status.count}</td>
						<td>${product.name}</td>
						<td>${product.price}</td>
						<td>${product.qty}</td>
					</tr>
				</c:forEach>
			</tbody>
	 </body>
</html>
-------------------------------------------------------------------------------------------
# JSTL forEach Tag Breakdown

| Part                | Meaning          | Description                                           |
|---------------------|------------------|-------------------------------------------------------|
| <c:forEach          | JSTL Loop Tag    | Starts the loop iteration                             |
| items="${products}" | Collection to iterate | Refers to products attribute from Spring controller |
| var="product"       | Loop variable    | Each item in collection is assigned to product         |
| varStatus="index"   | Loop status      | Provides loop information (counter, index, etc.)       |


Embedded Databasee(i.e In Memory database/Temporary Database)-->Starts when app starts and Stops when app stops
Ex:H2 DB,HSQLDB,Derby
Note -->don't add devtools dependency otherwise it will restart server upon changes and data will be lost
JSTL:-->Whatever data we are inserting in the db table, we need to display in the another page. so need to iterate the list of records in jsp

---Thymeleaf vs JSP
JSP can't send response directly to browser, so it is converted to servelet(Takes more time)
HTML is faster than jsp, but HTML is only for static pages. so we are going to use Thymeleaf inside HTML, to support dynamic webpages
Thymeleaf is the template engine that can be integrated into HTML
create HTML pages in src/resources/templates
| **Feature**              | **Thymeleaf**                  | **JSP (Java Server Pages)**            | 
| ------------------------ | ------------------------------ | ---------------------------------------|
| **Natural Templates**    | ✅ Yes – works as static HTML   | ❌ No – requires server to render     |
| **Spring Integration**   | ✅ Excellent native support     | ⚠️ Requires additional configuration  |
| **Syntax**               | ✅ HTML5-compliant, clean       | ❌ Mixes Java code with HTML          |
| **Learning Curve**       | ✅ Easy for frontend developers | ❌ Steeper, requires Java knowledge   |
| **Performance**          | ✅ Good (compiled templates)    | ✅ Good (compiled to servlets)        |
| **Internationalization** | ✅ Excellent support            | ✅ Good support                       |
| **Fragment Reuse**       | ✅ Layouts and fragments        | ✅ Includes and taglibs               |
| **Tooling**              | ✅ Good IDE support             | ✅ Mature tooling                     |
------------------------------------------------------------------------------------------------------
--need to add thymeleaf-starter in pom.xml(tomcat-embed-jasper is not needed now and no need to configure view resolver)

| Tag                                            | Description                         |
| ---------------------------------------------- | ----------------------------------- |
| `<form th:action="@{/product}" method="post">` | Submits form to `/product` endpoint |
| `th:object="${p}"`                             | Binds form inputs to Product object |
| `th:field="*{name}"`                           | Maps field to `Product.name`        |
| `th:if` / `th:text`                            | Used to show messages dynamically   |


index.html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>Home Page</title>
</head>
<body>
	<div class="container">
		<h3>
			<p th:text="${msg}" class="text-success"></p>
		</h3>
	</div>

	<form th:action="@{/product}" th:object="${p}" method="post">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" th:field="*{name}" ></td>
			</tr>
			<tr>
				<td>Price:</td>
				<td><input type="number" th:field="*{price}" ></td>
			</tr>
			<tr>
				<td>Quantity:</td>
				<td><input type="number" th:field="*{quantity}" ></td>
			</tr>
			<tr>
				<td><a href="/">Reset</a></td>
				<td><input type="submit" value="Save" class="btn btn-primary" /></td>
			</tr>
		</table>
	</form>

	<div class="pt-3 pb-3">
		<a href="/products">View All Products</a>
	</div>
</body>
</html>

data.html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
	<meta charset="UTF-8">
	<title>Product Page</title>
	<script type="text/javascript">
		function deleteConfirm() {
			return confirm("Are you sure you want to delete this product?");
		}
	</script>
</head>

<body>
	<div class="container">
		<h1>View Products</h1>
		<p th:text="${msg}" class="text-danger">
		<a href="/" class="btn btn-primary">+Add New Product</a>
	</div>
	<table>
		<thead>
			<tr>
				<th>Product ID</th>
				<th>Product Name</th>
				<th>Product Price</th>
				<th>Product Quantity</th>
				<th>Action</th>
			</tr>
		</thead>
		<tbody>
			<tr th:if="${list == null or list.empty}">
				<td colspan="5" style="text-align: center;">
					No Records found
				</td>
			</tr>
			<tr th:each="product : ${list}" th:if="${list != null and !list.empty}">
				<td th:text="${product.pid}"></td>
				<td th:text="${product.name}"></td>
				<td th:text="${product.price}"></td>
				<td th:text="${product.quantity}"></td>
				<td>
					<a th:href="@{/delete(pid=${product.pid})}" class="btn btn-danger"
						onclick="return deleteConfirm()">Delete</a>
				</td>
			</tr>
		</tbody>
	</table>
</body>

Form Validation-->As record should be inserted only when the data is available
--Client Side Validation: Validations executes on browser
--Server Side Validation:---for this we have to add spring-boot-starter-validation, we will write validation on binding object
@Validated---->To tell the spring boot, that we are getting form data in form of binding object, you verify that form data ,
store into binding object satisfying validation rule or not
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>Home Page</title>
</head>
<body>
	<div class="container">
		<h3>
			<p th:text="${msg}" class="text-success"></p>
		</h3>
	</div>

	<form th:action="@{/product}" th:object="${p}" method="post">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" th:field="*{name}" ></td>
				<td th:if="${#fields.hasErrors('name')}" th:errors="*{name}" class="text-danger"></td>
			</tr>
			<tr>
				<td>Price:</td>
				<td><input type="number" th:field="*{price}" ></td>
				<td th:if="${#fields.hasErrors('price')}" th:errors="*{price}" class="text-danger"></td>
			</tr>
			<tr>
				<td>Quantity:</td>
				<td><input type="number" th:field="*{quantity}" ></td>
				<td th:if="${#fields.hasErrors('quantity')}" th:errors="*{quantity}" class="text-danger"></td>
			</tr>
			<tr>
				<td><a href="/">Reset</a></td>
				<td><input type="submit" value="Save" class="btn btn-primary" /></td>
			</tr>
		</table>
	</form>

	<div class="pt-3 pb-3">
		<a href="/products">View All Products</a>
	</div>
</body>
</html>

@Entity
@Data
public class Product {
	
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	private Integer pid;
	
	@Size(min = 3, max = 15, message = "Name must have between {min} and {max} characters")
	@NotBlank(message="Name is mandatory")
	private String name;
	
	@NotNull(message="Price should be not null")
	private Double price;
	
	@NotNull(message="Quantity should be entered")
	private Integer quantity;

}

@Controller
public class ProductController {
	
	@Autowired
	public ProductRepository repo;
	
	@GetMapping("/")
	public String loadForm(Model model) {
		model.addAttribute("p", new Product());   //To bind form to binding object
		return "index";
	}
	
	@PostMapping("/product")
	public String saveProduct(@Validated @ModelAttribute("p") Product p,BindingResult result,Model model) {
		if(result.hasErrors()) {
			System.out.println(p);
			return "index";
		}
		Product savedProduct = repo.save(p);
		System.out.println(savedProduct);
		if(savedProduct.getPid()!=null) {
			model.addAttribute("msg", "Product is saved in DB");
		}
		return "index";
	}
	
	@GetMapping("/products")
	public String loadAllProducts(Model model){
		List<Product> all = repo.findAll();
		model.addAttribute("list",all);
		return "data";
	}
	
	@GetMapping("/delete")
	public String deleteRecord(@RequestParam("pid")Integer pid,Model model) {
		repo.deleteById(pid);
		List<Product> all = repo.findAll();
		model.addAttribute("msg", "Product deleted Successfully");
		model.addAttribute("list",all);    //displays latest data
		return "data";
	}
	
	@GetMapping("/edit")
	public String editProduct(@RequestParam("pid") Integer pid, Model model) {
	    Product product = repo.findById(pid).orElse(new Product());
	    model.addAttribute("p", product);
	    return "index"; // same form, pre-filled with data
	}


}

-->While using edit button and click on save button, pid again coming as null value, JPA thinks it's a new record. We need to tell JPA that it's existing,
 so use hidden variable
 <body>
	<div class="container">
		<h3>
			<p th:text="${msg}" class="text-success"></p>
		</h3>
	</div>

	<form th:action="@{/product}" th:object="${p}" method="post">
		<input type="hidden" th:field="*{pid}" />
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" th:field="*{name}" ></td>
				<td th:if="${#fields.hasErrors('name')}" th:errors="*{name}" class="text-danger"></td>
			</tr>
-------------------------------------------------------------------------------------
@Controller
@RequestMapping("/grateful")
public class MsgController {
	
	@GetMapping("/welcome")          --------------->When both are @GetMapping Method url should also be unique, otherwise confusion/ambiguity while component scanning
	public String welcomeMsg(Model model) {
		model.addAttribute("msg","Welcome to the team");
		return "index";        //Returns a Thymeleaf template view
	}
	
	@GetMapping("greet")
	@ResponseBody                      ------>@Controller + @ResponseBody--->Method will become REST method
	public String greetMsg() {
		return "Greetings";     //@ResponseBody returns the string directly as the HTTP response, not as a template view.
	}

}

application.properties
spring.application.name=25-Web-MVC-EmbedServer-ResponseBodyApp
server.port=9090
server.servelet.context-path=/alchemist
#localhost:9090/alchemist/*  ---->this url should be formed


Note: When controller method returns string type, dispatcher servelet will consider it as a view file, with that name and search it--->error. 
So we use @ResponseBody--> dispatcher will think that, whatever this method is returning is direct response to the client, who sends the request
@Controller--->C2B communication---->Request---->WebPages
@RestController--->B2B communication--->Request--->Response

@ResponseBody can be used at class level as well as Method level

Mutliple URL pattern for single method
@GetMapping(value={"/hi","/hello","/"})

---Exception Handling in the Web MVC application--->Unexepected and unwanted situation is called Exception.(i.e program terminate abnormally)
Handling Exception and Conveying to user are two different things.
--Two ways of Exception Handling
-Local Exception Handling(Controller specific exception handling)-->@ExceptionHandler
-Global Exception Handling(Application Specific)
Note: Local Exception Handling is not recommended as code duplication, we need to seperate Business logic and secondary logic(Aspect Oriented Programming)

@Controller
public class DemoController {
	
	private Logger logger = LoggerFactory.getLogger(DemoController.class);
	
	@GetMapping("/")
	public String getMessage(Model model) {
		int i=1/0;
		model.addAttribute("msg","Hi, Hello");
		return "index";
	}
	
	@GetMapping("/greet")
	public String greetMsg(Model model) {
		String txt=null;
		txt.length();
		model.addAttribute("msg","Greetings");
		return "index"; 
	}
	
	//@ExceptionHandler(value=ArithmeticException.class)
	@ExceptionHandler(value=Exception.class)------------------>//Exception is super class for all types of Exception
	public String handleArithmeticException(Exception ae){
		String msg = ae.getMessage();
		logger.error(msg);          //logging Error Message
		return "errorPage";
	}
}
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
	<head>
		<meta charset="UTF-8">
		<title>Error Page</title>
	</head>
	<body>
		<h2>Some problem occurred, Please try after some time....</h2>
	</body>
</html>

Whenever, Exception comes in project, spring boot will check is their anu handler for it?-->If yes, then it will execute it and if NO-->whitelebel error

--Global Exception Handler

@ControllerAdvice
public class AppExceptionHandler {
	
	private Logger logger = LoggerFactory.getLogger(AppExceptionHandler.class);
	
	@ExceptionHandler(value=Exception.class)
	public String handleException(Exception e) {
		String errorText = e.getMessage();
		logger.error(errorText);
		return "errorPage";		
	}
	
	@ExceptionHandler(value=NullPointerException.class)
	public String handleNullPointerEx(NullPointerException e) {
		String errorText = e.getMessage();
		logger.error(errorText);
		return "errorPage";
	}

}

---Java MocroServices(Microservice-->Architectural design pattern)
--Monolith Architecture--->Maintenance, Single point of failure, Redeploy entire app
--Microservices Architecture-->Easy maintenance,High availablility,Fast Development,Quick releases,Technology independency(i.e each API can be developed with differnt languages)
Microservice == One REST API
Distribute Applications-->One project wants to communicate with other project
ex: Passport App---->Aadhar app---->DB
Here Passport app is consumer app, and Aadhar app is provider app(i.e Providing services to other apps)
UI and BackEnd can be differnt projects
--InterOperatibility means platform independent and language independent
Mediator language--XML/JSON
XML-->As a mediator to excbange data between one application to other application
JSON-->Platform Independent and language indpendent(Inter-Operatibility achieved)

--REST Architecture-->
-Provider/Resource-->The application which is giving services to other application is called as provider application, provider is also called as REST APIs
-Consumer/Client-->The application which is accessing the services from other applications is called as Consumer application
-How communication happens between Provider and Consumer?
HTTP protocol, will act as mediator between consumer and provider. Consumer and provider will exchange data in the form of XML/JSON
Note: XML and JSON are inter-operable

HTTP Protocol-->HTTP will act as a mediator between client and server, HTTP is stateless protocol
                HTTP Request
                HTTP RESPONSE
				HTTP methods
				HTTP status code 
-HTTP Methods-->GET(To get the data from the server)
                POST(To send the data to server, insert/crete record at server)
				PUT(To update data at server)
				DELETE(To delet data at the server)
Note: Every REST API method should be mapped to HTTP Method

-HTTP Status Code:-->When Client send request to the Server, then server will process that request and will send response to the client with status code
  1XX--->Informational Code
  2XX--->Success Code
  3XX--->ReDirection(You sent request to one server, it will redirect to other server)
  4XX--->Client Error(Sending Incorrect request)
  5XX--->Server Error
  
All codes
1xx Informational:
100 Continue
101 Switching Protocols
102 Processing
103 Early Hints

2xx Success:
200 OK
201 Created
202 Accepted
204 No Content
206 Partial Content

3xx Redirection:
301 Moved Permanently
302 Found
304 Not Modified
307 Temporary Redirect
308 Permanent Redirect

4xx Client Error:----->when 4xx entered in 400 they told bad request and go to 401 and mark it as unauthorized,  
400 Bad Request------->in 401 it told to go in 403 and mark it as Forbidden, one person still tried after it marked as forbidden he got it 404-->not found, he tried one method and got 405 Method not allow
401 Unauthorized
403 Forbidden
404 Not Found
405 Method Not Allowed
409 Conflict
429 Too Many Requests

5xx Server Error:
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Gateway Timeout

Quick Ref:
2xx = Success
3xx = Redirect  
4xx = Client Error
5xx = Server Error

HTTP Request–Response Cycle Diagram

                ┌──────────────────────────────┐
                │          CLIENT              │
                │ (Browser / Postman / App)    │
                └─────────────┬────────────────┘
                              │
                              │  HTTP Request
                              ▼
     ┌────────────────────────────────────────────────────┐
     │                   HTTP REQUEST                     │
     │────────────────────────────────────────────────────│
     │ Request Line    →  Method + URL + HTTP Version      │
     │   e.g. GET /api/course/101 HTTP/1.1                 │
     │────────────────────────────────────────────────────│
     │ Request Headers →  Metadata (key–value pairs)       │
     │   e.g. Content-Type: application/json               │
     │        Authorization: Bearer <token>                │
     │────────────────────────────────────────────────────│
     │ Request Body    →  Payload (actual data sent)       │
     │   e.g. { "courseName": "Java", "duration": "2m" }   │
     └────────────────────────────────────────────────────┘
                              │
                              │  ↓ Sent to Server
                              │
                              ▼
     ┌────────────────────────────────────────────────────┐
     │                     SERVER                         │
     │ (API / Web Server / Database)                      │
     └────────────────────────────────────────────────────┘
                              │
                              │  HTTP Response
                              ▼
     ┌────────────────────────────────────────────────────┐
     │                   HTTP RESPONSE                    │
     │────────────────────────────────────────────────────│
     │ Response Line   →  Status Code + Message            │
     │   e.g. HTTP/1.1 200 OK                              │
     │────────────────────────────────────────────────────│
     │ Response Headers →  Metadata (content type, etc.)   │
     │   e.g. Content-Type: application/json               │
     │────────────────────────────────────────────────────│
     │ Response Body   →  Actual response data             │
     │   e.g. { "id": 101, "courseName": "Java" }          │
     └────────────────────────────────────────────────────┘
                              │
                              │  ↓ Back to Client
                              ▼
                ┌──────────────────────────────┐
                │      CLIENT (Displays Data)   │
                └──────────────────────────────┘

--JSON(JavaScript Object Notation):-JSON is used to represent data in key-value format
JSON is umiversal format to exchange data over internet
Syntax:
{
 "id" : 101,
 "name" : "Rohit",
 "gender" : "Male",
 "Phno" : "8087217921",
 "address" : {
               "city" : "Ichalkaranji",
			   "state" : "Maharashtra"
			  } 
}
-key in double quotes and only string value is in double quotes
As a part of development, java object conveted to JSON and vice versa
We have to use 3rd party apis to work with JSON data in java applications
-JackSon api--->ObjectMapper class provides method to convert java to json and vice versa(Spring boot by default uses it, 
when we add spring web--by default jackson-databind-__.jar can be seen)
-GSon api

JackSon api-->ObjectMapper class
/*
 * JACKSON OBJECTMAPPER - COMPLETE REFERENCE
 * 
 * ObjectMapper is the main class for Jackson API that provides 
 * bidirectional conversion between Java Objects and JSON data
 */

ObjectMapper mapper = new ObjectMapper();

// ================= SERIALIZATION (Java Object → JSON) =================
// Converting Java objects to JSON format

String jsonString = mapper.writeValueAsString(javaObject);
// → Converts Java object to JSON string

mapper.writeValue(new File("data.json"), javaObject);
// → Writes Java object as JSON to file

String prettyJson = mapper.writerWithDefaultPrettyPrinter()
                         .writeValueAsString(javaObject);
// → Converts to formatted/readable JSON string

// ================= DESERIALIZATION (JSON → Java Object) =================
// Converting JSON data back to Java objects

JavaObject obj1 = mapper.readValue(jsonString, JavaObject.class);
// → Converts JSON string to Java object

JavaObject obj2 = mapper.readValue(new File("data.json"), JavaObject.class);
// → Reads JSON file and converts to Java object

JavaObject obj3 = mapper.readValue(inputStream, JavaObject.class);
// → Converts JSON from InputStream to Java object

// ================= WORKFLOW DIAGRAM =================
/*
 *        +----------------+      Serialization      +---------------+
 *        |                |    (Java → JSON)        |               |
 *        |  Java Object   |  -------------------->  |   JSON Data   |
 *        |                |                         |               |
 *        +----------------+                         +---------------+
 *                ^                                         |
 *                | Deserialization                         |
 *                | (JSON → Java)                          |
 *                |                                         |
 *                +-----------------------------------------+
 */

// ================= DEPENDENCY =================
/*
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.17.2</version>
</dependency>
*/

// ================= KEY FEATURES =================
// • Handles nested objects and collections
// • Supports annotations for customization
// • Thread-safe after configuration
// • Automatic type inference
// • Exception handling for invalid JSON

// ================= COMMON EXCEPTIONS =================
// JsonProcessingException - Invalid JSON during reading
// IOException - File/stream operations
// InvalidFormatException - Type mismatch

--Gson api

public class App {
	public static void main(String[] args) {
    	Address addr = new Address();
		addr.setCity("Ichalkaranji");
		addr.setState("Maharashtra");
		addr.setCountry("India");
		
		Customer c = new Customer();
		c.setId(1);
		c.setName("Rohit");
		c.setEmail("lavatero92@gmail.com");
		c.setPhno((long)80872179);
		c.setAddr(addr);
		
		/*
		 * Gson gson = new Gson(); String json = gson.toJson(c); System.out.println(c);
		 */
		
        File file = new File("customer.json");
        Gson gson = new Gson();
        try {
            // Write JSON to File
            FileWriter writer = new FileWriter(file);
            gson.toJson(c, writer);
            writer.close();
		
		/*Customer fromJson = gson.fromJson(json, Customer.class);
		System.out.println(fromJson);
        */
            FileReader reader = new FileReader(file);
            Customer fromJson = gson.fromJson(reader, Customer.class);
            reader.close();
            
            System.out.println("\nObject from JSON file:");
            System.out.println(fromJson);
        }catch(Exception e) {
        	e.printStackTrace();
        }
    }
}

@RestController
public class CutstomerRestController {
	
	@GetMapping("/")
	public Customer getCustomer() {
		Address addr = new Address();
		addr.setCity("Terwad");
		addr.setState("Maharashtra");
		addr.setCountry("India");
		
		Customer customer = new Customer();
		customer.setId(1);
		customer.setName("Prime");
		customer.setEmail("prime@gmail.com");
		customer.setPhno((long)996050);
		customer.setAddr(addr);
		
		return customer;          --->Return json when we hit localhost:${server.port}/
	}
}

--XML and JAX-B
XML is extensible markup language(inter-operable)
XML represents data in element format(start tag and end tag) ex-<id>101</id>
XML have  2 types of elements
-Simple Elements:--Contains data directory
-Compound Elements:--Element containing child element
ex: <person>
       <id>101</id>
	   <name>Smith</name>
	   <address>
	       <city>Ichalkaranji</city>
		   <state>MH</state>
	   </address>
    </person>
	
# MARSHALLING & UNMARSHALLING

## 🔄 CONVERSION PROCESS

      +-------------+    MARSHALLING     +-------------+
      |             |   (Object → Data)  |             |
      |  JAVA OBJ   | ————————————————> |    XML/JSON |
      |             |                    |             |
      +-------------+                    +-------------+
            ^                                  |
            | UNMARSHALLING                    |
            | (Data → Object)                  |
            |                                  |
            +——————————————————————————————————+

## 📝 DEFINITIONS

### MARSHALLING (Serialization)
- **Java Object → Structured Data** (XML/JSON)
- Also called: **Serialization**, **Encoding**
- **Purpose**: For transmission, storage, API calls

### UNMARSHALLING (Deserialization)  
- **Structured Data → Java Object** 
- Also called: **Deserialization**, **Decoding**
- **Purpose**: For processing, data manipulation

## 🛠️ TECHNOLOGIES

### 1. JAX-B (Java Architecture for XML Binding)
```java
// MARSHALLING
JAXBContext context = JAXBContext.newInstance(Employee.class);
Marshaller marshaller = context.createMarshaller();
marshaller.marshal(employee, new File("employee.xml"));

// UNMARSHALLING  
Unmarshaller unmarshaller = context.createUnmarshaller();
Employee emp = (Employee) unmarshaller.unmarshal(new File("employee.xml"));
Note: To perform marshalling and Un-Marshalling, we need to create Binding class
Note: Upto JDK 1.8, JAX-B was part of JDK, but from 1.9v, it is not part of JDK, so we need to add in pom.xml

@Data
@XmlRootElement
public class Customer {
	
	private Integer id;
	
	private String name;
	
	private String email;
	
	private Long phno;

}

public class MarshalDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Customer customer = new Customer();
		customer.setId(1);
		customer.setName("Prime");
		customer.setEmail("prime@co.in");
		customer.setPhno((long)9899);
		
		try {
			JAXBContext context = JAXBContext.newInstance(Customer.class);
			Marshaller marshaller = context.createMarshaller();
			marshaller.marshal(customer,new File("Customer.xml"));
			System.out.println("XML file is created");
		} catch (JAXBException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}


--Provider/REST API development
@RestController
public class MsgRestController {
	
	@PostMapping("/msg")        //we have to check through postman--->405 in browser(whitelebel), browser will support only get methods(doesnot contain body)
	public ResponseEntity<String> saveMsg(){
		String responseBody = "Msg saved successfully....";
		return new ResponseEntity<String>(responseBody,HttpStatus.CREATED);
	}
	
	@GetMapping("/welcome")
	public ResponseEntity<String> welcomeMsg(){
		String msg = "Welcome to all people";
		return new ResponseEntity<String>(msg,HttpStatus.OK);----->To customize Response Body
	}
	
	@GetMapping("/greet")     --------------------------------->Method is not returning any status , but internally dispatcher servelet will prepare response and sent it(Can be seen in Postman)
	public String getGreeting() {
		String greet = "Good Morning, everyone";
		return greet;
	}

}
-------------------------------------------------------------------------------
@RestController
public class UserRestController {
	
	private  Map<Integer, User> dataMap =new HashMap<>();
	
	@PostMapping("/user")
	public ResponseEntity<String> addUser(@RequestBody User user){
		dataMap.put(user.getId(), user);
		System.out.println(dataMap);
		return new ResponseEntity<String>("User saved.....",HttpStatus.CREATED);
	}
	
	@GetMapping("/user")
	public User getUserByQueryParam(@RequestParam("userId") Integer userId) {
		User user = dataMap.get(userId);
		return user;
	}
	
	//example for multiple query parameters
	/*
	 * @GetMapping("/userData") public User getUserData(@RequestParam("name") String
	 * name, @RequestParam("email") String email ) { return null; }
	 */
	
	@GetMapping("/user/{id}")
	public User getUserByPathParam(@PathVariable("id")Integer userId) {
		User user = dataMap.get(userId);
		return user;
	}
	
	@GetMapping("/userData/{id}/data")
	public User getUserByPathParamUrlPattern(@PathVariable("id")Integer userId) {
		User user = dataMap.get(userId);
		return user;
	}

}


-When hit this url, check header in the postman--->Content-Type=application/Json
-Payload-->Business data, any data that is exchanged between consumer and provider in the body is called as a payload.
-Header-->Extra data you want to send consumer or provider(we can't pass business data here)-->Content-Type=application/Json(Understand what type of data client sends)
-@RequestBody--->To read Payload from HTTP POST Request(Telling that, get the data from request body and store into User object)
-@RequestPaaram-->To take single value 
-ResponseEntity-->To Test Rest API functionality
Note: if data is huge, go for body. Otherwise use url(Not sensitive data, send it in url)

--Query Param and Path Params--->Both are used to send data to server, sends data in URL
-Query Parameter----> www.youtube.com/watch?v=123(key and value format),Normally present at end of URL, starts with '?', 
and seperated by using '&'(e.g-->?v=seva&country=IN)------>Use @RequestParam to read query param from url
When client sends GET request with userId in query parameter. method will read parameter, using this gets data from map and return object in JSON format

-Path Parameter----->www.udemy.com/courses/java(direct value format)-->Path param will represent data directly, Path param can present anywhere in URL, starts with '/'
and will seperated only by '/'----->Use @PathParam to read the path parameter----->localhost:9090/user/1
Note: When Client is GET request, then client can use Query params or path params to send data to the server. GET request will not contain any Request Body
so we have to use either Query or path param to send the data. POST method doesn't require it, as it have body to send the data.
i.e when, we have parameter with @RequestParam, DispatcherServelet will understand that, userId will come as a query parameter--> It will understand that and 
check userId in query parameters. take it and give it to the method. Method return object --> DispatcherServelet return JSON(POST Processing)

	@PostMapping("/user")
	public ResponseEntity<String> addUser(String user){    ------->Instead of object if we send string it also works but, whatever json client is sending that should come
	                                                               as parameter to our method(raw JSON)-->write logic to convert JSON to java
																   But what if client sends xml--->code fails--->Tightly coupled with JSON, that's why we take object
																     Before processing, DispatcherServelet will read what data in the url,what is in body, in header
																   it observes Content-Type-->Give it to MsgConverter-->it give back converted data to DispatcherServelet and 
																   then passed to method

Note:
-When you want to get record with unique id-->Path Parameter(Based on ticket number, get data)
-If your method is giving more records as response-->Query Parameter(Based on author name, get book list)

--Consumes and Produces-->
consumes--->It represents which format supported by REST API method or In which format REST API can accept input data from client.
produces--->It represents in which format REST API method can provide response to clients
Note: POST Method-->consumes data
      GET Method--->produces data
Example:
    @PostMapping(
			value="/user",
			consumes= {"application/json"}
			)
	public ResponseEntity<String> addUser(@RequestBody User user){
		dataMap.put(user.getId(), user);
		System.out.println(dataMap);
		return new ResponseEntity<String>("User saved.....",HttpStatus.CREATED);
	}
	
	@GetMapping(
			value="/user", 
			produces= {"aplication/json"}
	)
	public User getUserByQueryParam(@RequestParam("userId") Integer userId) {
		User user = dataMap.get(userId);
		return user;
	}
	
Alternative way-->
@RestController
public class MyController {
    
    // JSON Response
    @GetMapping(value = "/users", produces = MediaType.APPLICATION_JSON_VALUE)
    public List<User> getUsers() {
        return userService.getAllUsers();
    }
    
    // XML Response
    @GetMapping(value = "/users", produces = MediaType.APPLICATION_XML_VALUE)
    public List<User> getUsersXml() {
        return userService.getAllUsers();
    }
    
    // Accept JSON request body
    @PostMapping(value = "/users", 
                consumes = MediaType.APPLICATION_JSON_VALUE,
                produces = MediaType.APPLICATION_JSON_VALUE)
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }
}
	
Client should send--->Accept=aplication/json or application/xml in header
The client must specify the Accept header to tell the server which format they want.
- Request Flow:
CLIENT REQUEST → Spring DispatcherServlet → Content Negotiation → Message Converter → Your Method
     ↓                   ↓                       ↓                   ↓               ↓
   Accept:             Reads                Determines           Converts        Returns
application/json    Accept header          response format    Object → JSON     Java Object

---jackson-dataformat-xml used in place of JAXB
@RestController
public class BookRestController {
	
	@GetMapping(
			value="/book",
			produces= {"application/json","application/xml"}
			)
	public Book getBook() {
		Book b = new Book();
		b.setId(1);
		b.setName("Java");
		b.setPrice(200d);
		return b;	
	}

}
Note: If we add JAXB dependency, above program will give data in xml format.(By default we get data in Json format)
If we want data to be stored in particular format mention it in 'Accept' attribute.

POST-->localhost:9090/book
       Content-Type: application/json(Header)  ----->i.e represents in which format client sending data to server in Request Body
	   Body: Raw-data-->JSON
GET-->localhost:8080/book
       Accept: aplication/json(Header)   -----> This header will represent in which format client expecting response from server
	   
--Swagger Documentation:--Swagger(Third party library) is used to generate REST API documentation
-The Problem
Spring Boot 3 uses Jakarta EE 9+ (package names: jakarta.servlet)
SpringFox (Swagger) uses legacy Java EE (package names: javax.servlet)
This causes ClassNotFoundException for javax.servlet.http.HttpServletRequest
-Add dependencies
<!-- Add SpringDoc OpenAPI -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.8.5</version>
</dependency>
-don't add these dependencies-->springfox-swagger2,springfox-swagger-ui
--Create SwaggerConfig Class with @Configuration
--spring.mvc.pathmatch.matching-strategy=ANT_PATH_MATCHER(application.properties)
--UI URL http://localhost:9090/swagger-ui.html directly access this url
Doc URL  http://localhost:9090/v3/api-docs     -->info about APIs(JSON Format)-->host,basepath,paths(url patterns),consumes,produces and Response data

--For Deployment
-add in pom.xnl--->Add tag <finalName>
<build>
	 <finalName>sb-irctc-api</finalName>
		<plugins>
			<plugin......

-Refresh and run as --> Maven build, Goals-->clean package(To package app)
-Launch EC2(Linux VM, Ubuntu,t2.micro,key-pair(e.g sbmsKey)), Security group-->Add rule-->Custom TCP(8080)-->in our case 9090
-Open Mobaxterm--->Basic SSH setting-->Remote Host-->(paste public IP) and Specify Username-->Ubuntu,Port:22
                   Advanced SSH setting-->Use private key(Check it)-->Select key-pair
-copy file path and upload file
-run following commands
$sudo apt install dafault-jdk
$sudo apt install java
$java -version
$java -jar sb-irctc-api.jar
--Now go to instance-->take public ip by selecting EC2
--Go to browser===> (public IP):8080/swagger-ui.html

---Consumer Development
--Client/Consumer-->application which is accessing services from other applications
3 ways to develop consumer
-RestTemplate(Out dated)---------------->Supports only synchronous communication
-WebClient(Introduced from Spring 5.X)-->supports both synchronous as well as Asynchronous communication
-FeignClient(Spring Cloud)
Note: In Realtime, APIs cannot be accessed by everyone(security)

--For using RestTemplate
   RestTemplate rt = new RestTemplate();
   ResponseEntity<Object of Response type> response=rt.postForEntity("url you want to access"."object data you want to send in body","Response type(how we want response)");-->for post request, 
   
   for get request--->getForEntity(url,ResponseType class, path variables comma seperated);
   
-public class ServiceImpl implements MTMService{
	private String BOOK_TICKET_URL = "http://localhost:9090/ticket";       //ip inplace of localhost when deployed on AWS
	private String GET_TICKET_URL = "http://localhost:9090/ticket/{ticketNum}";

	@Override
	public Ticket bookTicket(Passenger passenger) {
		RestTemplate rt = new RestTemplate();
		ResponseEntity<Ticket> response = rt.postForEntity(BOOK_TICKET_URL, passenger, Ticket.class);
		Ticket ticket = response.getBody();
		return ticket;
	}

	@Override
	public Ticket getTicketByNum(String ticketNumber) {
		RestTemplate rt = new RestTemplate();
		ResponseEntity<Ticket> response = rt.getForEntity(GET_TICKET_URL, Ticket.class, ticketNumber);
		Ticket ticket = response.getBody();
		return ticket;
	}

}

--WebClient-->Predefined interface(spring 5.x)--->We can send HTTP Request(GET,PUT,POST,DELETE)
Supports both sychronous and asynchronous communications.
Dependency-->web-flux-starter (spring reactive web)

@Service
public class ServiceImpl implements MTMService{
	private String BOOK_TICKET_URL = "http://localhost:9090/ticket";       //ip inplace of localhost when deployed on AWS
	private String GET_TICKET_URL = "http://localhost:9090/ticket/{ticketNum}";

	@Override
	public Ticket bookTicket(Passenger passenger) {
		WebClient webclient = WebClient.create();
		Ticket ticket = webclient.post()
				     .uri(BOOK_TICKET_URL)
					 .header("Accept","application/json")             //To send the header in request
				     //.body(BodyInserters.fromObject(passenger))    //deprecated
				     .bodyValue(passenger)                           //use it--->i.e convert passenger data from object to json
				     .retrieve()
				     .bodyToMono(Ticket.class)
				     .block();
		return ticket;
	}

	@Override
	public Ticket getTicketByNum(Integer ticketNumber) {
		//Get the instance of webclient(Implementaion class object)
		WebClient webclient = WebClient.create(); 
		//Send GET Request and map response to ticket obj
		Ticket ticket = webclient.get()                         //represent get request
				        .uri(GET_TICKET_URL,ticketNumber)      //If we want to send query param-->set it parameter here
				        .retrieve()                            //retrieve the response
				        .bodyToMono(Ticket.class)              //response map to Ticket class object and return object
				        .block();                             //wait till get response from IRCTC app and store into variable
		return ticket;
	}

}
-----------------------------------------------------------------------------------------------------
@Controller
public class MakeMyTripController {
	@Autowired
	private MTMService service;
	
	@GetMapping("/")
	public String loadForm(Model model) {
		model.addAttribute("passenger",new Passenger());
		return "index";
	}
	
	@PostMapping("book-ticket")
	public String bookTicket(@ModelAttribute("passenger")Passenger passenger, Model model) {
		Ticket bookedTicket = service.bookTicket(passenger);
		model.addAttribute("msg","Ticket is booked with ID:"+bookedTicket.getTicketNumber());
		return "index";
	}
	@GetMapping("/get-ticket")  
	public String getTicketDetails(
	        @RequestParam(value = "ticketNumber", required = false) Integer ticketNumber, 
	        Model model) {
	    
	    System.out.println("=== GET TICKET DEBUG ===");
	    System.out.println("Received ticketNum parameter: " + ticketNumber);
	    
	    if (ticketNumber != null) {
	        System.out.println("Calling service.getTicketByNum(" + ticketNumber + ")");
	        Ticket ticket = service.getTicketByNum(ticketNumber);
	        System.out.println("Service returned ticket: " + ticket);
	        model.addAttribute("ticket", ticket);
	        
	        if (ticket == null) {
	            System.out.println("⚠️ No ticket found for number: " + ticketNumber);
	        } else {
	            System.out.println("✅ Ticket found: " + ticket.getTicketNumber());
	        }
	    } else {
	        System.out.println("ℹ️ No ticketNum parameter received");
	    }
	    
	    System.out.println("Returning view: ticket-form");
	    return "ticket-form";
	}
	
}

--Sychronous vs Asynchronous Communications
Synchronous Communication-->After Sending request, thread will wait for RESPONSE---->sync call(sync request)-->block()
Aysnc Communication--->After sending the request, thread will not wait for response-->Async call(Async request)-->subscribe()
//do one example

--------------------------------------------------------------------------------
public class WebClientSyncAsyncExample {

    public static void main(String[] args) throws InterruptedException {

        WebClient webClient = WebClient.create("https://jsonplaceholder.typicode.com");

        // --- Synchronous Call ---
        System.out.println("=== Synchronous Call Start ===");
        long startSync = System.currentTimeMillis();

        String syncResponse = webClient.get()
                .uri("/posts/1")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class)
                .block();  // <-- BLOCKING call

        long endSync = System.currentTimeMillis();
        System.out.println("Sync Response Received:");
        System.out.println(syncResponse);
        System.out.println("Time Taken (Sync): " + (endSync - startSync) + " ms");
        System.out.println("=== Synchronous Call End ===\n");


        // --- Asynchronous Call ---
        System.out.println("=== Asynchronous Call Start ===");
        long startAsync = System.currentTimeMillis();

        Mono<String> asyncResponse = webClient.get()
                .uri("/posts/1")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class);

        asyncResponse.subscribe(
                data -> {
                    long endAsync = System.currentTimeMillis();
                    System.out.println("Async Response Received:");
                    System.out.println(data);
                    System.out.println("Time Taken (Async): " + (endAsync - startAsync) + " ms");
                    System.out.println("=== Asynchronous Call End ===");
                },
                error -> System.err.println("Error occurred: " + error),
                () -> System.out.println("Request completed successfully.")
        );

        System.out.println("Main thread continues execution...");
        
        // Keep the program running long enough for async response to complete
        Thread.sleep(2000);
    }
}
------------------------------------------------------------------------------------------
package com.example.webclientdemo.controller;

import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@RestController
public class WebClientController {

    private final WebClient webClient = WebClient.create("https://jsonplaceholder.typicode.com");

    // --- Synchronous Example ---
    @GetMapping(value = "/sync", produces = MediaType.APPLICATION_JSON_VALUE)
    public String getSyncData() {
        System.out.println("=== Synchronous Request Start ===");
        long start = System.currentTimeMillis();

        // Blocking call
        String response = webClient.get()
                .uri("/posts/1")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class)
                .block(); // waits for response

        long end = System.currentTimeMillis();
        System.out.println("=== Synchronous Request End (Time: " + (end - start) + " ms) ===");
        return response;
    }

    // --- Asynchronous Example ---
    @GetMapping(value = "/async", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<String> getAsyncData() {
        System.out.println("=== Asynchronous Request Start ===");
        long start = System.currentTimeMillis();

        // Non-blocking call
        Mono<String> responseMono = webClient.get()
                .uri("/posts/1")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class)
                .doOnNext(resp -> {
                    long end = System.currentTimeMillis();
                    System.out.println("=== Asynchronous Response Received (Time: " + (end - start) + " ms) ===");
                });

        System.out.println("Main thread continues execution immediately (non-blocking).");
        return responseMono;
    }
}
----------------------------------------------------------------------------------------------------------
package com.example.webclientdemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebClientDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(WebClientDemoApplication.class, args);
    }
}
----------------------------------------------------------------------------------------------------------
--REST API Excption Handling
We should give meaningful msg when exception occurs,global exception handler

@RestController
public class DemoRestController {
	@GetMapping("/welcome")
	public String welcomeMsg() {
		String msg = "Welcome to REST API...";
		int i = 10/0;
		return msg;
	}

}
----------------------------------------------------------------
@Data
public class ErrorInfo {
	private String code;
	private String msg;
	private LocalDate date;
}
----------------------------------------------------------------
@RestControllerAdvice
public class AppExceptionHandler {
	@ExceptionHandler(value=Exception.class)
	public ResponseEntity<ErrorInfo> handleException(Exception e){
		String errMsg = e.getMessage();
		ErrorInfo info = new ErrorInfo();
		info.setCode(errMsg);
		info.setMsg("SBIEX0003");
		info.setWhen(LocalDate.now());
		return new ResponseEntity<>(info,HttpStatus.INTERNAL_SERVER_ERROR);
	}
	
	@ExceptionHandler(value=UserNotFoundException.class)
	public ResponseEntity<ErrorInfo> handleUserNotFoundException(UserNotFoundException e){
		String errMsg = e.getMessage();
		ErrorInfo info = new ErrorInfo();
		info.setCode(errMsg);
		info.setMsg("SBIEX0004");
		info.setWhen(LocalDate.now());
		return new ResponseEntity<>(info,HttpStatus.BAD_REQUEST);     //different status code---->400 client side exception
	}

}
---------------------------------------------------------------
-User Defined Exception:

public class UserNotFoundException extends Exception{
	private static final long serialVersionUID = 892744662240479766L;
	public UserNotFoundException() {
		
	}
	public UserNotFoundException(String msg) {
		super(msg);                              //RuntimeException constructor will be called
	}

}
------------------------------------------------------------------
@RestController
public class UserRestController {
	@GetMapping("/user/{userId}")
	public String getUserName(@PathVariable("userId") Integer userId) throws UserNotFoundException {
		if(userId == 100) {
			return "john";
		}else if(userId == 200) {
			return "smith";
		}else {
			throw new UserNotFoundException("User not Found");
		}
		
	}

}
-----------------------------------------------------------------
Note: When ArithmeticException occurs, it will check any handler for it or not--->if not, it will go for generic exception. For client app, we are senging meaningful message,
Sending response in JSON format to client app

---properties file vs yml(Yet Another MarkUP language) file
--properties file-->represents data in key-values format and used only in java applications
--yml file--->represents data in hierarchical format, universal format(Java,Ansible,K8s,Python),indent spacing is important
-For multiple values use list
ex:
hobbies:
    -singing
	-playinfg
	-dancing
	
--Actuators:-
Need to add dependency-->spring-boot-starter-actuator
 Used to provide production-ready features for our application(i.e monitor and manage our application)-->no of beans loaded,app health, conifg properties,
environments loaded,threads,JVM and heap etc
https://docs.spring.io/spring-boot/reference/actuator/index.html
https://docs.spring.io/spring-boot/reference/actuator/endpoints.html
URL->http://localhost:9090/actuator, http://localhost:9090/actuator/health
-To enable actuators-----> .include/.exclude
--application.yml-->
spring:
  application:
    name: 40-CSV-PDF-App
server:
  port: 9090
management:
  endpoints:
    web:
      exposure:
        include: '*'                     //Expose all endpoints
        exclude: 'mappings'              //mapping will not be ommited
  endpoint:
    shutdown:
      enabled: true                     //we have configured shutdown of app


URL-->http://localhost:9090/actuator/mapping ---->All URL patterns loaded by our application
      http://localhost:9090/actuator/beans ---> All classes loaded by our (Predefined and custom)
	  http://localhost:9090/actuator/threaddump
	  http://localhost:9090/actuator/heapdump
	  
Note:Shutdown is a special endpoint which is used to stop our application and it is mapped to POST request.
http://localhost:9090/actuator/shutdown	  

--------------------------------------------------------------------------------------------------------------------------------------------
--Microservices--->It is architectural design pattern
Microservices project means it contains collection of REST APIs, and every REST API responsible for one functionality(Independently deployable ,testable)
Advantages:--Easy maintenance,High availability,Fast Development, Quick Releases, Technology Independence(Each REST ApI can be developed with differnt technology)
Challenges:--Bounded context(Deciding No of microservices), lots of configuration and visibility
Microservices Architecture-->Their is no fixed architecture, customize architeture according to project requirement
Example
+-----------------------+       +-----------------------+       +-----------------------+
|         UI            | --->  |     API Gateway       | --->  |   Service Registry     |
| (Frontend / Angular)  |       | (Spring Cloud Gateway)|       |      (Eureka)          |
+-----------------------+       +-----------------------+       +-----------------------+
                                                                          |
                                                                          v
-------------------------------------------------------------------------------------------------------------
|                                                                                                           |
|   +----------------+       +----------------+       +------------------+       +------------------+        |
|   |   Service A    |<----->|   Service B    |<----->|   Admin Server   |<----->|  Zipkin Server   |        |
|   | (API-1)        |       | (API-2)        |       | (Monitoring)     |       | (Tracing)        |        |
|   +--------+-------+       +--------+-------+       +------------------+       +------------------+        |
|            |                        |                                                               |      |
|            |                        |                                                               |      |
|     +------+-----+          +--------+--------+                                                      |      |
|     |    Redis    |          |       Kafka     |                                                      |      |
|     | (Caching)   |          | (Event Stream)  |                                                      |      |
|     +-------------+          +-----------------+                                                      |      |
|                                                                                                      |      |
|     +---------------------------------------------------------------------------------------------+  |      |
|     |                               Config Server (Centralized Config)                            |  |      |
|     |         ↑                    ↑                     ↑                    ↑                    |  |      |
|     |         |                    |                     |                    |                    |  |      |
|     |    Gateway, Service A,   Service B,          Admin Server,         Zipkin Server             |  |      |
|     |   etc. all fetch configs at startup and refresh dynamically from here                        |  |      |
|     +---------------------------------------------------------------------------------------------+  |      |
-------------------------------------------------------------------------------------------------------------

--Service Registry-->It will maintain list of apis available in our project(apis acts as clients of Eureka server(Spring cloud) which acts as Service Registry)-->Name,status and URL
@SpringBootApplication
@EnableEurekaServer
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}

application.yml
---------------
spring:
  application:
    name: 41-SBMS-Service-Registry
server:
  port: 8761
eureka:
  client:
    register-with-eureka: false            //Other app should register with Eureka server, but same application should not

Note: If Service-Registry port is 8761, then client can discover service-registry and will register automatically with service-registry else, we have to register clients with service-registry manually
application.yml     ------>manual registration
---------------
eureka:
  client:
    service-url:
      defaultZone: http://localhost:9090/eureka/


--Admin Server-->It will provide dashboard to monitor and manage all apis actuator at one place(All apis acts as client to admin server also)
@EnableAdminServer
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}

application.yml
----------------
spring:
  application:
    name: 42-SBMS-Admin-Server
server:
  port: 1111

--Zipkin Server-->It is used for distributed tracing(i.e Tracing one request by one api). It will provide information about request processing time(Performace of apis)
Add sleuth dependency, to connect with zipkin server
Download jar-->zipkin.io/quickstart(Java--latest release)
default port: 9411------> http://localhost:9411/zipkin/
To run-->commands
curl -sSL https://zipkin.io/quickstart.sh | bash -s
java -jar zipkin.jar
-Instead of sleuth, add these following dependencies
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-tracing-bridge-brave</artifactId>
</dependency>

<dependency>
    <groupId>io.zipkin.reporter2</groupId>
    <artifactId>zipkin-reporter-brave</artifactId>
</dependency>


Note: Whatever api we develop acts as client for all following apis
http://localhost:8761 --->Service Registry
http://localhost:1111 ---->Admin Server
http://localhost:9411/zipkin/ --->Zipkin Server

--API GateWay-->Request Verifcation and Request validation.(Any request coming to api should come first to api gateway).It will acts as a entry point for all backend apis, it will act as mediator between incoming requestts and backend apis
ex-zuul proxy(Backend),spring cloud Gateway(Open Source),ApiGee(Google, Commercial)

--ConfigServer-->It is used to seperate configuration properties from our application-->For loosely coupling
Project + Project configuration Properties

--Redis Server-->It is used to maintain distributed cache(Cache memory)-->used to reduce number of db calls from our application to DB
Data = Dynamic + Static(Stor static data in Redis cache to reduce database calls)

--Apache kafka-->Message broker, used to develop event driven microservices(to send message from one app to another app)

---Create one application for Service registry, Admin Server and Zipkin Server
Add following dependencies-->
  Spring-web
  DevTools
  Actuator
  Eureka Discovery client
  Spring boot admin client
  zipkin
  sleuth ------> It will communicate with zipkin server

  application.yml
  ---------------
  spring:
  application:
    name: 43-GREET-API
  boot:
    admin:
      client:
        url: http://localhost:1111/                //To tell admin server available(spring.boot.admin.client.url=)
management:
  endpoints:
    web:
      exposure:
        include: '*'
server:
  port: 9090

------------------------------------
--For InterService communication, we will use feign client(Also can be done with RestTemplate)

@FeignClient("GREET-API")
public interface GreetFeignClient {
	@GetMapping("/greet")
	public String invokeGreetApi();         //RunTime implementation by using proxy design pattern
}
---------------
@RestController
public class WelcomeRestController {
	
	@Autowired
	private GreetFeignClient client;
	
	@GetMapping("/welcome")
	public String welcomeMsg() {
		String greetResponse = client.invokeGreetApi();
		return greetResponse + " Welcome to REST";
	}

}
------------------------
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}
-----------------------
Note: When call invokeGreetApi() method, feign client will take service-name and go to service registry and get the url of API. Then feign client will talk to Greet API by sending GET request with '/greet' as URL pattern pattern

---Load Balancer---> To achieve high availability(using FeignClient-->Already load balancing implemented in it)
-What if 1 million request---> 1 tomcat server can not handle it. 
In real time--> Application should not run in one server. so same application should run in multiple server.
Note: With RestTemplate,only one url so no load balancing.
 Feign client will get multiple URL, it will get confused which to use , to avoid confusion spring cloud contains Ribbon. FeignClient contact ribbon, 
 it will decide which URL to use to access GREET API(Logic is round robin). If get more traffic, we can increase instances.(Run configurations---->To do it manually)
 i.e Scalability-->Without stopping any instance, creating new instance
 Autoscaling---->System will decide how much servers it needed, based on traffic
 
---API Gateway(Spring Cloud API Gateway)-->Entry point for all microservices. Any request coming to backend services should go through API Gateway. In API Gateway, Filter logic and 
Routing logic available.(Mediator between UI and BackEnd)
 Filter-->stopping unwanted requests, valid request allowed
 Routing-->From API Gateway, where it should go
-In API Gateway-->we will have 3 types of logics
    Route,Predicate(if path matched, request directed to that uri),Filters

--Servelet based
-To Create API GateWay, add following dependencies
<dependencies>
    <!-- Spring MVC Gateway -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway-mvc</artifactId>
    </dependency>
    
    <!-- Spring Web MVC -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Eureka Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    
    <!-- Actuator -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- Dev Tools -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
</dependencies>

-Routing-->Whenever request comes with '/welcome' url pattern, you go to welcome api, handle that request so on...It can have one url or multiple instances. 
Routing used to distribute request from one app to other app

-application.yml
-----------------
spring:
  application:
    name: 45-SBMS-API-GATEWAY

  main:
    web-application-type: servlet

  cloud:
    gateway:
      mvc:  # ✅ not under server
        routes:
          - id: greet-api
            uri: lb://43-GREET-API
            predicates:
              - Path=/greet/**
          - id: welcome-api
            uri: lb://44-WELCOMEAPI-INTERSERVICECOMMUNICATION-MONITOR
            predicates:
              - Path=/welcome/**
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true

server:
  port: 2222

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
    register-with-eureka: true
    fetch-registry: true
  instance:
    prefer-ip-address: true

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always

logging:
  level:
    org.springframework.cloud.gateway.server.mvc: TRACE




  
-Routing Flow
  Client Request → Gateway (Port 2222) → Route Matching → Service Discovery → Load Balancing → Target Service
     ↓
http://localhost:2222/welcome → Gateway → WELCOME-API service instance

                    +-----------------+
                    |       UI        |
                    +--------+--------+
                             |
                             v
         +-------------------------------------------+
         |        API Gateway (Spring Cloud Gateway) |
         |-------------------------------------------|
         |  Port: 2222                               |
         |  - Routing                                |
         |  - Filters                                |
         |  - Authentication/Authorization           |
         +------------------+------------------------+
                             |
                             v
             +-----------------------------------+
             |  Service Registry (Eureka Server)  |
             |  Port: 8761                        |
             |  - Registers all microservices     |
             |  - Enables load balancing          |
             +------------------+-----------------+
                             |
     -------------------------------------------------------------
     |                           |                               |
     v                           v                               v
+-------------+          +----------------+           +-----------------+
|  API-1      |          |    API-2       |           |   Config Server |
|-------------|          |----------------|           |-----------------|
| Port: 9090  |          | Ports: 8081,   |           | Port: 8888      |
|             |          | 8082, 8083     |           | - Centralized   |
| @EnableEurekaClient |  | @EnableEurekaClient |      |   config mgmt   |
| @EnableFeignClients  |  | Feign client to 3rd API   |                 |
+----------+------------+  +-----------+--------------+-----------------+
           |                           |               
           |                           v
           |                  +------------------+
           |                  | 3rd Party API(s) |
           |                  +------------------+
           |
   ------------------------------
   |            |              |
   v            v              v
+------+    +---------+    +----------------+
|Redis |    |  Kafka  |    | Admin Server   |
|Port: |    |Port:9092|    | Port: 1111     |
|Cache |    |Message Q|    | Monitors Apps  |
+------+    +---------+    +----------------+
                             |
                             v
                      +---------------+
                      | Zipkin Server |
                      | Port: 9411    |
                      | Distributed   |
                      | Tracing       |
                      +---------------+

-Filter-->If we want to perform operation before processing your request then we use filer

@Component
public class MyFilter implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        System.out.println(">>> Request Info <<<");
        System.out.println("Method: " + request.getMethod());
        System.out.println("URI: " + request.getRequestURI());
        System.out.println("Headers:");

        Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            System.out.println(headerName + ": " + request.getHeader(headerName));
        }

        // Continue the chain
        chain.doFilter(request, response);

        System.out.println("<<< Response Status: " + response.getStatus());
    }
}


--Reactive Based API Gateway
<dependencies>
        <!-- Spring Cloud Gateway (Reactive) -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <!-- Eureka Client -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>

        <!-- Actuator for monitoring -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Devtools (optional) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>

application.yml
----------------
server:
  port: 2222

spring:
  application:
    name: 46-sbms-reactive-apigateway

  main:
    web-application-type: reactive  # ✅ WebFlux for reactive gateway

  cloud:
    gateway:
      routes:
        - id: greet-api
          uri: lb://43-GREET-API
          predicates:
            - Path=/greet/**
        - id: welcome-api
          uri: lb://44-WELCOMEAPI-INTERSERVICECOMMUNICATION-MONITOR
          predicates:
            - Path=/welcome/**
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
    register-with-eureka: true
    fetch-registry: true
  instance:
    prefer-ip-address: true

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always

logging:
  level:
    org.springframework.cloud.gateway: TRACE
---------------------------------------------

@Component
public class CustomGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println(">> Filter Execution Started::: ");
        ServerHttpRequest request =exchange.getRequest();
        RequestPath path = request.getPath();
        System.out.println(">> Pre Filter: "+path);
        System.out.println("--------------------------------------------");
        HttpHeaders headers = request.getHeaders();
        Set<String> keySet = headers.keySet();
        for(String key: keySet) {
        	System.out.print(key+" ");
        	System.out.println(headers.getValuesAsList(key));
        	
        }
        // Call the next filter in the chain
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            // Post Filter logic
            System.out.println("<< Post Filter: " + exchange.getResponse().getStatusCode());
        }));
    }

    @Override
    public int getOrder() {
        return -1; // Precedence, lower = higher priority
    }
}


---Redis Cache
 Database = Static tables + non-static tables
 Connecting with db = Load Driver, create connection, execute query, process data, close connection (Costly operation as it takes time, performance reduces)
 Instead we can store static data in cache and call db for dynamic data
 --Cache-->Temporary storage in key-value format. By using it we can reduce no of db calls
 
Redis--> Open source, In Memory database store. It can be used as a DB,Cache, Streaming engine and message broker.
Install Redis Server in PC
Java application is client for REDIS(default port: 6379)
dependency-->springboot-starter-redis---->JedisConnFactory class(To connect with Redis server)
Configuration of Redis we will set to JedisConnFactory class object(injected in RedisTemplate Class)
--We will use below components to communicate with Redis Server
-RedisConnectionFactory: It represents connection with Redis Server
-RedisTemplate: It provides method to perform operations with Redis Server
-OpsForHash: It is providing methods to perform operations based on Hash Key(CRUD Operations)
 put(..),get(..),entries(..),delete(..)
Example:  user:123:profile   →  { "id":123, "name":"Rohit", "role":"Admin"}--->123(key):profile(table)
┌────────────────────────────────────────────────────────────────────────┐
│                    🚀 SPRING BOOT APPLICATION ARCHITECTURE             │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│   ┌───────────────────────┐                                            │
│   │     CONTROLLER LAYER  │                                            │
│   │  • Handles HTTP calls │                                            │
│   │  • Delegates to       │                                            │
│   │    Service Layer      │                                            │
│   └──────────┬────────────┘                                            │
│              │                                                         │
│              ▼                                                         │
│   ┌───────────────────────┐                                            │
│   │      SERVICE LAYER    │                                            │
│   │  • Contains business  │                                            │
│   │    logic              │                                            │
│   │  • Uses caching       │                                            │
│   │    annotations:       │                                            │
│   │     - @Cacheable      │                                            │
│   │     - @CachePut       │                                            │
│   │     - @CacheEvict     │                                            │
│   │     - @Caching        │                                            │
│   └──────────┬────────────┘                                            │
│              │                                                         │
│              ▼                                                         │
│   ┌───────────────────────┐                                            │
│   │    REPOSITORY LAYER   │                                            │
│   │  • Interacts with DB  │                                            │
│   │  • Executes queries   │                                            │
│   └──────────┬────────────┘                                            │
│              │                                                         │
│              ▼                                                         │
│   ┌──────────────────────────────────────────────────────────────┐     │
│   │           🧠 SPRING CACHE MANAGER (Redis Backend)             │     │
│   │  • Central cache abstraction layer                           │     │
│   │  • Connects Spring Cache → Redis                             │     │
│   │                                                              │     │
│   │  ┌────────────────────────────────────────────────────────┐  │     │
│   │  │  Cache Operations via Annotations:                     │  │     │
│   │  │   @Cacheable  → Read from cache                        │  │     │
│   │  │   @CachePut   → Update cache after method execution    │  │     │
│   │  │   @CacheEvict → Remove outdated cache entries          │  │     │
│   │  │   @Caching    → Combine multiple cache actions         │  │     │
│   │  └────────────────────────────────────────────────────────┘  │     │
│   └──────────────────────────────────────────────────────────────┘     │
│              │                                                         │
│              ▼                                                         │
│   ┌──────────────────────────────────────────────────────────────┐     │
│   │    🔧 REDIS TEMPLATE / CACHE WRITER COMPONENTS                │     │
│   │  • Handles communication between Cache Manager & Redis       │     │
│   │                                                              │     │
│   │  ┌───────────────┬───────────────┬────────────────────────┐  │     │
│   │  │ Key Serializer│ Value Serializer│ Data Serializer       │  │     │
│   │  │ (e.g. String) │ (e.g. JSON)    │ (Object Mapping)      │  │     │
│   │  └───────────────┴───────────────┴────────────────────────┘  │     │
│   └──────────────────────────────────────────────────────────────┘     │
│              │                                                         │
│              ▼                                                         │
└──────────────┼─────────────────────────────────────────────────────────┘
               │
               ▼
┌────────────────────────────────────────────────────────────────────────┐
│                      🧱 REDIS SERVER (In-Memory Cache)                 │
├────────────────────────────────────────────────────────────────────────┤
│  • High-performance in-memory key-value store                          │
│  • Stores serialized JSON or Java objects                              │
│  • Supports multiple data structures:                                  │
│     - Strings                                                          │
│     - Hashes                                                           │
│     - Lists                                                            │
│     - Sets / Sorted Sets                                               │
│                                                                        │
│  Example Entries:                                                      │
│     user:123:profile   →  { "id":123, "name":"Rohit", "role":"Admin"}  │
│     product:456:detail  →  { "id":456, "price":4999, "stock":30 }      │
└────────────────────────────────────────────────────────────────────────┘


┌──────────┐     ┌────────────┐     ┌─────────────┐     ┌──────────────┐
│  Client  │ ───▶│ Controller │ ───▶│  Service    │ ───▶│ @Cacheable   │
│  Request │     │   Layer    │     │   Layer     │     │   Method     │
└──────────┘     └────────────┘     └─────────────┘     └──────┬───────┘
                                                               │
                                                               ▼
                                                     ┌──────────────────┐
                                                     │   Check Redis    │
                                                     │      Cache       │
                                                     │                  │
                                                     │   Data Found?    │
                                                     └───────┬──────────┘
                                                             │
                                           ┌─────────────────┴─────────────────┐
                                           │                                   │
                                         Yes                                   No
                                           │                                   │
                                           ▼                                   ▼
                             ┌────────────────────┐              ┌────────────────────┐
                             │ Return cached data │              │   Query Database   │
                             │    (Fast access)   │              │  (Fetch from DB)   │
                             └─────────┬──────────┘              └─────────┬──────────┘
                                       │                                   │
                                       │                                   ▼
                                       │                        ┌────────────────────┐
                                       │                        │  Store in Redis    │
                                       │                        │      Cache         │
                                       │                        └─────────┬──────────┘
                                       │                                   │
                                       ▼                                   │
┌──────────┐     ┌────────────┐     ┌─────────────┐                      │
│  Client  │ ◀───│ Controller │ ◀───│  Service    │◀─────────────────────┘
│ Response │     │   Layer    │     │   Layer     │
└──────────┘     └────────────┘     └─────────────┘

┌────────────────────────────┐        ┌────────────────────────────┐        ┌────────────────────────────┐        ┌─────────────────┐
│   Spring Boot Service      │ ───▶   │  RedisTemplate<K, HK, V>  │ ───▶  │ opsForHash() (put/get/del)│ ───▶  │ JedisConnectionFactory  │
│  - Calls Redis operations  │        │  - High-level API for Redis│        │ - Hash operations          │        │ - Connects to Redis   │
└────────────────────────────┘        └────────────────────────────┘        └────────────────────────────┘        │   server              │
                                                                                                                  └─────────────┬─────────┘
                                                                                                                                │
                                                                                                                                ▼
                                                                                                                    ┌─────────────────┐
                                                                                                                    │   Redis Server  │
                                                                                                                    │ - Stores data   │
                                                                                                                    │   as Hashes     │
                                                                                                                    │ key→hashKey→val│
                                                                                                                    └─────────────────┘
--JedisConnectionFactory-----Inject into--->RedisTemplate--->OpsForHah

Example:
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>redis.clients</groupId>
			<artifactId>jedis</artifactId>
			<!--<version>5.1.5</version>--> <!-- ✅ Compatible with Spring Boot 3.5.x -->
		</dependency>
		
--------------
Binding class

@Data
public class Country implements Serializable{
	
	private Integer sno;
	
	private String name;
	
	private String countryCode;

}
--------------
Redis config class

@Configuration
public class RedisConfig {
	@Bean
	public JedisConnectionFactory jedisconn() {
		JedisConnectionFactory jedis = new JedisConnectionFactory();
		//we can set redis server properties here
		/*
		 * jedis.setHostName("127.0.0.1"); jedis.setPort(6379);
		 * jedis.setPassword("yourPassword");
		 */
		return jedis;
	}
	
	@Bean
	public RedisTemplate<String, Country> redisTemplate(){         //kind of data stored in redis i.e Country type
		RedisTemplate<String, Country> rt = new RedisTemplate<>();    
		rt.setConnectionFactory(jedisconn());             //Injecting JedisConnectionFactory object here
		return rt;
	}
	
	
}
--------------
@RestController
public class CountryRestController {
	
	HashOperations<String, Integer, Country> opsForHash = null;       -----> HashOperations<key, key from table, value > opsForHash
	
	@Autowired
	public CountryRestController(RedisTemplate<String, Country> rt) {
		this.opsForHash = rt.opsForHash();
	}
	
	@PostMapping("/country")
	public String addCountry(@RequestBody Country country) {
		opsForHash.put("COUNTRIES", country.getSno(), country);
		return "Contry Added.....";
	}
	
	@GetMapping("/countries")
	public Collection<Country> getCountries() {
		Map<Integer,Country> entries = opsForHash.entries("COUNTRIES");
		Collection<Country> values = entries.values();
		return values;
	}

}

--Cloud Config Server-->When package jar/war, application.prooperties/application.yml also part of it. If property changed, need to package again(Tightly coupled)
We can externalize configuration properties by using config server. We will keep .yml in github and to load it create one app{Config server app}. When run api it 
will connect with config server and load properties(yml should match with our api/app name)
steps-->Maintain application configuration yml in github repo(app name and yml file should be same)
        Config server app will connect with GitHub repo to load all ymls
		Our APIs(Microservices) will connect with config server to load yml data based on application name.
Note: If we use config server, then we no need to repackage our application when we make some changes in properties

┌────────────────────────────┐         ┌───────────────────────────┐         ┌──────────────────────┐
│        GitHub Repo         │  --->   │     Config Server App     │  --->   │      greet-api       │
│────────────────────────────│         │───────────────────────────│         └──────────────────────┘
│  greet.yml                 │         │  (Fetches configs from    │
│  welcome.yml               │         │   GitHub and serves to    │         ┌──────────────────────┐
│  admin.yml                 │         │   microservices)          │  --->   │    welcome-api       │
└────────────────────────────┘         └───────────────────────────┘         └──────────────────────┘
                                                                               ┌──────────────────────┐
                                                                               │     admin-api        │
                                                                               └──────────────────────┘
---------------------------------------
        <dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-config-server</artifactId>
		</dependency>


@EnableConfigServer
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}

application.yml
------------
spring:
  application:
    name: 48-Config-Server-App
  cloud:
    config:
      server:
        git:
          uri: https://github.com/rohitlavate97/config_server_properties
          clone-on-start: true
server:
  port: 9090

--Config-server-client app
dependencies--> web-starter
                config-client
				dev-tools
				spring-cloud-starter-config
				


@RestController
public class WelcomeRestController {
	
	@Value("${msg}")
	private String msg;
	
	@GetMapping
	public String getWelcomeMsg() {
		return msg;
	}

}

application.yml
----------------
spring:
  application:
    name: 49-Config-Server-Client-App   # 👈 The name used to fetch the correct YAML file from Config Server
  config:
    import: optional:configserver:http://localhost:9090  # 👈 URL of your Config Server
server:
  port: 9091  # 👈 Local port where this client (microservice) will run
  
We also can add profile also--->spring.profiles.active = dev

---Apache kafka
-Event Streaming is practice of capturing data in real time from event sources(Sources-->db,sensors,mobile devices,cloud services and software applications)
Using Event Streams, we can keep right information at right place at right time.
-Uses of Data-->Application data can be used to run analytics in real time serving various purposes like
               delivery advertisements
			   tracing abnormal user behaviors
			   displaying search based on relevance
			   showing recommendations based on previous activities
Ex: when we search product on amazon, we can see product in their apps i.e amzaon sales data to those apps(To promote business)
To share data between two applications, we need to establish pipeline between these apps(difficult)-->so we use message broker(Data stored in message queue and fb,youtube etc will take data from it)
Here webservices call is not possible, as every second data is generating

┌─────────────────────────────────────────────────────────────────┐
│                     Amazon.in E-commerce Platform               │
└─────────────────────────────────────────────────────────────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   ▼                   ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   Event         │ │   Product       │ │   Order         │
│   Producers     │ │   Catalog       │ │   Service       │
│                 │ │   Producer      │ │   Producer      │
└─────────────────┘ └─────────────────┘ └─────────────────┘
         │                   │                   │
         └───────────────────┼───────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Apache Kafka Cluster                         │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │
│  │ user_events │  │product_updates│ │order_events │  │email_events││
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │
│         │                │                │             │       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────┐ │
│  │ Partitions  │  │ Partitions  │  │ Partitions  │  │Partitions││
│  │    P0-P7    │  │    P0-P5    │  │    P0-P5    │  │  P0-P3  │ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────┘ │
└─────────────────────────────────────────────────────────────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   ▼                   ▼
    ┌─────────┐         ┌─────────┐         ┌─────────┐
    │Consumer │         │Consumer │         │Consumer │
    │ Groups  │         │ Groups  │         │ Groups  │
    └─────────┘         └─────────┘         └─────────┘
         │                   │                   │
    ┌────┼────┐         ┌────┼────┐         ┌────┼────┐
    │    │    │         │    │    │         │    │    │
    ▼    ▼    ▼         ▼    ▼    ▼         ▼    ▼    ▼
┌────┐┌────┐┌────┐ ┌────┐┌────┐┌────┐ ┌────┐┌────┐┌────┐
│YouTube││Facebook││LinkedIn││Gmail ││Naukri││Others││Analytics│
└────┘└────┘└────┘ └────┘└────┘└────┘ └────┘└────┘└────┘

--Types of applications by Message Flow Role
-Publishers-->Applications which store data into Apache kafka
-subscribers-->Application takes data from message queue
Note: One producer can have multiple subscribers

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Rider     │    │   Uber      │    │   Driver    │
│   App       │    │  Backend    │    │   App       │
└─────────────┘    └─────────────┘    └─────────────┘
      │                   │                  │
      │ 1. Book Cab       │                  │
      │──────────────────▶│                  │
      │                   │                  │
      │                   │ 2. Publish to    │
      │                   │    Kafka         │
      │                   │───────┐          │
      │                   │       │          │
      │                   │       ▼          │
      │                   │ ┌─────────────┐  │
      │                   │ │   KAFKA     │  │
      │                   │ │  - ride_requests│
      │                   │ └─────────────┘  │
      │                   │       │          │
      │                   │       │ 3. Notify│
      │                   │       │   Drivers│
      │                   │       └─────────▶│
      │                   │                  │
      │                   │ 4. Driver Accepts│
      │                   │◀─────────────────│
      │                   │                  │
      │ 5. Driver Assigned│                  │
      │◀──────────────────│                  │
      │                   │                  │
      │ 6. Ride in Progress                  │
      │──────────────────────────────────────▶│
      │                   │                  │
	  
-Why messaging system?--->Messaging system provide a seamless integration between distributed applications with help of messages(i.e data is treated as messages means message in stream of data), 
collecting data from different sources in different format becomes easy.
Model-->Publish and Subscribe model

--Apache Kafka-->Distributed straming platform, used to process real time data feeds with high throughput and low latency(ex-->Flights data ,sensors data , news data etc...)
It works based on Publish and Subscribe model-->It allows Producers generate data/persist data in Apache kafka topics, and that topic can be read by any number of systems who need that data(Consumers)

Event driven microservices-->Within the project we can use 'Message Queues'
example-->While booking in uber, it will send nearest driver-->booking api generated an event, msg saved-->Listner for other api-->once event generated other api takes data
         api continuously listening to msg queue-->when message comes it takes for processing immediately(Listeners listen event, they take that message and process that msg)-->all the listeners for project

+-------------------+        +------------------------+        +----------------------+
|    Swiggy / App     | --->   |  Orchestrator Service  | --->   |     Message Queue    |
| (Places Order)    |        | (Publishes Event e.g., |        | (Kafka / RabbitMQ)   |
|                   |        | "OrderPlaced")         |        |                      |
+-------------------+        +------------------------+        +----------------------+
                                                                /          |            \
                                                               /           |             \
                                                              v            v              v
                                       +----------------+  +----------------+  +---------------------+
                                       |  db api |  |         Restaurant    |  |  Notification       |
                                       | (Consumes Msg) |  |  api           |  |  Service            |
                                       | (Save Order,   |  | (Prepare /     |  | (Sends SMS, Push)   |
                                       |  Update DB)    |  |  Update Status)|  |                     |
                                       +----------------+  +----------------+  +---------------------+

Kafka is publish/subscribe system. Behind the scenes, kafka is distributed, scales well, replicates data across brokers(servers), can survive broken downtime and much more--->NEFT Queues, Ticket queue

 +----------------------------------------------------------------------------------------------+
|                          Data Producers (Sources)                                            |
+----------------------------------------------------------------------------------------------+
|   Metrics   |     Logs     |   Transaction Data   |   IoT Data   |   App Events   |
+----------------------------------------------------------------------------------------------+
           \         |             |              |              |              /
            \        |             |              |              |             /
             \       |             |              |              |            /
              \      |             |              |              |           /
                      v             v              v              v
                                   +----------------------------+
                                   |          KAFKA             |
                                   |  (Distributed Pub/Sub Bus) |
                                   +----------------------------+
                      ^             ^              ^              ^
                     /               \             |               \
+----------------------------------------------------------------------------------------------+
|      Online Applications      |   Stream Processing Systems   |  Offline Processing Systems  | 
|  (Apache Solr, OpenTSDB etc.) |  (Samza, Spark, Storm, Flink) |  (Hadoop, Hive, etc.)       |
+----------------------------------------------------------------------------------------------+
                                        |
                                        v
                          +-------------------------------+
                          |  Analytics / Reporting Tools  |
                          |  (BI Dashboards, Monitoring)  |
                          +-------------------------------+

Kafka Advantages-->High Throughput(Support for 100's of messages),scalability(No downtime), No data loss, Durability, Replication(Message can be replicated across clusters, which supports multiple subscribers)

--Kafka Core API-->Producer API
                   Consumer API
                   Streams API---------->To create pipeline of streams of data
                   Connector API-------->If app wants to store data in queue-->1st app should connect to queue(i.e connector api)

--Kafka Installation-->
   Download and Run zookeeper
   Download and run apache kafka server
   Create topic(buckets in message queue) in apache kafka--->used to differentiate messages(everything can't be stored in single topic)
   
           ┌────────────────────────────────────────────────────────────┐
          │                    Kafka Cluster                           │
          └────────────────────────────────────────────────────────────┘
                                    │
         ┌──────────────────────────────────────────────────────────┐
         │                        Topics                            │
         └──────────────────────────────────────────────────────────┘
              │                   │                     │
              ▼                   ▼                     ▼
    ┌────────────────┐   ┌────────────────┐   ┌────────────────┐
    │ Topic: orders  │   │ Topic: payments│   │ Topic: logs    │
    └────────────────┘   └────────────────┘   └────────────────┘
          │                    │                    │
          ▼                    ▼                    ▼
 ┌────────────────┐   ┌────────────────┐   ┌────────────────┐
 │ Partition 0    │   │ Partition 0    │   │ Partition 0    │
 │ Partition 1    │   │ Partition 1    │   │ Partition 1    │
 └────────────────┘   └────────────────┘   └────────────────┘
          │                    │                    │
          ▼                    ▼                    ▼
 ┌────────────────┐   ┌────────────────┐   ┌────────────────┐
 │ Consumer Group │   │ Consumer Group │   │ Consumer Group │
 │ (Order Service)│   │ (Payment App)  │   │ (Logging Tool) │
 └────────────────┘   └────────────────┘   └────────────────┘

--Spring boot and Apache Kafka application steps to build
step 1--> Download zookeeper and extract zip(URL: https://zookeeper.apache.org/releases.html)
step 2--> Download Apache Kafka (URL: https://kafka.apache.org/downloads)
step 3--> set path to ZOOKEEPER in environment variables upto bin folder(system variables-->path-->%apache-zookeeper-3.8.5-bin\bin)
step 4--> start ZOOKEEPER server using below command from kafka folder
       command: zookeeper-server-start.bat zookeeper.properties
	   Note: Above command is available in kafka/bin/windows folder
	   Note: zookeeper.properties file will be available in config folder, you can copy zookeeper.properties and server.properties file from kafka/config folder to kafka/bin/windwos folder
step 5--> start kafka server using below command from kafka folder
       command: kafka-server-start.bat server.properties   -->starts kafka on zookeeper
	   Note: server.properties file available in config folder-->copy to windwos folders
step 6--> create kafka topic using below command from kafka/bin/windows folder
       command: kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partition 1 --topic 03-sbms-topic      --->(2181-->default port for zookeeper server) --->deprecated command
	   new commadn: kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic CUSTOMER
step 7--> View created tipic by below command
       command(deprecated): kafka-tipic.bat --list --zookeeper localhost:2181
	   new command: kafka-topics.bat --list --bootstrap-server localhost:9092
step 8-->create spring boot producer app

<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>

 server.port=9090

 
(Client Request)
       │
       ▼
+-----------------+       publish       +----------------------+       consume       +-----------------+
| Spring Boot App |  ───────────────▶  |      Apache Kafka     |  ───────────────▶  | Spring Boot App |
| (Publisher)     |                    | (Broker + Topics)     |                    | (Subscriber)    |
| PORT: 9090      |                    |                      ▼                     | PORT: 7070      |
+-----------------+                    |     +-------------+                        +-----------------+
                                       |     |  Zookeeper  |                       
                                       |     |-------------|                       
                                       |     | - Manages   |                       
                                       |     |   Brokers   |                       
                                       |     | - Metadata  |                       
                                       |     | - Election  |                       
                                       |     +-------------+                       
                                       +----------------------+

public class KafkaConstants {
	public static final String TOPIC = "CUSTOMER";            //need to create this topic in the kafka
	public static final String GROUP_ID = "GROUP_CUSTOMERS";
	public static final String HOST = "localhost:9092";
}
--------------------------
@Data
public class Customer {
	private Integer customerId;
	private String customerName;
	private String customerEmail;
}
----------------------------
@Service("CustomerService")
public class CustomerService {
	@Autowired
	private KafkaTemplate<String, Customer> kafkaTemplate;
	
	public String add(List<Customer> customers) {
		if(!customers.isEmpty()) {
			for(Customer c : customers) {
				kafkaTemplate.send(KafkaConstants.TOPIC, c);
				System.out.println("*****Message is published to kafka topic*****");
			}
		}
		return "Customer record is added to the Kafka-Queue successfully";
	}
}
------------------------------
@Configuration
public class KafkaProduceConfig {
	@Bean
	public ProducerFactory<String,Customer> producerFactory(){
		Map<String, Object> configProp = new HashMap<>();
		configProp.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, KafkaConstants.HOST);
		configProp.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);    //key-->TopicName
		configProp.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);    //value-->customerdata
		return new DefaultKafkaProducerFactory<>(configProp);
	}
	
	@Bean(name = "KafkaTemplate")
	public KafkaTemplate<String, Customer> kafkaTemplate(){
		return new KafkaTemplate<>(producerFactory());
	}

}
------------------
🧠 What Happens

ProducerFactory:
Creates Kafka producers using the given configuration (host, serializers, etc.).
Serializers ensure that String (topic key) and Customer (JSON message) are correctly sent to Kafka.

KafkaTemplate
Provides a high-level API to send messages easily from your CustomerService.
Autowired into your service like this:

@Autowired
private KafkaTemplate<String, Customer> kafkaTemplate;


You can now publish Customer objects to Kafka topics like:
kafkaTemplate.send(KafkaConstants.TOPIC, customer);
-----------------------
step 9-->create spring boot consumer app

<dependencies>
    <!-- Spring Boot Kafka -->
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka</artifactId>
    </dependency>

    <!-- JAXB for XML binding -->
    <dependency>
        <groupId>jakarta.xml.bind</groupId>
        <artifactId>jakarta.xml.bind-api</artifactId>
    </dependency>

    <dependency>
        <groupId>org.glassfish.jaxb</groupId>
        <artifactId>jaxb-runtime</artifactId>
    </dependency>

    <!-- Lombok (optional) -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>


public class KafkaConstants {
	public static final String TOPIC ="CUSTOMER";
	public static final String GROUP_ID = "GROUP_CUSTOMER";
	public static final String HOST ="localhost:9092";

}
-----------------
@XmlRootElement(name = "customer")
@XmlAccessorType(XmlAccessType.FIELD)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Customer {
	private Integer customerId;
	private String customerName;
	private String customerEmail;
}
-----------------
@EnableKafka
@Configuration
public class KafkaListenerConfig {
	
	@Bean
	public ConsumerFactory<String, Customer> consumerFactory() {
		/*
		 * JsonDeserializer<Customer> deserializer = new
		 * JsonDeserializer<>(Customer.class); deserializer.addTrustedPackages("*"); //
		 * allow deserialization from all packages
		 */
	    Map<String, Object> props = new HashMap<>();
	    props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, KafkaConstants.HOST);
	    props.put(ConsumerConfig.GROUP_ID_CONFIG, KafkaConstants.GROUP_ID);
	    props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
	    props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
	    props.put(JsonDeserializer.TRUSTED_PACKAGES, "*");
	    return new DefaultKafkaConsumerFactory<>(props, new StringDeserializer(), new JsonDeserializer<>(Customer.class));
	}

	
	@Bean
	public ConcurrentKafkaListenerContainerFactory<String, Customer> kafkaListenerContainerFactory() {
	    ConcurrentKafkaListenerContainerFactory<String, Customer> factory = new ConcurrentKafkaListenerContainerFactory<>();
	    factory.setConsumerFactory(consumerFactory());
	    return factory;
	}
}
------------------
@Component
public class KafkaMessageListener {

    @Autowired
    private CustomerService customerService;

    @KafkaListener(topics = KafkaConstants.TOPIC, groupId = KafkaConstants.GROUP_ID,
                   containerFactory = "kafkaListenerContainerFactory")
    public void consume(Customer customer) {
        System.out.println("✅ Received Customer: " + customer);
        customerService.setLastCustomer(customer);
    }
}

------------------
import com.alchemist.model.Customer;

public interface CustomerService {
    void setLastCustomer(Customer c);
    Customer getLastCustomer();
}
----------------
@Service
public class CustomerServiceImpl implements CustomerService {

    private Customer lastCustomer;

    @Override
    public void setLastCustomer(Customer c) {
        this.lastCustomer = c;
    }

    @Override
    public Customer getLastCustomer() {
        return lastCustomer;
    }
}


----------------------

@RestController
public class ConsumerRestController {

    @Autowired
    private CustomerService customerService;

    @GetMapping("/lastCustomer")
    public Customer getLastReceivedCustomer() {
        Customer c = customerService.getLastCustomer();
        if (c == null)
            throw new RuntimeException("No message received yet from Kafka topic.");
        return c;
    }

    @GetMapping("/status")
    public String getStatus() {
        return "✅ Kafka Consumer is running on port 7070";
    }
}

---------------------------
spring:
  application:
    name: 51-Apache-Kafka-Consumer
  kafka:
    consumer:
      group-id: GROUP_CUSTOMER
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "com.alchemist.model"
server:
  port: 7070
---------------------------

---Circuit Breaker in MicroServices--> Design Pattern for fault tolerence(Fault tolerent applications are called Resillience applications)

Client/API  ────▶  Circuit Breaker  ────▶  Remote Service
                      │
                      │ (When Open/Failed)
                      ▼
                Fallback/Error Message
				
				
				
┌──────────────┐     Request     ┌──────────────────┐
│   Client     │ ──────────────▶ │ Circuit Breaker   │
│    / API     │                 └─────────┬─────────┘
└──────────────┘                           │
                     ┌─────────────────────┼────────────────────┐
                     │                     │                    │
                     │ (State: CLOSED)     │ (State: OPEN)       │ (State: HALF-OPEN)
                     │ Normal Operation    │ Fast Fail           │ Test Limited Requests
                     ▼                     ▼                    ▼
            ┌─────────────────┐     ┌─────────────────┐   ┌─────────────────┐
            │ Remote Service  │     │ Fallback / Error │   │ Remote Service  │ (Test Call)
            │ (Healthy)       │     │ Message Response │   │ (If Recovers)   │
            └─────────────────┘     └─────────────────┘   └─────────────────┘					  



 CLOSED  ---- errors threshold ---->  OPEN
   ^                                    |
   |                                    | wait → try
   +------------ HALF-OPEN <------------+
                 |  success → CLOSED
                 |  failure → OPEN



					  
┌──────────────┐     Failure     ┌──────────────┐     Timeout     ┌──────────────┐
│    CLOSED    │ ──────────────▶ │     OPEN     │ ──────────────▶ │  HALF-OPEN  │
│              │                 │              │                 │              │
│ • Normal     │                 │ • Fast Fail  │                 │ • Test       │
│ • Requests   │                 │ • No Requests│                 │   Requests   │
│   Allowed    │                 │   Allowed    │                 │ • Limited    │
└──────────────┘                 └──────────────┘                 └──────┬───────┘
       Ａ                                                                    │
       │                              Success                         Failure│
       │                              (All Test Requests Pass)         (Any Test Fails)
       └─────────────────────────────────────────────────────────────────────┘
	   
-If service A(m1 method) communicates with service B(m2 method)-->

UI/Client → Service A → Service B → Database
    │           │           │           │
    │           │           │           │
 Frontend   API Layer  Business    Data
           Gateway     Logic      Persistence
		   
    If Service B is down-->Exception, we can use try and catch block for handling the Exception. but, if 1000's of requests-->not recommended approach
	So, we should go for Circuit breaker(Used to develop fault tolerence)---->configure Circuit breaker for service B(m2 method)--->If request failing consecutively(ex-->5 times)-->then on 6th time call m3 method
	Ex-->
	@CircuitBreaker(name="", fallbackmethod="m3")
	public String m2(){
	//logic to call Service-B using RestTemplate
	return str;
	}
	public String m3(){
	//alternate logic
	}
	
-circuit-breaker-config-properties-->when to execute m2() and m3()
                                    For how many requests we need to monitor
-Circuit breaker will have below 3 states-->CLOSED,OPEN,HALF-OPEN
| State         | Meaning                                  | Behavior                                                      |
| ------------- | ---------------------------------------- | ------------------------------------------------------------- |
| **CLOSED**    | System is working normally               | Requests flow normally to downstream service                  |
| **OPEN**      | Downstream service is failing repeatedly | Requests are *blocked immediately* and fallback logic is used |
| **HALF-OPEN** | Testing if service has recovered         | Sends **limited trial requests** to check service health      |

--What is Resilience4j-->Lightweight, easy to use fault tolerence library inspired by NetFlix Hystrix.It provides various features.
        Circuit Breaker-->Fault Tolerence
		Rate Limiter-->Block too many requests
		Time Limiter-->Limit time while calling remote operations
		Retry Mechanism-->Automatic retry for failed operations
		Bulkhead-->limit number of concurrent requests
		Cache-->Store results of costly remote operations
		
--Develop applications with circuit-breaker

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
	</dependencies>
--------------------------------------------
@Data
@AllArgsConstructor
@NoArgsConstructor
public class InterestRate {
	Integer id;
	String type;
	Double rateValue;
}
---------------------------------------------
@Service
public class LoanService {
	@Autowired
	private RestTemplate restTemplate;

	private static final String SERVICE_NAME = "loan-service";
	private static final String RATE_SERVICE_URL ="http://localhost:9091/rate/{type}";
	
	@CircuitBreaker(name = SERVICE_NAME, fallbackMethod = "getDefaultLoan")
	public InterestRate getAllLoansByType(String type) {
		System.out.println("*****Original Method called...*****");
		ResponseEntity<InterestRate> response = restTemplate.getForEntity(RATE_SERVICE_URL, InterestRate.class, type);
		return response.getBody();
	}
	
	// ✅ Correct fallback: Same params + Exception
	public InterestRate getDefaultLoan(String type, Exception e) {
		System.out.println("*****Fallback method called.....****");
		return new InterestRate(0, type, 7.5);  // return safe default response
	}
}

---------------------------------------
@RestController
public class LoanController {
	@Autowired
	private LoanService loanService;
	
	@GetMapping(path ="/loans")
	public ResponseEntity<InterestRate> getLoansByType(@RequestParam("type") String type){
		return ResponseEntity.ok().body(loanService.getAllLoansByType(type.toUpperCase()));
	}
}
---------------------------------------
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
	
	@Bean
	public RestTemplate restTemplate() {
		return new RestTemplate();
	}

}
---------------------------------------------
application.yml
---------------------------------------------
server:
  port: 9090

spring:
  application:
    name: 52-Circuit_breaker-LoanService
  datasource:
    url: jdbc:h2:mem:cb-loan-db
    username: root
    password: 123
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
    database-platform: org.hibernate.dialect.H2Dialect
  h2:
    console:
      enabled: true

management:
  endpoints:
    web:
      exposure:
        include: health
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true

resilience4j:
  circuitbreaker:
    instances:
      loan-service:                           #name is the link between code and properties(must match with SERVICE_NAME)
        register-health-indicator: true
        failure-rate-threshold: 50
        minimum-number-of-calls: 5            #After sending 5 calls it evaluates how many failed
        sliding-window-type: COUNT_BASED      # COUNT_BASED or TIME_BASED
        sliding-window-size: 10              # Evaluate last 10 calls
        wait-duration-in-open-state: 10s     # Stay OPEN for 10 sec → then go HALF-OPEN
        permitted-number-of-calls-in-half-open-state: 3  # Allow 3 test calls in HALF-OPEN
        automatic-transition-from-open-to-half-open-enabled: true
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Property Name                                               | Meaning                                             | Example                                                                |
| ----------------------------------------------------------- | --------------------------------------------------- | ---------------------------------------------------------------------- |
| `failure-rate-threshold: 50`                                | If **50% calls fail**, breaker will **OPEN**        | Out of 10 calls, if 5 fail → OPEN state                                |
| `minimum-number-of-calls: 5`                                | Evaluate failures **only after at least 5 calls**   | Before 5 calls → always CLOSED                                         |
| `sliding-window-type: COUNT_BASED`                          | Evaluate based on **last N calls**                  | Here N = 10                                                            |
| `sliding-window-size: 10`                                   | Looks at **last 10 calls** to decide                | If 6/10 fail → failure rate = 60% → OPEN                               |
| `wait-duration-in-open-state: 10s`                          | Stay in **OPEN state for 10 seconds**               | During this time → **no calls go to actual service**, fallback is used |
| `permitted-number-of-calls-in-half-open-state: 3`           | While HALF-OPEN, allow **3 test calls**             | If they succeed → go to **CLOSED**                                     |
| `automatic-transition-from-open-to-half-open-enabled: true` | Automatically move to HALF-OPEN after wait duration | After 10 seconds, allow 3 test calls                                   |

---------------------------------------------------------------------------
--Develop rate-service
---------------------------------------------------------------------------


<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
---------------------------
@Data
@AllArgsConstructor
@NoArgsConstructor
public class InterestRate {
	private Integer id;
	private String type;
	private Double rateValue;
}
--------------------------
@RestController
@RequestMapping("/rate")
public class RateController {

    @GetMapping("/{type}")
    public ResponseEntity<InterestRate> getRateByType(@PathVariable("type") String type) {

        System.out.println("****** Rate Service Called ******");

        if(type.equalsIgnoreCase("HOME")) {
            return ResponseEntity.ok(new InterestRate(101, "HOME", 7.5));
        }
        else if(type.equalsIgnoreCase("PERSONAL")) {
            return ResponseEntity.ok(new InterestRate(102, "PERSONAL", 11.2));
        }
        else if(type.equalsIgnoreCase("CAR")) {
            return ResponseEntity.ok(new InterestRate(103, "CAR", 9.0));
        }

        // Simulate service failure on unknown types
        throw new RuntimeException("Rate not found for type: " + type);
    }
}
--------------------------
server:
  port: 9091

spring:
  application:
    name: 52-Rate-Service
--------------------------


--Spring Security-->
-----------------
-Authentication(Verifying Credentials) + Authorization(User Access specific functionality)
Note:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
-When we add this dependency in pom.xml file, then by default our application will be secured with basic authentication. It will generate random password to access our application.When we access our application url in browser then,it 
will display 'Login Form' to authenticate our request.In order to access Secured REST API from Postman, we need to set Auth values in postman to send request.
    Auth: Basic Auth
	UserName: User
	Password: <Copy-from-console>
	
-When Secured REST-API available, we need to pass credentials in the Header(key-value) of Client.
-To override default credentials, we can configure security credentials in applicaion.properties/application.yml like below,
spring.security.user.name=admin
spring.security.user.password=password
#spring.security.user.roles=USER,ADMIN
-->Enter above username and password in Postman header to access the REST API

--Securing specific URL Pattern-->
-------------------------------
When we add securiry-starter--> it will apply security filter to all HTTP methods of our application. But in reality, we need to secure only few methods not all methods in our app-->Cusotmize security configuration
Ex: For banking application
    /login---> Security not needed
	/transfer--> Security required
	/balance---> Security required
	/about-us---> Security not required

@Configuration
@EnableWebSecurity
public class SecurityConfigurer{
     @Bean
	 public SecurityFilterChain securityFilter(HttpSecurity http) throws Exception{
	   http.authorizeHttpRequests(request)->request
	                             .antMatchers("/","/login","/about","/swagger-ui.html")
								 .permitAll()
								 ).formLogin();
	   return http.build();
	}
}

-Develop app
@RestController
public class SecurityRestController {
	@GetMapping("/hi")
	public String sayHi() {
		return "Hi, How are you?";
	}
	
	@GetMapping("/hello")
	public String sayHello() {
		return "Hello, how are you?";
	}
	
	@GetMapping("/contact")
	public String getContact() {
		return "Call us::+918600852978";
	}
}

@Configuration
@EnableWebSecurity
public class SecurityConfigurer {
	@Bean                                                                           //called when application is started
	public SecurityFilterChain securityFilter(HttpSecurity http) throws Exception{
		System.out.println("Security Filter Called.....");
		//Customize Security
		http.authorizeHttpRequests((req) ->
		//req.antMatchers("/contact").permitAll()       //deprecated
		req.requestMatchers("/contact").permitAll()                         //any request matches with this pattern will be permited
		.anyRequest().authenticated()                                       //else authenticated by user form login 
		).formLogin();
		return http.build();
	}
}

application.properties
spring.application.name=54-Spring-Securiry-App
spring.security.user.name=admin
spring.security.user.password=admin@123
server.port=9090
----------------------
-Database Authentication-->Hardcode values in application.properties not recommended, but real time app will be available in db,internally code is executed by spring security. Only if right credentials provided,
then it will allow to access the page
-Their is predefined class in the spring security named User. So whatever credetials in application.properties, loaded to User Object by Spring Security.