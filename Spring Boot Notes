Servers used for configuaration in Microservices development with Spring boot
-Service Registry
-Admin Server
-API Gateway

Development flow:
-From backend to UI
-API Gatewway acts as a mediator between FrontEnd and BackEnd

-Spring Core provides IOC and DI, to develop classes with loosely coupling
-Use Interface to provide common methods(increases readability)
Dependency Injection: Injecting dependent object into target object using target class variable/setter/constructor
-Different Types of Injection
--Constructor Injection
--Setter Injection
--Field Injection

What if we perform both constructor Injection and Setter Injection-->First construction injection will happen. then, it will
initialize the variable then setter injection will happen and it will reinitialize the same variable so final value be setter injection value
Note: Setter injection will override construction injection

In Spring, IOC is responsible for Dependency Injection
IOC manages and collaborate object(i.e Creating and injecting object). IOC is a principle which is used to manage and collaborate dependencies among the objects in the application
For IOC container, we need to provide Java Classes as input as it don't know which is target class. Along with Java classes we have to provide configuration(through Xml or annotartions)
IOC will load classes and then create object and will perform DI(i.e it provides spring beans-->Class which is managed by IOC)

Ways to Start the IOC
-BeanFactory(Outdated)
-ApplicationContext(interface)

Class managed by IOC is called as Spring Bean

ApplicationContext ctx = new ClassPathXmlApplicationContext(String xmlFilePath);


Beans.xml-----> should be created in src/main/java
-----------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
    <bean id="credit" class="com.alchemist.beans.CreditCardPayment"/>
    <bean id="debit" class="com.alchemist.beans.DebitCardPayment"/>
    <bean id="payment" class="com.alchemist.beans.PaymentService">
    <!-- to avoid Nullpointer exception as PaymentService don't have by default constructor-->
       <!--constructor-arg name="payment" ref="debit"/-->----------------This is the constructor injection
       <!--constructor-arg name="payment" ref="credit"/-->
       <property name="iPayment" ref="credit"/>--------------------------- this is how settter injection done, property name should be interface referece variable
     </bean>
</beans>
-----------------------------------------------------------------------------
Note: 'ref' attribute represents which object should be injected
-Field injection is only possible with Annotations

Spring Bean Scope-->Decides how many objects should be crated for spring bean class
-Singleton(Default)--> Every Spring Bean is Singleton, whenever we start IOC container, by default it will create objects for singlton bens and when we call getBean()(everytime it checks scope when we call this method) then it will create object for others(for memory management)
-Prototype--->Every time new object will be created
-Request
-Session
Note: Request and Session scopes are used in Spring web MVC

Syntax:
    <bean id="car" class="com.alchemist.beans.CarService" scope="prototype">
       <constructor-arg name="car" ref="petrol"/>
     </bean>

Manual Wiring--> injecting dependent object into target objects with 'ref' attribute is Manual Wiring
Autowiring-->To identify objects and injecting into the Target objects
works on below modes
-byName--->for setter injection--->based on bean id of bean matching with interface variable
-byType--->for setter injection--->based on type of variable, dependent bean will be identified(bean id doesn't matter)
-Constructor
-none

Syntax:
--byName--->identity dependent based on variable name matching with bean id
<bean id="car" class="com.alchemist.beans.CarService" autowire="byName">
--When we write 'autowire' attribute in the bean definition, that bean will be considered as Target Class

--byType--->identity dependent bean based on variable type
  autowire-candidate="false"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" autowire-candidate="false"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">
     </bean>
  primary="true"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" primary="true"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <!--bean id="car" class="com.alchemist.beans.CarService" autowire="byName"-->
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">

--constructor--->First it will check byName, then goes for byType, we can use primary="true" for any bean which we want to inject
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="constructor">
     </bean>

Spring Annotations: Annotations are used to provide metadata
---------------------------------------------------------------------------
@Configuration:->Instead of XML, java class can be marked as Configuration
@Component,@Service,@Repository-->To represent java class as spring bean class
@Scope-->To represent scope of the bean
@Qualifier-->When multiple beans of same type, it is used to identity bean based on the given name for DI
@Autowired:-->used to enable auto-wiring in a class
@Primary-->To give priority for the bean for auto-wiring
@Bean:-->The @Bean annotation in Spring Boot is used to declare a method that produces a bean to be managed by the Spring IoC (Inversion of Control) container. This annotation is typically used within a @Configuration class, which signifies that the class's primary purpose is to define bean definitions. @Component auto-detects your beans, @Bean explicitly 
declares them.For third-party library classes or when you need custom instantiation logic
@ComponentScan(basePackages={"com.alchemist","edu.scaler"})-->It is the process of identifying spring bean classes available in project based on base packages name
-->Example name
package com.alchemist;------->Always keep Appconfig.java in base package rather than config package
@Configuration
@ComponentScan(basePackages = "com.alchemist")
public class AppConfig {

}

-eager loading-->IOC container creates object immediately from singleton beans
-lazy loading-->For Prototype ban when you create object then only object created

Autowiring with Spring Annotation(@Autowired)-->
@Autowired can be used at 3 places
-Variable level--Field injection
-Constructor level--Constructor injection
-Setter Mehtod level--Setter Injection

--Autowiring byName
-@Service
 public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

-@Repository("reportDAO")    //to do autowiring by name
 public class OracleDBReportDAO implements ReportDAO {

--Using @Qualifier
@Repository("mysqlDBDAO")
public class MysqlDBDAO implements ReportDAO {

@Repository("oracleDBDAO")
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    @Qualifier("oracleDBDAO")
    private ReportDAO reportDAO;

--Using @Primary
@Repository("oracleDBDAO")
@Primary
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

--Autowiring with Setter

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public void setReportDAO(@Qualifier("oracleDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

    public void generateReport() {
        System.out.println("ReportService - Generating Report");
        reportDAO.getData();
        System.out.println("ReportService - Report Generated");
    }

}
Note: also we can use @Primary

--Autowiring with Constructor

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public ReportService(@Qualifier("mysqlDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

Note: If we remove @Autowired here, still DI will happens as ReportService is Spring bean,i.e IOC should create object for ReportService when you have only one parameterized constructor in class @Autowired is optional. Wnen you have 2 constructors, DI will not happen withoult @Autowired
If we have one no param constructor and one Param constructor, then by default it will call 0-param constructor and DI will not happen

Spring bean life-Cycle
----------------------
init(),getData,destroy()
Bean life-Cycle methods can be executed in 3 ways
-Declarative approach(Xml file to configure)
    <!--Add attribute init-method and destroy-mehtod for Bean Lifecycle-->
    <bean id="dao" class="com.alchemist.UserDAO"
    init-method="init"
    destroy-method="destroy"
    />
	
-Programmatic approach(By using Interface)

public class UserDAO implements InitializingBean,DisposableBean{
	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

-Annotation approach
@Component
public class UserDAO{
	
	@PostConstruct
	public void init() {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	@PreDestroy
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

Main Class for all approaches
package com.alchemist;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class Application {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");---->XML Approach
		ApplicationContext context=new AnnotationConfigApplicationContext(AppConfig.class);----> annotation approach
		UserDAO dao = context.getBean(UserDAO.class);
		dao.getData();
		/*If we add this much code-->destroy() will not be executed, as in in main method no code to 
		 * to execute-->JVM shutdown i.e main method terminated--->IOC container have not got chance 
		 * to remove the object. so in order to see execution of destroy() add following code */
		ConfigurableApplicationContext ctxt = (ConfigurableApplicationContext)context;
		ctxt.close();

	}

}

@DependsOn:-->Wnen one bean dependent on another bean, we specify that DependsOn. (also this can be used in XML also)
We can specify single or multiple beans
@DependsOn("dao") 
@DependsOn(value={"dao","service"})

Ex-->Class A and Class B, Class B should fetch data from db and store into redis, then Class A will fetch data from redis. It will increase performance.
so here Class A dependent on Class B
In some cases, for creating object scanning happens according to alphabetical order--->Causes isssue

@Component("userDao") //writing the name of the bean
public class UserDao implements InitializingBean,DisposableBean{

@Service
@DependsOn("userDao")
public class UserService {
	public UserService() {
		System.out.println("Getting data from Redis...");
	}
----------------------------------------Spring Core Completed----------------------------------------------------------------------------------------------
Project Lombok-->Project Lombok is a Java library that helps you reduce boilerplate code,
i.e., the repetitive stuff like getters, setters, constructors, toString(), and equals() methods â€” by generating them automatically during compilation.
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.38</version>
</dependency>

| Annotation                 | Purpose                                                                                      |
| -------------------------- | -------------------------------------------------------------------------------------------- |
| `@Getter` / `@Setter`      | Creates getters and setters                                                                  |
| `@ToString`                | Generates `toString()`                                                                       |
| `@EqualsAndHashCode`       | Generates `equals()` and `hashCode()`                                                        |
| `@NoArgsConstructor`       | Generates a no-argument constructor                                                          |
| `@AllArgsConstructor`      | Generates a constructor with all fields                                                      |
| `@RequiredArgsConstructor` | Generates a constructor for final fields                                                     |
| `@Data`                    | Combines `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor` |
| `@Builder`                 | Enables the **Builder pattern**                                                              |
| `@Value`                   | Creates an **immutable class** (like `final` + all fields `private final`)                   |
| `@Slf4j`                   | Adds a logger instance automatically (`log.info("message")`)                                 |
-----------------------------------------------------------------------------------------------------------------------------

Spring Boot--->It is the Extension for Spring Framework
It is one approach, to develop Spring Based application with less configuration-->Develops Standalone, Web and Distributed i.e Microservices
Spring Boot = Spring - XML configuration + Auto Configuration + Embedded Servers + Actuator
We have following advantages-->
-Starter POM-->Simplifies Maven/Graddle build configuaration
It contains web-starter,datajpa-starter,Security-starter and mail-starter
--Auto Configuration--->Whatever common configuaration required for Spring boot will be taken care by Spring boot
e.g-->Creating db connection pool,Deploy Web Application in embeded server, Start IOC container, Component Scanning etc

Note: As Spring Boot executes from main(), war or jar doesn't matters

pom.xml------------>Add the following dependency
        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

@Service
public class ReportService {
	
	public ReportService() {
		/*
		 * this class is added to showcase that object is created by IOC when @Service
		 * annotation is added on the top of the class
		 */
		System.out.println("Report Service :: Constructor");
	}

}

--@SpringBootApplication--->@SpringBootConfiguration(-->@Configuration) + @EnableAutoConfiguration(-->AppConfig.java need not to write) + @ComponentScan

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

[32m :: Spring Boot :: [39m             [2m (v3.4.10)[0;39m

[2m2025-10-12T22:01:40.746+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m Starting Application using Java 17.0.16 with PID 9772 (D:\Projects\Spring-Boot-Projects\13-SB-first-App\target\classes started by Admin in D:\Projects\Spring-Boot-Projects\13-SB-first-App)
[2m2025-10-12T22:01:40.749+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m No active profile set, falling back to 1 default profile: "default"
[2m2025-10-12T22:01:41.406+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat initialized with port 8080 (http)
[2m2025-10-12T22:01:41.419+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.apache.catalina.core.StandardService  [0;39m [2m:[0;39m Starting service [Tomcat]
[2m2025-10-12T22:01:41.419+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.apache.catalina.core.StandardEngine   [0;39m [2m:[0;39m Starting Servlet engine: [Apache Tomcat/10.1.46]
[2m2025-10-12T22:01:41.452+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.a.c.c.C.[Tomcat].[localhost].[/]      [0;39m [2m:[0;39m Initializing Spring embedded WebApplicationContext
[2m2025-10-12T22:01:41.453+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mw.s.c.ServletWebServerApplicationContext[0;39m [2m:[0;39m Root WebApplicationContext: initialization completed in 657 ms
Report Service :: Constructor
[2m2025-10-12T22:01:41.738+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mr$InitializeUserDetailsManagerConfigurer[0;39m [2m:[0;39m Global AuthenticationManager configured with UserDetailsService bean with name inMemoryUserDetailsManager
[2m2025-10-12T22:01:41.855+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat started on port 8080 (http) with context path '/'
[2m2025-10-12T22:01:41.864+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m Started Application in 1.469 seconds (process running for 1.852)

Here in the console we can see IOC container started autoconfiguration,
Tomcat Started,Component scanning done by default,Security provided automatically

Spring Boot Actuator:---->It is a built-in module that exposes a set of production-ready endpoints (called Actuator Endpoints) to let you:
-Monitor application health
-Check configurations and environment properties
-View metrics (CPU, memory, threads, requests, etc.)
-Manage log levels at runtime
-View application beans and mappings
-Integrate with monitoring tools like Prometheus, Grafana, New Relic, etc.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

Default Endpoint-->http://localhost:8080/actuator
Common Endpoints
| Endpoint             | Description                                               |
| -------------------- | --------------------------------------------------------- |
| `/actuator/health`   | Shows application health (e.g., "UP" or "DOWN").          |
| `/actuator/info`     | Displays custom app info (version, name, etc.).           |
| `/actuator/metrics`  | Shows performance metrics like memory, CPU, GC, etc.      |
| `/actuator/beans`    | Lists all Spring Beans loaded in the context.             |
| `/actuator/env`      | Shows environment variables and configuration properties. |
| `/actuator/mappings` | Displays all HTTP mappings (useful for debugging).        |
| `/actuator/loggers`  | View and change log levels at runtime.                    |

---->application.properties
# Expose all endpoints
management.endpoints.web.exposure.include=*

# Change base path (optional)
management.endpoints.web.base-path=/manage

# Custom info endpoint data
info.app.name=PayrollApp
info.app.version=1.0.0
info.app.owner=Rohit Lavate

ğŸ§© Use Case Example
In a real app (like your payroll or compliance system at Morningstar ğŸ‘”):
-/actuator/health â†’ used by a load balancer to check if service is alive
-/actuator/metrics/jvm.memory.used â†’ used by Grafana to monitor memory
-/actuator/loggers â†’ allows changing log level without restarting app

--Embedded servers
Apache Tomcat, Jetty, and Netty
| Feature             | Tomcat              | Jetty                         | Netty                          |
| ------------------- | ------------------- | ----------------------------- | ------------------------------ |
| Type                | Servlet container   | Servlet container             | NIO framework                  |
| Spring Boot default | âœ… Yes               | âŒ No                          | âŒ No                           |
| Performance         | Good                | Very good                     | Excellent                      |
| Concurrency         | Medium              | High                          | Very high                      |
| Blocking model      | Blocking            | Async (supports non-blocking) | Fully non-blocking             |
| Footprint           | Moderate            | Small                         | Small                          |
| Reactive support    | âŒ                   | Partial                       | âœ… Full                         |
| Ideal for           | REST APIs, web apps | Microservices                 | Reactive, event-driven systems |

Class containing main() called as Start/Execution class/Main Class of spring boot.
Entry point for Spring boot application is run()-->It is static method(ClassName.methodName() to call).Starts IOC Container, IOC container object is return type of this method(i.e ConfigurableApplicationContext),
and also perform Component scanning
  ConfigurableApplicationContext context = SpringApplication.run(Application.class,args);
  Car c = context.getBean(Car.class);
 
--ConfigurableApplicationContext is an interface,it will provide implementation class of that class hold into variable
@SpringBootApplication
@RestController
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext context=SpringApplication.run(Application.class, args);---->Contains logic to start the IOC
		System.out.println(context.getClass().getName());
	}
}
--When we use 'web-starter'(i.e web-apps + REST API) in pom.xml----->AnnotationConfig'ServletWebServer'ApplicationContext class will be used to create object for IOC container
--For StandAlone application i.e boot-starter--->AnnotationConfigApplicationContext
--For Reactive Applications ie starter-webflux---->AnnotationConfig'ReactiveWebServer;ApplicationContext class
--If pom.xml contains--> web-starter + webflux-->Priority given to web-starter i.e among 3 web-starter gets priority

SpringBoot Banner-->3 modes as following
--Console(default)-->prints on the console
--log-->Prints on the log file
--off-->don't print banner

create a file-->src/main/resources/banner.txt
  ____             _             _       
 / ___| _ __  _ __(_)_ __  _   _| |_ ___ 
 \___ \| '_ \| '__| | '_ \| | | | __/ _ \
  ___) | |_) | |  | | | | | |_| | ||  __/
 |____/| .__/|_|  |_|_| |_|\__,_|\__\___|
       |_|        ${spring-boot.version}

Application: ${spring.application.name}------>You can use Spring placeholders:
Profile: ${spring.profiles.active}

--application.properties
spring.main.banner-mode=off--->To disable the banner
spring.main.banner-mode=log---->Setting to log file

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApplication.class);
        app.setBannerMode(Banner.Mode.OFF);
        app.run(args);
    }
}

-Dynamic custom Banner via Java Class
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApp.class);
        app.setBanner(new Banner() {
            @Override
            public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
                out.println("ğŸŒ¼ Custom Dynamic Banner ğŸŒ¼");
                out.println("Active Profile: " + environment.getActiveProfiles()[0]);
            }
        });
        app.run(args);
    }
}

-->Internals of SpringApplication.run() step by step â€” 

âš™ï¸ 1ï¸âƒ£ Entry Point
SpringApplication.run(MyApp.class, args);

youâ€™re actually calling a 'static helper' method that does this:

public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
    return new SpringApplication(primarySource).run(args);
}


So there are two main phases:
new SpringApplication(primarySource) â†’ sets up the Spring Boot launcher.
.run(args) â†’ starts the full lifecycle.

âš™ï¸ 2ï¸âƒ£ Phase 1: new SpringApplication()
This constructor prepares metadata about your application.
Key internals:
Detects Application type:
SERVLET â†’ for web apps using Tomcat/Jetty.
REACTIVE â†’ for WebFlux.
NONE â†’ for CLI apps.

Registers ApplicationContext class to use (like AnnotationConfigServletWebServerApplicationContext).
Loads SpringApplicationRunListeners â†’ these are â€œlistenersâ€ that react to lifecycle events (e.g., starting, environmentPrepared, etc.).
Initializes the main class (from the one having @SpringBootApplication).

âš™ï¸ 3ï¸âƒ£ Phase 2: run(args)
Hereâ€™s the internal flow simplified (core sequence):
ğŸ”¹ Step 1: prepareEnvironment()
Creates or loads the Spring Environment (ConfigurableEnvironment)
Reads all property sources:
application.properties / application.yml
System environment variables
Command-line arguments
Applies profiles and merges configurations.

ğŸ”¹ Step 2: printBanner()
Loads and prints the banner.txt (if spring.main.banner-mode â‰  off).
Uses BannerPrinter internally.

ğŸ”¹ Step 3: createApplicationContext()
Creates an ApplicationContext instance based on app type:
For web apps â†’ AnnotationConfigServletWebServerApplicationContext.
For reactive â†’ AnnotationConfigReactiveWebServerApplicationContext.
For non-web â†’ AnnotationConfigApplicationContext.

ğŸ”¹ Step 4: prepareContext()
Loads ApplicationContextInitializers (custom setup before beans load).
Sets up environment in the context.
Publishes an event: ApplicationContextInitializedEvent.

ğŸ”¹ Step 5: refreshContext()
This is the heart of Spring â€” triggers the entire bean creation lifecycle:
Scans packages (@ComponentScan)
Registers beans (@Bean, @Configuration, @Component)
Resolves dependency injection
Applies AOP proxies
Triggers @PostConstruct
Publishes ContextRefreshedEvent
Essentially, this is where IoC container starts and your app beans become live.

ğŸ”¹ Step 6: afterRefresh()
Starts embedded web servers (Tomcat, Jetty, etc.) if itâ€™s a web app.
Calls any ApplicationRunner or CommandLineRunner beans.

ğŸ”¹ Step 7: runListeners.finished() and Context ready
Fires final events like ApplicationReadyEvent.
Returns a fully initialized ConfigurableApplicationContext.

ğŸ§  Summary (in Simple Terms)

Hereâ€™s the flow as a quick visual:

SpringApplication.run()
â”‚
â”œâ”€â”€ Create SpringApplication object
â”œâ”€â”€ Prepare Environment
â”œâ”€â”€ Print Banner
â”œâ”€â”€ Create ApplicationContext
â”œâ”€â”€ Prepare Context
â”œâ”€â”€ Refresh Context (Bean creation)
â”œâ”€â”€ Run CommandLineRunner / ApplicationRunner
â””â”€â”€ Application is READY âœ…

ğŸ§© Bonus: Key Interfaces Inside run()
| Component                                 | Purpose                                                    |
| ----------------------------------------- | ---------------------------------------------------------- |
| `SpringApplicationRunListener`            | Gets lifecycle events (startup, environmentPrepared, etc.) |
| `ApplicationContextInitializer`           | Customizes the context before beans load                   |
| `ApplicationRunner` / `CommandLineRunner` | Runs after app startup                                     |
| `SmartLifecycle`                          | Manages start/stop hooks                                   |

----->Spring Boot Startup Call Tree
SpringApplication.run(MyApp.class, args)
â”‚
â”œâ”€> SpringApplication.<init>(primarySource)
â”‚   â”œâ”€ Detect application type (SERVLET / REACTIVE / NONE)
â”‚   â”œâ”€ Set ApplicationContext class
â”‚   â””â”€ Load SpringApplicationRunListeners
â”‚
â”œâ”€> SpringApplication.run(args)
â”‚   â”œâ”€ getRunListeners(args)
â”‚   â”‚   â””â”€ Instantiate listeners from META-INF/spring.factories
â”‚   â”‚
â”‚   â”œâ”€ listeners.starting()
â”‚   â”‚   â””â”€ ApplicationStartingEvent
â”‚   â”‚
â”‚   â”œâ”€ prepareEnvironment(listeners, args)
â”‚   â”‚   â”œâ”€ Create ConfigurableEnvironment (StandardEnvironment / WebEnvironment)
â”‚   â”‚   â”œâ”€ Load property sources:
â”‚   â”‚   â”‚    â”œâ”€ application.properties / .yml
â”‚   â”‚   â”‚    â”œâ”€ System env variables
â”‚   â”‚   â”‚    â””â”€ Command-line args
â”‚   â”‚   â”œâ”€ Apply profiles
â”‚   â”‚   â””â”€ listeners.environmentPrepared(environment)
â”‚   â”‚
â”‚   â”œâ”€ printBanner(environment)
â”‚   â”‚   â””â”€ BannerPrinter.print(environment, sourceClass)
â”‚   â”‚
â”‚   â”œâ”€ createApplicationContext()
â”‚   â”‚   â”œâ”€ AnnotationConfigServletWebServerApplicationContext (Web)
â”‚   â”‚   â”œâ”€ AnnotationConfigReactiveWebServerApplicationContext (Reactive)
â”‚   â”‚   â””â”€ AnnotationConfigApplicationContext (Non-web)
â”‚   â”‚
â”‚   â”œâ”€ prepareContext(context, environment, listeners)
â”‚   â”‚   â”œâ”€ context.setEnvironment(environment)
â”‚   â”‚   â”œâ”€ context.setId(...)
â”‚   â”‚   â”œâ”€ Apply ApplicationContextInitializers
â”‚   â”‚   â””â”€ listeners.contextPrepared(context)
â”‚   â”‚
â”‚   â”œâ”€ refreshContext(context)
â”‚   â”‚   â””â”€ AbstractApplicationContext.refresh()
â”‚   â”‚       â”œâ”€ prepareBeanFactory()
â”‚   â”‚       â”œâ”€ postProcessBeanFactory()
â”‚   â”‚       â”œâ”€ invokeBeanFactoryPostProcessors()
â”‚   â”‚       â”œâ”€ registerBeanPostProcessors()
â”‚   â”‚       â”œâ”€ initMessageSource()
â”‚   â”‚       â”œâ”€ initApplicationEventMulticaster()
â”‚   â”‚       â”œâ”€ onRefresh() (hook for subclasses)
â”‚   â”‚       â”œâ”€ registerListeners()
â”‚   â”‚       â”œâ”€ finishBeanFactoryInitialization()
â”‚   â”‚       â”‚    â”œâ”€ Instantiate singleton beans
â”‚   â”‚       â”‚    â”œâ”€ Resolve DI
â”‚   â”‚       â”‚    â”œâ”€ Apply @PostConstruct
â”‚   â”‚       â”‚    â””â”€ Apply AOP proxies
â”‚   â”‚       â””â”€ finishRefresh()
â”‚   â”‚            â””â”€ Publish ContextRefreshedEvent
â”‚   â”‚
â”‚   â”œâ”€ afterRefresh(context, args)
â”‚   â”‚   â”œâ”€ Start embedded web server (if Web app)
â”‚   â”‚   â”œâ”€ Run ApplicationRunner beans
â”‚   â”‚   â””â”€ Run CommandLineRunner beans
â”‚   â”‚
â”‚   â””â”€ listeners.finished(context, null)
â”‚       â””â”€ Publish ApplicationReadyEvent


