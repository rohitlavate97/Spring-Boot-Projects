Servers used for configuaration in Microservices development with Spring boot
-Service Registry
-Admin Server
-API Gateway

Development flow:
-From backend to UI
-API Gatewway acts as a mediator between FrontEnd and BackEnd

-Spring Core provides IOC and DI, to develop classes with loosely coupling
-Use Interface to provide common methods(increases readability)
Dependency Injection: Injecting dependent object into target object using target class variable/setter/constructor
-Different Types of Injection
--Constructor Injection
--Setter Injection
--Field Injection

What if we perform both constructor Injection and Setter Injection-->First construction injection will happen. then, it will
initialize the variable then setter injection will happen and it will reinitialize the same variable so final value be setter injection value
Note: Setter injection will override construction injection

In Spring, IOC is responsible for Dependency Injection
IOC manages and collaborate object(i.e Creating and injecting object). IOC is a principle which is used to manage and collaborate dependencies among the objects in the application
For IOC container, we need to provide Java Classes as input as it don't know which is target class. Along with Java classes we have to provide configuration(through Xml or annotartions)
IOC will load classes and then create object and will perform DI(i.e it provides spring beans-->Class which is managed by IOC)

Ways to Start the IOC
-BeanFactory(Outdated)
-ApplicationContext(interface)

Class managed by IOC is called as Spring Bean

ApplicationContext ctx = new ClassPathXmlApplicationContext(String xmlFilePath);


Beans.xml-----> should be created in src/main/java
-----------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
    <bean id="credit" class="com.alchemist.beans.CreditCardPayment"/>
    <bean id="debit" class="com.alchemist.beans.DebitCardPayment"/>
    <bean id="payment" class="com.alchemist.beans.PaymentService">
    <!-- to avoid Nullpointer exception as PaymentService don't have by default constructor-->
       <!--constructor-arg name="payment" ref="debit"/-->----------------This is the constructor injection
       <!--constructor-arg name="payment" ref="credit"/-->
       <property name="iPayment" ref="credit"/>--------------------------- this is how settter injection done, property name should be interface referece variable
     </bean>
</beans>
-----------------------------------------------------------------------------
Note: 'ref' attribute represents which object should be injected
-Field injection is only possible with Annotations

Spring Bean Scope-->Decides how many objects should be crated for spring bean class
-Singleton(Default)--> Every Spring Bean is Singleton, whenever we start IOC container, by default it will create objects for singlton bens and when we call getBean()(everytime it checks scope when we call this method) then it will create object for others(for memory management)
-Prototype--->Every time new object will be created
-Request
-Session
Note: Request and Session scopes are used in Spring web MVC

Syntax:
    <bean id="car" class="com.alchemist.beans.CarService" scope="prototype">
       <constructor-arg name="car" ref="petrol"/>
     </bean>

Manual Wiring--> injecting dependent object into target objects with 'ref' attribute is Manual Wiring
Autowiring-->To identify objects and injecting into the Target objects
works on below modes
-byName--->for setter injection--->based on bean id of bean matching with interface variable
-byType--->for setter injection--->based on type of variable, dependent bean will be identified(bean id doesn't matter)
-Constructor
-none

Syntax:
--byName--->identity dependent based on variable name matching with bean id
<bean id="car" class="com.alchemist.beans.CarService" autowire="byName">
--When we write 'autowire' attribute in the bean definition, that bean will be considered as Target Class

--byType--->identity dependent bean based on variable type
  autowire-candidate="false"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" autowire-candidate="false"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">
     </bean>
  primary="true"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" primary="true"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <!--bean id="car" class="com.alchemist.beans.CarService" autowire="byName"-->
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">

--constructor--->First it will check byName, then goes for byType, we can use primary="true" for any bean which we want to inject
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="constructor">
     </bean>

Spring Annotations: Annotations are used to provide metadata
---------------------------------------------------------------------------
@Configuration:->Instead of XML, java class can be marked as Configuration
@Component,@Service,@Repository-->To represent java class as spring bean class
@Scope-->To represent scope of the bean
@Qualifier-->When multiple beans of same type, it is used to identity bean based on the given name for DI
@Autowired:-->used to enable auto-wiring in a class
@Primary-->To give priority for the bean for auto-wiring
@Bean:-->The @Bean annotation in Spring Boot is used to declare a method that produces a bean to be managed by the Spring IoC (Inversion of Control) container. This annotation is typically used within a @Configuration class, which signifies that the class's primary purpose is to define bean definitions. @Component auto-detects your beans, @Bean explicitly 
declares them.For third-party library classes or when you need custom instantiation logic
@ComponentScan(basePackages={"com.alchemist","edu.scaler"})-->It is the process of identifying spring bean classes available in project based on base packages name
-->Example name
package com.alchemist;------->Always keep Appconfig.java in base package rather than config package
@Configuration
@ComponentScan(basePackages = "com.alchemist")
public class AppConfig {

}

-eager loading-->IOC container creates object immediately from singleton beans
-lazy loading-->For Prototype ban when you create object then only object created

Autowiring with Spring Annotation(@Autowired)-->
@Autowired can be used at 3 places
-Variable level--Field injection
-Constructor level--Constructor injection
-Setter Mehtod level--Setter Injection

--Autowiring byName
-@Service
 public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

-@Repository("reportDAO")    //to do autowiring by name
 public class OracleDBReportDAO implements ReportDAO {

--Using @Qualifier
@Repository("mysqlDBDAO")
public class MysqlDBDAO implements ReportDAO {

@Repository("oracleDBDAO")
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    @Qualifier("oracleDBDAO")
    private ReportDAO reportDAO;

--Using @Primary
@Repository("oracleDBDAO")
@Primary
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

--Autowiring with Setter

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public void setReportDAO(@Qualifier("oracleDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

    public void generateReport() {
        System.out.println("ReportService - Generating Report");
        reportDAO.getData();
        System.out.println("ReportService - Report Generated");
    }

}
Note: also we can use @Primary

--Autowiring with Constructor

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public ReportService(@Qualifier("mysqlDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

Note: If we remove @Autowired here, still DI will happens as ReportService is Spring bean,i.e IOC should create object for ReportService when you have only one parameterized constructor in class @Autowired is optional. Wnen you have 2 constructors, DI will not happen withoult @Autowired
If we have one no param constructor and one Param constructor, then by default it will call 0-param constructor and DI will not happen

Spring bean life-Cycle
----------------------
init(),getData,destroy()
Bean life-Cycle methods can be executed in 3 ways
-Declarative approach(Xml file to configure)
    <!--Add attribute init-method and destroy-mehtod for Bean Lifecycle-->
    <bean id="dao" class="com.alchemist.UserDAO"
    init-method="init"
    destroy-method="destroy"
    />
	
-Programmatic approach(By using Interface)

public class UserDAO implements InitializingBean,DisposableBean{
	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

-Annotation approach
@Component
public class UserDAO{
	
	@PostConstruct
	public void init() {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	@PreDestroy
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

Main Class for all approaches
package com.alchemist;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class Application {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");---->XML Approach
		ApplicationContext context=new AnnotationConfigApplicationContext(AppConfig.class);----> annotation approach
		UserDAO dao = context.getBean(UserDAO.class);
		dao.getData();
		/*If we add this much code-->destroy() will not be executed, as in in main method no code to 
		 * to execute-->JVM shutdown i.e main method terminated--->IOC container have not got chance 
		 * to remove the object. so in order to see execution of destroy() add following code */
		ConfigurableApplicationContext ctxt = (ConfigurableApplicationContext)context;
		ctxt.close();

	}

}
