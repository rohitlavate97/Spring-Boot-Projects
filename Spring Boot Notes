Servers used for configuaration in Microservices development with Spring boot
-Service Registry
-Admin Server
-API Gateway

Development flow:
-From backend to UI
-API Gatewway acts as a mediator between FrontEnd and BackEnd

-Spring Core provides IOC and DI, to develop classes with loosely coupling
-Use Interface to provide common methods(increases readability)
Dependency Injection: Injecting dependent object into target object using target class variable/setter/constructor
-Different Types of Injection
--Constructor Injection
--Setter Injection
--Field Injection

What if we perform both constructor Injection and Setter Injection-->First construction injection will happen. then, it will
initialize the variable then setter injection will happen and it will reinitialize the same variable so final value be setter injection value
Note: Setter injection will override construction injection

In Spring, IOC is responsible for Dependency Injection
IOC manages and collaborate object(i.e Creating and injecting object). IOC is a principle which is used to manage and collaborate dependencies among the objects in the application
For IOC container, we need to provide Java Classes as input as it don't know which is target class. Along with Java classes we have to provide configuration(through Xml or annotartions)
IOC will load classes and then create object and will perform DI(i.e it provides spring beans-->Class which is managed by IOC)

Ways to Start the IOC
-BeanFactory(Outdated)
-ApplicationContext(interface)

Class managed by IOC is called as Spring Bean

ApplicationContext ctx = new ClassPathXmlApplicationContext(String xmlFilePath);


Beans.xml-----> should be created in src/main/java
-----------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
    <bean id="credit" class="com.alchemist.beans.CreditCardPayment"/>
    <bean id="debit" class="com.alchemist.beans.DebitCardPayment"/>
    <bean id="payment" class="com.alchemist.beans.PaymentService">
    <!-- to avoid Nullpointer exception as PaymentService don't have by default constructor-->
       <!--constructor-arg name="payment" ref="debit"/-->----------------This is the constructor injection
       <!--constructor-arg name="payment" ref="credit"/-->
       <property name="iPayment" ref="credit"/>--------------------------- this is how settter injection done, property name should be interface referece variable
     </bean>
</beans>
-----------------------------------------------------------------------------
Note: 'ref' attribute represents which object should be injected
-Field injection is only possible with Annotations

Spring Bean Scope-->Decides how many objects should be crated for spring bean class
-Singleton(Default)--> Every Spring Bean is Singleton, whenever we start IOC container, by default it will create objects for singlton bens and when we call getBean()(everytime it checks scope when we call this method) then it will create object for others(for memory management)
-Prototype--->Every time new object will be created
-Request
-Session
Note: Request and Session scopes are used in Spring web MVC

Syntax:
    <bean id="car" class="com.alchemist.beans.CarService" scope="prototype">
       <constructor-arg name="car" ref="petrol"/>
     </bean>

Manual Wiring--> injecting dependent object into target objects with 'ref' attribute is Manual Wiring
Autowiring-->To identify objects and injecting into the Target objects
works on below modes
-byName--->for setter injection--->based on bean id of bean matching with interface variable
-byType--->for setter injection--->based on type of variable, dependent bean will be identified(bean id doesn't matter)
-Constructor
-none

Syntax:
--byName--->identity dependent based on variable name matching with bean id
<bean id="car" class="com.alchemist.beans.CarService" autowire="byName">
--When we write 'autowire' attribute in the bean definition, that bean will be considered as Target Class

--byType--->identity dependent bean based on variable type
  autowire-candidate="false"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" autowire-candidate="false"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">
     </bean>
  primary="true"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" primary="true"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <!--bean id="car" class="com.alchemist.beans.CarService" autowire="byName"-->
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">

--constructor--->First it will check byName, then goes for byType, we can use primary="true" for any bean which we want to inject
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="constructor">
     </bean>

Spring Annotations: Annotations are used to provide metadata
---------------------------------------------------------------------------
@Configuration:->Instead of XML, java class can be marked as Configuration
@Component,@Service,@Repository-->To represent java class as spring bean class
@Scope-->To represent scope of the bean
@Qualifier-->When multiple beans of same type, it is used to identity bean based on the given name for DI
@Autowired:-->used to enable auto-wiring in a class
@Primary-->To give priority for the bean for auto-wiring
@Bean:-->The @Bean annotation in Spring Boot is used to declare a method that produces a bean to be managed by the Spring IoC (Inversion of Control) container. This annotation is typically used within a @Configuration class, which signifies that the class's primary purpose is to define bean definitions. @Component auto-detects your beans, @Bean explicitly 
declares them.For third-party library classes or when you need custom instantiation logic
@ComponentScan(basePackages={"com.alchemist","edu.scaler"})-->It is the process of identifying spring bean classes available in project based on base packages name
Note:--Class that communicates with db is called Persistence Class/DAO Class. Whatever Exception getting from DB i.e SQLException will be truncated into our java side
--Classes which are utility like sending mail. generateReport are represented by @Component
--interfaces which has business logic get implementation class @Service annotation

-->Example name
package com.alchemist;------->Always keep Appconfig.java in base package rather than config package
@Configuration
@ComponentScan(basePackages = "com.alchemist")
public class AppConfig {

}

-eager loading-->IOC container creates object immediately from singleton beans
-lazy loading-->For Prototype ban when you create object then only object created

Autowiring with Spring Annotation(@Autowired)-->
@Autowired can be used at 3 places
-Variable level--Field injection
-Constructor level--Constructor injection
-Setter Mehtod level--Setter Injection

--Autowiring byName
-@Service
 public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

-@Repository("reportDAO")    //to do autowiring by name
 public class OracleDBReportDAO implements ReportDAO {

--Using @Qualifier
@Repository("mysqlDBDAO")
public class MysqlDBDAO implements ReportDAO {

@Repository("oracleDBDAO")
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    @Qualifier("oracleDBDAO")
    private ReportDAO reportDAO;

--Using @Primary
@Repository("oracleDBDAO")
@Primary
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

--Autowiring with Setter

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public void setReportDAO(@Qualifier("oracleDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

    public void generateReport() {
        System.out.println("ReportService - Generating Report");
        reportDAO.getData();
        System.out.println("ReportService - Report Generated");
    }

}
Note: also we can use @Primary

--Autowiring with Constructor

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public ReportService(@Qualifier("mysqlDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

Note: If we remove @Autowired here, still DI will happens as ReportService is Spring bean,i.e IOC should create object for ReportService when you have only one parameterized constructor in class @Autowired is optional. Wnen you have 2 constructors, DI will not happen withoult @Autowired
If we have one no param constructor and one Param constructor, then by default it will call 0-param constructor and DI will not happen

Spring bean life-Cycle
----------------------
init(),getData,destroy()
Bean life-Cycle methods can be executed in 3 ways
-Declarative approach(Xml file to configure)
    <!--Add attribute init-method and destroy-mehtod for Bean Lifecycle-->
    <bean id="dao" class="com.alchemist.UserDAO"
    init-method="init"
    destroy-method="destroy"
    />
	
-Programmatic approach(By using Interface)

public class UserDAO implements InitializingBean,DisposableBean{
	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

-Annotation approach
@Component
public class UserDAO{
	
	@PostConstruct
	public void init() {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	@PreDestroy
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

Main Class for all approaches
package com.alchemist;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class Application {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");---->XML Approach
		ApplicationContext context=new AnnotationConfigApplicationContext(AppConfig.class);----> annotation approach
		UserDAO dao = context.getBean(UserDAO.class);
		dao.getData();
		/*If we add this much code-->destroy() will not be executed, as in in main method no code to 
		 * to execute-->JVM shutdown i.e main method terminated--->IOC container have not got chance 
		 * to remove the object. so in order to see execution of destroy() add following code */
		ConfigurableApplicationContext ctxt = (ConfigurableApplicationContext)context;
		ctxt.close();

	}

}

@DependsOn:-->Wnen one bean dependent on another bean, we specify that DependsOn. (also this can be used in XML also)
We can specify single or multiple beans
@DependsOn("dao") 
@DependsOn(value={"dao","service"})

Ex-->Class A and Class B, Class B should fetch data from db and store into redis, then Class A will fetch data from redis. It will increase performance.
so here Class A dependent on Class B
In some cases, for creating object scanning happens according to alphabetical order--->Causes isssue

@Component("userDao") //writing the name of the bean
public class UserDao implements InitializingBean,DisposableBean{

@Service
@DependsOn("userDao")
public class UserService {
	public UserService() {
		System.out.println("Getting data from Redis...");
	}
----------------------------------------Spring Core Completed----------------------------------------------------------------------------------------------
Project Lombok-->Project Lombok is a Java library that helps you reduce boilerplate code,
i.e., the repetitive stuff like getters, setters, constructors, toString(), and equals() methods ‚Äî by generating them automatically during compilation.
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.38</version>
</dependency>

| Annotation                 | Purpose                                                                                      |
| -------------------------- | -------------------------------------------------------------------------------------------- |
| `@Getter` / `@Setter`      | Creates getters and setters                                                                  |
| `@ToString`                | Generates `toString()`                                                                       |
| `@EqualsAndHashCode`       | Generates `equals()` and `hashCode()`                                                        |
| `@NoArgsConstructor`       | Generates a no-argument constructor                                                          |
| `@AllArgsConstructor`      | Generates a constructor with all fields                                                      |
| `@RequiredArgsConstructor` | Generates a constructor for final fields                                                     |
| `@Data`                    | Combines `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor` |
| `@Builder`                 | Enables the **Builder pattern**                                                              |
| `@Value`                   | Creates an **immutable class** (like `final` + all fields `private final`)                   |
| `@Slf4j`                   | Adds a logger instance automatically (`log.info("message")`)                                 |
-----------------------------------------------------------------------------------------------------------------------------

Spring Boot--->It is the Extension for Spring Framework
It is one approach, to develop Spring Based application with less configuration-->Develops Standalone, Web and Distributed i.e Microservices
Spring Boot = Spring - XML configuration + Auto Configuration + Embedded Servers + Actuator
We have following advantages-->
-Starter POM-->Simplifies Maven/Graddle build configuaration
It contains web-starter,datajpa-starter,Security-starter and mail-starter
--Auto Configuration--->Whatever common configuaration required for Spring boot will be taken care by Spring boot
e.g-->Creating db connection pool,Deploy Web Application in embeded server, Start IOC container, Component Scanning etc

Note: As Spring Boot executes from main(), war or jar doesn't matters

pom.xml------------>Add the following dependency
        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

@Service
public class ReportService {
	
	public ReportService() {
		/*
		 * this class is added to showcase that object is created by IOC when @Service
		 * annotation is added on the top of the class
		 */
		System.out.println("Report Service :: Constructor");
	}

}

--@SpringBootApplication--->@SpringBootConfiguration(-->@Configuration) + @EnableAutoConfiguration(-->AppConfig.java need not to write) + @ComponentScan

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

[32m :: Spring Boot :: [39m             [2m (v3.4.10)[0;39m

[2m2025-10-12T22:01:40.746+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m Starting Application using Java 17.0.16 with PID 9772 (D:\Projects\Spring-Boot-Projects\13-SB-first-App\target\classes started by Admin in D:\Projects\Spring-Boot-Projects\13-SB-first-App)
[2m2025-10-12T22:01:40.749+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m No active profile set, falling back to 1 default profile: "default"
[2m2025-10-12T22:01:41.406+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat initialized with port 8080 (http)
[2m2025-10-12T22:01:41.419+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.apache.catalina.core.StandardService  [0;39m [2m:[0;39m Starting service [Tomcat]
[2m2025-10-12T22:01:41.419+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.apache.catalina.core.StandardEngine   [0;39m [2m:[0;39m Starting Servlet engine: [Apache Tomcat/10.1.46]
[2m2025-10-12T22:01:41.452+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.a.c.c.C.[Tomcat].[localhost].[/]      [0;39m [2m:[0;39m Initializing Spring embedded WebApplicationContext
[2m2025-10-12T22:01:41.453+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mw.s.c.ServletWebServerApplicationContext[0;39m [2m:[0;39m Root WebApplicationContext: initialization completed in 657 ms
Report Service :: Constructor
[2m2025-10-12T22:01:41.738+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mr$InitializeUserDetailsManagerConfigurer[0;39m [2m:[0;39m Global AuthenticationManager configured with UserDetailsService bean with name inMemoryUserDetailsManager
[2m2025-10-12T22:01:41.855+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat started on port 8080 (http) with context path '/'
[2m2025-10-12T22:01:41.864+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m Started Application in 1.469 seconds (process running for 1.852)

Here in the console we can see IOC container started autoconfiguration,
Tomcat Started,Component scanning done by default,Security provided automatically

Spring Boot Actuator:---->It is a built-in module that exposes a set of production-ready endpoints (called Actuator Endpoints) to let you:
-Monitor application health
-Check configurations and environment properties
-View metrics (CPU, memory, threads, requests, etc.)
-Manage log levels at runtime
-View application beans and mappings
-Integrate with monitoring tools like Prometheus, Grafana, New Relic, etc.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

Default Endpoint-->http://localhost:8080/actuator
Common Endpoints
| Endpoint             | Description                                               |
| -------------------- | --------------------------------------------------------- |
| `/actuator/health`   | Shows application health (e.g., "UP" or "DOWN").          |
| `/actuator/info`     | Displays custom app info (version, name, etc.).           |
| `/actuator/metrics`  | Shows performance metrics like memory, CPU, GC, etc.      |
| `/actuator/beans`    | Lists all Spring Beans loaded in the context.             |
| `/actuator/env`      | Shows environment variables and configuration properties. |
| `/actuator/mappings` | Displays all HTTP mappings (useful for debugging).        |
| `/actuator/loggers`  | View and change log levels at runtime.                    |

---->application.properties
# Expose all endpoints
management.endpoints.web.exposure.include=*

# Change base path (optional)
management.endpoints.web.base-path=/manage

# Custom info endpoint data
info.app.name=PayrollApp
info.app.version=1.0.0
info.app.owner=Rohit Lavate

üß© Use Case Example
In a real app (like your payroll or compliance system at Morningstar üëî):
-/actuator/health ‚Üí used by a load balancer to check if service is alive
-/actuator/metrics/jvm.memory.used ‚Üí used by Grafana to monitor memory
-/actuator/loggers ‚Üí allows changing log level without restarting app

--Embedded servers
Apache Tomcat, Jetty, and Netty
| Feature             | Tomcat              | Jetty                         | Netty                          |
| ------------------- | ------------------- | ----------------------------- | ------------------------------ |
| Type                | Servlet container   | Servlet container             | NIO framework                  |
| Spring Boot default | ‚úÖ Yes               | ‚ùå No                          | ‚ùå No                           |
| Performance         | Good                | Very good                     | Excellent                      |
| Concurrency         | Medium              | High                          | Very high                      |
| Blocking model      | Blocking            | Async (supports non-blocking) | Fully non-blocking             |
| Footprint           | Moderate            | Small                         | Small                          |
| Reactive support    | ‚ùå                   | Partial                       | ‚úÖ Full                         |
| Ideal for           | REST APIs, web apps | Microservices                 | Reactive, event-driven systems |

Class containing main() called as Start/Execution class/Main Class of spring boot.
Entry point for Spring boot application is run()-->It is static method(ClassName.methodName() to call).Starts IOC Container, IOC container object is return type of this method(i.e ConfigurableApplicationContext),
and also perform Component scanning
  ConfigurableApplicationContext context = SpringApplication.run(Application.class,args);
  Car c = context.getBean(Car.class);
 
--ConfigurableApplicationContext is an interface,it will provide implementation class of that class hold into variable
@SpringBootApplication
@RestController
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext context=SpringApplication.run(Application.class, args);---->Contains logic to start the IOC
		System.out.println(context.getClass().getName());
	}
}
--When we use 'web-starter'(i.e web-apps + REST API) in pom.xml----->AnnotationConfig'ServletWebServer'ApplicationContext class will be used to create object for IOC container
--For StandAlone application i.e boot-starter--->AnnotationConfigApplicationContext
--For Reactive Applications ie starter-webflux---->AnnotationConfig'ReactiveWebServer;ApplicationContext class
--If pom.xml contains--> web-starter + webflux-->Priority given to web-starter i.e among 3 web-starter gets priority

SpringBoot Banner-->3 modes as following
--Console(default)-->prints on the console
--log-->Prints on the log file
--off-->don't print banner

create a file-->src/main/resources/banner.txt
  ____             _             _       
 / ___| _ __  _ __(_)_ __  _   _| |_ ___ 
 \___ \| '_ \| '__| | '_ \| | | | __/ _ \
  ___) | |_) | |  | | | | | |_| | ||  __/
 |____/| .__/|_|  |_|_| |_|\__,_|\__\___|
       |_|        ${spring-boot.version}

Application: ${spring.application.name}------>You can use Spring placeholders:
Profile: ${spring.profiles.active}

--application.properties
spring.main.banner-mode=off--->To disable the banner
spring.main.banner-mode=log---->Setting to log file

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApplication.class);
        app.setBannerMode(Banner.Mode.OFF);
        app.run(args);
    }
}

-Dynamic custom Banner via Java Class
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApp.class);
        app.setBanner(new Banner() {
            @Override
            public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
                out.println("üåº Custom Dynamic Banner üåº");
                out.println("Active Profile: " + environment.getActiveProfiles()[0]);
            }
        });
        app.run(args);
    }
}

-->Internals of SpringApplication.run() step by step ‚Äî 

‚öôÔ∏è 1Ô∏è‚É£ Entry Point
SpringApplication.run(MyApp.class, args);

you‚Äôre actually calling a 'static helper' method that does this:

public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
    return new SpringApplication(primarySource).run(args);
}


So there are two main phases:
new SpringApplication(primarySource) ‚Üí sets up the Spring Boot launcher.
.run(args) ‚Üí starts the full lifecycle.

‚öôÔ∏è 2Ô∏è‚É£ Phase 1: new SpringApplication()
This constructor prepares metadata about your application.
Key internals:
Detects Application type:
SERVLET ‚Üí for web apps using Tomcat/Jetty.
REACTIVE ‚Üí for WebFlux.
NONE ‚Üí for CLI apps.

Registers ApplicationContext class to use (like AnnotationConfigServletWebServerApplicationContext).
Loads SpringApplicationRunListeners ‚Üí these are ‚Äúlisteners‚Äù that react to lifecycle events (e.g., starting, environmentPrepared, etc.).
Initializes the main class (from the one having @SpringBootApplication).

‚öôÔ∏è 3Ô∏è‚É£ Phase 2: run(args)
Here‚Äôs the internal flow simplified (core sequence):
üîπ Step 1: prepareEnvironment()
Creates or loads the Spring Environment (ConfigurableEnvironment)
Reads all property sources:
application.properties / application.yml
System environment variables
Command-line arguments
Applies profiles and merges configurations.

üîπ Step 2: printBanner()
Loads and prints the banner.txt (if spring.main.banner-mode ‚â† off).
Uses BannerPrinter internally.

üîπ Step 3: createApplicationContext()
Creates an ApplicationContext instance based on app type:
For web apps ‚Üí AnnotationConfigServletWebServerApplicationContext.
For reactive ‚Üí AnnotationConfigReactiveWebServerApplicationContext.
For non-web ‚Üí AnnotationConfigApplicationContext.

üîπ Step 4: prepareContext()
Loads ApplicationContextInitializers (custom setup before beans load).
Sets up environment in the context.
Publishes an event: ApplicationContextInitializedEvent.

üîπ Step 5: refreshContext()
This is the heart of Spring ‚Äî triggers the entire bean creation lifecycle:
Scans packages (@ComponentScan)
Registers beans (@Bean, @Configuration, @Component)
Resolves dependency injection
Applies AOP proxies
Triggers @PostConstruct
Publishes ContextRefreshedEvent
Essentially, this is where IoC container starts and your app beans become live.

üîπ Step 6: afterRefresh()
Starts embedded web servers (Tomcat, Jetty, etc.) if it‚Äôs a web app.
Calls any ApplicationRunner or CommandLineRunner beans.

üîπ Step 7: runListeners.finished() and Context ready
Fires final events like ApplicationReadyEvent.
Returns a fully initialized ConfigurableApplicationContext.

üß† Summary (in Simple Terms)

Here‚Äôs the flow as a quick visual:

SpringApplication.run()
‚îÇ
‚îú‚îÄ‚îÄ Create SpringApplication object
‚îú‚îÄ‚îÄ Prepare Environment
‚îú‚îÄ‚îÄ Print Banner
‚îú‚îÄ‚îÄ Create ApplicationContext
‚îú‚îÄ‚îÄ Prepare Context
‚îú‚îÄ‚îÄ Refresh Context (Bean creation)
‚îú‚îÄ‚îÄ Run CommandLineRunner / ApplicationRunner
‚îî‚îÄ‚îÄ Application is READY ‚úÖ

üß© Bonus: Key Interfaces Inside run()
| Component                                 | Purpose                                                    |
| ----------------------------------------- | ---------------------------------------------------------- |
| `SpringApplicationRunListener`            | Gets lifecycle events (startup, environmentPrepared, etc.) |
| `ApplicationContextInitializer`           | Customizes the context before beans load                   |
| `ApplicationRunner` / `CommandLineRunner` | Runs after app startup                                     |
| `SmartLifecycle`                          | Manages start/stop hooks                                   |

----->Spring Boot Startup Call Tree
SpringApplication.run(MyApp.class, args)
‚îÇ
‚îú‚îÄ> SpringApplication.<init>(primarySource)
‚îÇ   ‚îú‚îÄ Detect application type (SERVLET / REACTIVE / NONE)
‚îÇ   ‚îú‚îÄ Set ApplicationContext class
‚îÇ   ‚îî‚îÄ Load SpringApplicationRunListeners
‚îÇ
‚îú‚îÄ> SpringApplication.run(args)
‚îÇ   ‚îú‚îÄ getRunListeners(args)
‚îÇ   ‚îÇ   ‚îî‚îÄ Instantiate listeners from META-INF/spring.factories
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ listeners.starting()
‚îÇ   ‚îÇ   ‚îî‚îÄ ApplicationStartingEvent
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ prepareEnvironment(listeners, args)
‚îÇ   ‚îÇ   ‚îú‚îÄ Create ConfigurableEnvironment (StandardEnvironment / WebEnvironment)
‚îÇ   ‚îÇ   ‚îú‚îÄ Load property sources:
‚îÇ   ‚îÇ   ‚îÇ    ‚îú‚îÄ application.properties / .yml
‚îÇ   ‚îÇ   ‚îÇ    ‚îú‚îÄ System env variables
‚îÇ   ‚îÇ   ‚îÇ    ‚îî‚îÄ Command-line args
‚îÇ   ‚îÇ   ‚îú‚îÄ Apply profiles
‚îÇ   ‚îÇ   ‚îî‚îÄ listeners.environmentPrepared(environment)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ printBanner(environment)
‚îÇ   ‚îÇ   ‚îî‚îÄ BannerPrinter.print(environment, sourceClass)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ createApplicationContext()
‚îÇ   ‚îÇ   ‚îú‚îÄ AnnotationConfigServletWebServerApplicationContext (Web)
‚îÇ   ‚îÇ   ‚îú‚îÄ AnnotationConfigReactiveWebServerApplicationContext (Reactive)
‚îÇ   ‚îÇ   ‚îî‚îÄ AnnotationConfigApplicationContext (Non-web)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ prepareContext(context, environment, listeners)
‚îÇ   ‚îÇ   ‚îú‚îÄ context.setEnvironment(environment)
‚îÇ   ‚îÇ   ‚îú‚îÄ context.setId(...)
‚îÇ   ‚îÇ   ‚îú‚îÄ Apply ApplicationContextInitializers
‚îÇ   ‚îÇ   ‚îî‚îÄ listeners.contextPrepared(context)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ refreshContext(context)
‚îÇ   ‚îÇ   ‚îî‚îÄ AbstractApplicationContext.refresh()
‚îÇ   ‚îÇ       ‚îú‚îÄ prepareBeanFactory()
‚îÇ   ‚îÇ       ‚îú‚îÄ postProcessBeanFactory()
‚îÇ   ‚îÇ       ‚îú‚îÄ invokeBeanFactoryPostProcessors()
‚îÇ   ‚îÇ       ‚îú‚îÄ registerBeanPostProcessors()
‚îÇ   ‚îÇ       ‚îú‚îÄ initMessageSource()
‚îÇ   ‚îÇ       ‚îú‚îÄ initApplicationEventMulticaster()
‚îÇ   ‚îÇ       ‚îú‚îÄ onRefresh() (hook for subclasses)
‚îÇ   ‚îÇ       ‚îú‚îÄ registerListeners()
‚îÇ   ‚îÇ       ‚îú‚îÄ finishBeanFactoryInitialization()
‚îÇ   ‚îÇ       ‚îÇ    ‚îú‚îÄ Instantiate singleton beans
‚îÇ   ‚îÇ       ‚îÇ    ‚îú‚îÄ Resolve DI
‚îÇ   ‚îÇ       ‚îÇ    ‚îú‚îÄ Apply @PostConstruct
‚îÇ   ‚îÇ       ‚îÇ    ‚îî‚îÄ Apply AOP proxies
‚îÇ   ‚îÇ       ‚îî‚îÄ finishRefresh()
‚îÇ   ‚îÇ            ‚îî‚îÄ Publish ContextRefreshedEvent
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ afterRefresh(context, args)
‚îÇ   ‚îÇ   ‚îú‚îÄ Start embedded web server (if Web app)
‚îÇ   ‚îÇ   ‚îú‚îÄ Run ApplicationRunner beans
‚îÇ   ‚îÇ   ‚îî‚îÄ Run CommandLineRunner beans
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ listeners.finished(context, null)
‚îÇ       ‚îî‚îÄ Publish ApplicationReadyEvent

Spring Boot Runners:--->
They are special interfaces that allow you to execute code once the application context is fully loaded 
but before the application starts accepting requests. They're perfect for initialization tasks, data setup, or validation checks.
Ex;-->In db their is static data, to get that data one time only when we start application is starting and save in the app.
UseCases-->Load Static table data when application starts, Delete data from staging tables(i.e Temporary table), Send notification regarding application startup
Two runners in the spring boot-->
--ApplicationRunner---->run()
--CommandLineRunner---->run()
Note: Both are functional interface, only one abstract method is available i.e run()
Key Point: Runners execute after the application context is fully refreshed but before the application is marked as fully ready (before ApplicationReadyEvent).
Spring Boot Startup:
‚îú‚îÄ‚îÄ Context Refresh (Bean creation, Dependency Injection)
‚îú‚îÄ‚îÄ Web Server Starts
‚îú‚îÄ‚îÄ ApplicationStartedEvent Published
‚îú‚îÄ‚îÄ üèÉ Runners Execute (in @Order sequence)
‚îÇ   ‚îú‚îÄ‚îÄ CommandLineRunner @Order(1)
‚îÇ   ‚îú‚îÄ‚îÄ ApplicationRunner @Order(2)
‚îÇ   ‚îî‚îÄ‚îÄ Other runners...
‚îî‚îÄ‚îÄ ApplicationReadyEvent Published (App is READY!)

@Component
public class MyApplicationRunner implements ApplicationRunner{

	@Override
	public void run(ApplicationArguments args) throws Exception {
		// TODO Auto-generated method stub
		System.out.println("ApplicationRunner run().. method");
	}

}

spring-boot-autoconfigure-x.x.x.jar---->
It contains all the pre-written configuration classes that Spring Boot uses to automatically set up:
-Data sources (JDBC, JPA, MongoDB)
-Web servers (Tomcat, Jetty, Undertow)
-Spring MVC
-Security
-Actuator
-Mail, Kafka, Redis, Quartz, etc.

META-INF/spring-factories---->Contains initializers and listeners
In the run()-->createBootStrapContext() and getRunListeners(args)-->From factories file they load classes available, they will create object and they
will call methods. These classes load configuration required for our application
SpringApplication.run()
        ‚îÇ
        ‚îú‚îÄ‚îÄ createBootstrapContext()
        ‚îÇ      ‚îî‚îÄ‚îÄ DefaultBootstrapContext created
        ‚îÇ      ‚îî‚îÄ‚îÄ Initializers registered (for logging, env)
        ‚îÇ
        ‚îú‚îÄ‚îÄ getRunListeners(args)
        ‚îÇ      ‚îî‚îÄ‚îÄ Load EventPublishingRunListener
        ‚îÇ      ‚îî‚îÄ‚îÄ Prepare lifecycle event handlers
        ‚îÇ
        ‚îú‚îÄ‚îÄ listeners.starting()
        ‚îÇ      ‚îî‚îÄ‚îÄ Fire ApplicationStartingEvent
        ‚îÇ
        ‚îú‚îÄ‚îÄ prepareEnvironment()
        ‚îÇ      ‚îî‚îÄ‚îÄ Load application.properties / YAML
        ‚îÇ
        ‚îú‚îÄ‚îÄ createApplicationContext()
        ‚îÇ      ‚îî‚îÄ‚îÄ Instantiate main ApplicationContext
        ‚îÇ
        ‚îú‚îÄ‚îÄ refreshContext()
        ‚îÇ      ‚îî‚îÄ‚îÄ Load all beans
        ‚îÇ
        ‚îî‚îÄ‚îÄ callRunners()
               ‚îî‚îÄ‚îÄ Execute CommandLineRunner / ApplicationRunner
public ConfigurableApplicationContext run(String... args) {
    long startTime = System.nanoTime();

    // 1Ô∏è‚É£ Create initial context
    DefaultBootstrapContext bootstrapContext = createBootstrapContext();

    ConfigurableApplicationContext context = null;
    configureHeadlessProperty();

    // 2Ô∏è‚É£ Create listeners for startup events
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting(bootstrapContext, this.mainApplicationClass);

    try {
        // 3Ô∏è‚É£ Prepare environment
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);

        // 4Ô∏è‚É£ Create and refresh ApplicationContext
        context = createApplicationContext();
        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments);
        refreshContext(context);

        // 5Ô∏è‚É£ Call CommandLineRunners / ApplicationRunners
        afterRefresh(context, applicationArguments);
        listeners.started(context);
        callRunners(context, applicationArguments);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, listeners);
    }

    listeners.ready(context);
    return context;
}

Spring Data JPA--->used to develop Persistence layer logic, Simplifies CRUD operations implemenations in project
--Java JDBC,Spring JDBC, Hibernate Framework,Spring ORM, Spring Data JPA-->Ways to develop persistence logic
--In Spring Data JPA, we need to write 0 methods to perform CRUD operations, uses Hibernate framework internally.(If performance is crucial for application,
then directly go with JDBC as it will execute query directly on db)
Java App--->Spring Data JPA(Hibrenate ORM-->JDBC)-->DB
--If you want everything in object format, then go with Hibernate framework/Spring Data JPA
Note: If we have 5000 DB tables then, we have to create 5000 DAO classes. Every dao class should contains 4 common methods so it will become 20000 methods 
with same logic(This is not recommended--->To avoid boilerplate code we use Spring Data JPA)
--In Spring Data JPA-->DAO is called as Repository, and it provided Repository interfaces as follows
CrudRepository(CRUD operations method)
JpaRepository(CRUD operations method + Pagination + Sorting + QBE)
--data-jpa-starter
Driver will be loaded
Connection will be created
SessionFactory will be created
Transaction will be happening

Repository (I)
   ‚Üë
   ‚îî‚îÄ‚îÄ CrudRepository (I)        --> (12 methods)
           ‚Üë
           ‚îî‚îÄ‚îÄ PagingAndSortingRepository (I)
                   ‚Üë
                   ‚îî‚îÄ‚îÄ JpaRepository (I)
                           ‚Üë
                           ‚îî‚îÄ‚îÄ QueryByExampleExecutor (I)

JpaRepository is grandchild of CrudRepository
| Interface                      | Extends From                                       | Purpose                                                                               |
| ------------------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Repository**                 | ‚Äî                                                  | Marker interface (root of Spring Data hierarchy).                                     |
| **CrudRepository**             | Repository                                         | Provides CRUD operations like `save()`, `findById()`, `delete()`, etc. (‚âà12 methods). |
| **PagingAndSortingRepository** | CrudRepository                                     | Adds pagination and sorting support (`findAll(Pageable)`, `findAll(Sort)`).           |
| **JpaRepository**              | PagingAndSortingRepository, QueryByExampleExecutor | Adds JPA-specific methods like `flush()`, `saveAndFlush()`, and batch operations.     |
| **QueryByExampleExecutor**     | ‚Äî                                                  | Provides methods for Query by Example (QBE) functionality.                            |
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--CrudRepository 
| Method                  | Signature                                                 | Description                                                   | Example                               |
| :---------------------- | :-------------------------------------------------------- | :------------------------------------------------------------ | :------------------------------------ |
| **save**                | `<S extends T> S save(S entity)`                          | Saves a single entity. Inserts if new, updates if ID exists.  | `repo.save(emp);`                     |
| **saveAll**             | `<S extends T> Iterable<S> saveAll(Iterable<S> entities)` | Saves all entities in batch. Inserts new, updates existing.   | `repo.saveAll(listOfEmployees);`      |
| **findById**            | `Optional<T> findById(ID id)`                             | Retrieves entity by ID. Returns `Optional` to avoid nulls.    | `repo.findById(1L);`                  |
| **existsById**          | `boolean existsById(ID id)`                               | Checks if an entity with the given ID exists.                 | `repo.existsById(5L);`                |
| **findAll**             | `Iterable<T> findAll()`                                   | Retrieves all entities in the repository.                     | `repo.findAll();`                     |
| **findAllById**         | `Iterable<T> findAllById(Iterable<ID> ids)`               | Retrieves all entities for the given IDs.                     | `repo.findAllById(List.of(1L,2L));`   |
| **count**               | `long count()`                                            | Returns the total number of entities in the repository.       | `repo.count();`                       |
| **deleteById**          | `void deleteById(ID id)`                                  | Deletes the entity with the given ID.                         | `repo.deleteById(3L);`                |
| **delete**              | `void delete(T entity)`                                   | Deletes the given entity.                                     | `repo.delete(emp);`                   |
| **deleteAllById**       | `void deleteAllById(Iterable<? extends ID> ids)`          | Deletes all entities for the given IDs.                       | `repo.deleteAllById(List.of(1L,2L));` |
| **deleteAll(entities)** | `void deleteAll(Iterable<? extends T> entities)`          | Deletes all given entities in batch.                          | `repo.deleteAll(listOfEmployees);`    |
| **deleteAll()**         | `void deleteAll()`                                        | Deletes **all entities** in the repository. Use with caution. | `repo.deleteAll();`                   |

üîπ Notes:
save():If entity ID is null or not in DB ‚Üí insert.(First Select Query then insert query)-->Polymorphic method
If entity ID exists in DB ‚Üí update.
findById() returns Optional<T> ‚Üí helps avoid NullPointerException.
findAll() and count() ‚Üí useful for pagination & reporting.
Deletion methods are safe, but deleteAll() removes everything ‚Äî be careful.
While executing findAll()-->It executing select query
                            Retrieving records in form of ResultSet
							Moving Cursor of ResultSet
							Taking each row from ResultSet and setting it to Entity Object
							Adding Entity object to Collection and Returning
							
Requirement:-->Retrieve books whose price>=200-->Non Primary key columns
Solution--> findBy methods
        --> Custom Quries
		
findBy methods	
| Method                         | Generated SQL      | Description               |
| :----------------------------- | :----------------- | :------------------------ |
| `findByName(String name)`      | `WHERE name = ?`   | Finds all with exact name |
| `findByRole(String role)`      | `WHERE role = ?`   | Finds by role             |
| `findById(Long id)`            | `WHERE id = ?`     | Finds by ID               |
| `findBySalary(Double salary)`  | `WHERE salary = ?` | Finds by salary           |
| `findByActive(boolean active)` | `WHERE active = ?` | Finds by boolean column   |
----------------------------------------------------------------------------------
| Interface                      | Extends From                                       | Purpose                                                                               |
| ------------------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Repository**                 | ‚Äî                                                  | Marker interface (root of Spring Data hierarchy).                                     |
| **CrudRepository**             | Repository                                         | Provides CRUD operations like `save()`, `findById()`, `delete()`, etc. (‚âà12 methods). |
| **PagingAndSortingRepository** | CrudRepository                                     | Adds pagination and sorting support (`findAll(Pageable)`, `findAll(Sort)`).           |
| **JpaRepository**              | PagingAndSortingRepository, QueryByExampleExecutor | Adds JPA-specific methods like `flush()`, `saveAndFlush()`, and batch operations.     |
| **QueryByExampleExecutor**     | ‚Äî                                                  | Provides methods for Query by Example (QBE) functionality.                            |
--findBy methods are used to perfrom only select operations
--Using non primary key columns we can select records
--In findBy methods, method name is very important-->based on method name JPA will construct the query for execution
Note:findBy method should represent Entity class variables

Custom Queries--> If we want to execute our own query, we can write in 2 ways-->@Query annotation
-HQL Queries(Hibernate Query Language)--->Independent of db i.e can't execute on db directly
-Native SQL Queries(Ex--> select * from book)
Note:-->We can write custom query to update and delete,but not insert(direct insert not supported). Insert from one table to other table is supported.
| Type            | Annotation                      | Description                         | Example                                              |
| --------------- | ------------------------------- | ----------------------------------- | ---------------------------------------------------- |
| Derived Query   | ‚Äî                               | Auto-generated based on method name | `findByName(String name)`                            |
| JPQL Query      | `@Query`                        | Uses entity and field names         | `@Query("SELECT e FROM Employee e WHERE e.id=:id")`  |
| Native Query    | `@Query(..., nativeQuery=true)` | Uses table and column names         | `@Query("SELECT * FROM employee", nativeQuery=true)` |
| Modifying Query | `@Modifying` + `@Transactional` | For UPDATE/DELETE/INSERT            | `@Query("DELETE FROM Employee e WHERE e.id=:id")`    |
| Named Query     | `@NamedQuery`                   | Predefined query inside Entity      | Defined in entity, used in repo                      |
| Projection      | `@Query` with interface         | Select specific columns only        | `SELECT e.name, e.salary`                            |
| Dynamic Query   | SpEL + `@Query`                 | Evaluate expressions at runtime     | `:#{#param}`                                         |
| Joins           | `@Query`                        | For relational fetching             | `JOIN e.department d`                                |
--------------------------------------------------------------------------------------------------------------------------------------------------
--HQL vs SQL
| **Feature**                      | **HQL (Hibernate Query Language)**                    | **SQL (Structured Query Language)**                      |
| -------------------------------- | ----------------------------------------------------- | -------------------------------------------------------- |
| **Full Form**                    | Hibernate Query Language                              | Structured Query Language                                |
| **Works On**                     | Java **entities and their properties**                | **Database tables and columns**                          |
| **Abstraction Level**            | Object-oriented (ORM layer)                           | Relational (Database layer)                              |
| **Language Type**                | Object-based query language                           | Database query language                                  |
| **Dependency on Database**       | Independent (portable across databases)               | Dependent (vendor-specific syntax may vary)              |
| **Return Type**                  | Entity objects or projections                         | ResultSet (raw database rows)                            |
| **Mapping**                      | Automatically mapped to entity classes                | Manual mapping needed (unless ORM used)                  |
| **Case Sensitivity**             | Entity names and field names are case-sensitive       | Table/column names depend on DB vendor                   |
| **Joins**                        | Uses entity relationships (e.g., `JOIN e.department`) | Uses explicit joins (e.g., `JOIN department ON ...`)     |
| **Data Retrieval**               | Returns persistent objects                            | Returns raw data (rows and columns)                      |
| **Query Example**                | `FROM Employee e WHERE e.salary > 50000`              | `SELECT * FROM employee WHERE salary > 50000`            |
| **Updates & Deletes**            | Supported (`UPDATE`, `DELETE`) but on entities        | Fully supported (`UPDATE`, `DELETE`) on tables           |
| **Aggregations**                 | Supported (`COUNT`, `SUM`, etc.)                      | Supported (`COUNT`, `SUM`, etc.)                         |
| **Named Parameters**             | Supported (`:paramName`)                              | Positional parameters (`?`) mostly used                  |
| **Automatic Conversion**         | Yes ‚Äî Hibernate converts HQL to SQL internally        | No ‚Äî SQL executes as written                             |
| **Portability**                  | High ‚Äî works with any DB supported by Hibernate       | Low ‚Äî syntax may differ across DBs                       |
| **Performance Tuning**           | Controlled by Hibernate                               | Controlled by database directly                          |
| **Use Case**                     | Ideal for standard CRUD, entity-based queries         | Ideal for complex, DB-specific queries and optimizations |
| **Supports Native DB Functions** | Limited                                               | Fully supported                                          |
| **Relationship Navigation**      | Easy (uses mapped associations)                       | Manual joins required                                    |
| **Ease of Use**                  | Easier and cleaner for ORM-based apps                 | Requires SQL and schema knowledge                        |
| **Example in Hibernate**         | `session.createQuery("FROM Employee").list();`        | `session.createNativeQuery("SELECT * FROM employee");`   |

--When to use
| **Scenario**                                       | **Recommended Query Type** |
| -------------------------------------------------- | -------------------------- |
| CRUD operations using entities                     | HQL                        |
| Complex joins using entity relationships           | HQL                        |
| Vendor-specific SQL functions or stored procedures | SQL                        |
| Reporting and analytics queries                    | SQL                        |
| Cross-database portability required                | HQL                        |
| Heavy performance tuning or DB optimizations       | SQL                        |


public interface BookRepository extends CrudRepository<Book, Integer> {
	
	public List<Book> findByBookPriceGreaterThan(Double price);
	
	//nateive query
	@Query(value="select * from book", nativeQuery=true)
	public List<Book> getAllBooks();
	
	//HQL Query
	@Query("from Book")
	public List<Book> getBooks();

}
-Dialect class converts HQL queries to SQL Queries i.e maintenance wise HQL queries are good-->Every DB have it's own dialect class
Ex:==OracleDialect,MySQLDialect,DB2Dialect,PostgresDialect etc...
Note: Dialect class will be loaded along with DB driver class
1000 HQL Queries--->MysQL dialect-->MysQLDB
1000 HQL Queries--->Oracle dialect-->OracleDB
i.e we can change db effortlessely.
Example
=======
select * from book(Table in db)==========from Book(Entity Class)
select * from book where book_price=200(book_price is column name)====from book where bookPrice=200(here bookPrice is variable)
selct book_name from book=====select bookName form Book
| **Term**       | **Meaning**                                  | **Affects**       | **SQL Clause** | **Example**                         |
| -------------- | -------------------------------------------- | ----------------- | -------------- | ----------------------------------- |
| **Selection**  | Filters specific **rows** based on condition | Number of rows    | `WHERE`        | `SELECT * FROM emp WHERE dept='HR'` |
| **Projection** | Selects specific **columns** from a table    | Number of columns | `SELECT`       | `SELECT name, salary FROM emp`      |

--JpaRepository:-->
| **Aspect**                    | **Description / Example**                                                                                                                                                                                                                                                                                                                   |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**                | `JpaRepository` is an interface in Spring Data JPA that provides **CRUD operations + JPA-specific methods**. It extends `PagingAndSortingRepository` and CrudRepository`.                                                                                                                                                                  |
| **Basic Syntax**              | `java<br>@Repository<br>public interface BookRepository extends JpaRepository<Book, Integer> { }<br>`<br>Book = entity class, Integer = primary key type                                                                                                                                                                                    |
| **Built-in Methods**          | `save(entity)`, `findById(id)`, `findAll()`, `delete(entity)`, `count()`, `existsById(id)`                                                                                                                                                                                                                                                  |
| **Derived Query Methods**     | Spring generates queries from method names:<br>`List<Book> findByBookName(String name);`<br>`List<Book> findByBookPriceGreaterThan(Double price);`<br>`List<Book> findByBookNameContaining(String keyword);`                                                                                                                                |
| **Custom Queries (`@Query`)** | JPQL: <br>`java<br>@Query("SELECT b FROM Book b WHERE b.bookPrice > :price")<br>List<Book> findExpensiveBooks(@Param("price") Double price);<br>`<br>Native SQL: <br>`java<br>@Query(value = "SELECT * FROM book WHERE book_price > :price", nativeQuery = true)<br>List<Book> findExpensiveBooksNative(@Param("price") Double price);<br>` |
| **Paging & Sorting**          | Inherited from `PagingAndSortingRepository`:<br>`Page<Book> findAll(Pageable pageable);`<br>`List<Book> findAll(Sort sort);`<br>Example:<br>`Pageable pageable = PageRequest.of(0, 5, Sort.by("bookPrice").descending());`<br>`Page<Book> page = bookRepository.findAll(pageable);`                                                         |
| **Key Interfaces**            | `CrudRepository` ‚Üí basic CRUD<br>`PagingAndSortingRepository` ‚Üí pagination & sorting<br>`JpaRepository` ‚Üí JPA-specific methods + all above                                                                                                                                                                                                  |
| **Advantages**                | ‚úÖ No implementation needed ‚Äî Spring generates it<br>‚úÖ Supports derived queries<br>‚úÖ Supports custom JPQL/native queries<br>‚úÖ Built-in pagination and sorting                                                                                                                                                                                |

Note:
findAll()---->Retrieves all the records
Page<Book> findAll(Pageable pageable)------>Retrieves record with pagination
List<Book> findAll(Sort sort)----->Retrieves records wit sorting

Example.of() lets you build dynamic queries without writing JPQL or method names.
You create a probe (sample entity) with some fields set, and Spring Data JPA finds matching records.

@SpringBootApplication
public class Application {

    private final EmpRepository empRepository;

    Application(EmpRepository empRepository) {
        this.empRepository = empRepository;
    }

	public static void main(String[] args) {
		ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
		EmpRepository empRepo = context.getBean(EmpRepository.class);
		System.out.println("EmpRepository Bean is: " + empRepo.getClass().getName());

		/*
		 * Employee e1 = new Employee();
		 * 
		 * e1.setEmpName("John Doe"); e1.setEmpSalary(50000.0); e1.setEmpGender("Male");
		 * e1.setEmpDept("IT"); empRepo.save(e1);--------------------------------------------->when save() executed ID and create_Date field in the db gets updated
		 * 
		 * e1.setEmpName("Jane Smith"); e1.setEmpSalary(30000.0);
		 * e1.setEmpGender("Female"); e1.setEmpDept("HR");
		 * 
		 * Employee e2 = new Employee(); e2.setEmpName("Alice Johnson");
		 * e2.setEmpSalary(35000.0); e2.setEmpGender("Female"); e2.setEmpDept("HR");
		 * 
		 * Employee e3 = new Employee(); e3.setEmpName("Bob Brown");
		 * e3.setEmpSalary(40000.0); e3.setEmpGender("Male"); e3.setEmpDept("IT");
		 * 
		 * empRepo.saveAll( java.util.List.of(e1, e2, e3) );
		 * System.out.println("Employees saved successfully!");
		 */

		List<Employee> listbySalaryDesc = empRepo.getEmployeeBySalaryDesc();
		listbySalaryDesc.forEach(System.out::println);
		System.out.println("-----------------------------------------------------");
		
		// ascending order by bookName
		Sort sortByNameAsc = Sort.by("empName").ascending();
		//List<Employee> empAsc = empRepo.findAll(Sort.by("empName").ascending());
		List<Employee> empAsc = empRepo.findAll(sortByNameAsc);
		empAsc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//Sort sortByDeptDesc = Sort.by("empDept").descending();
		Sort sortByDeptDesc = Sort.by(Sort.Direction.DESC, "empDept");
		List<Employee> empDeptDesc = empRepo.findAll(sortByDeptDesc);
		empDeptDesc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//sorting based on multiple fields
		//Sort sortByDeptAscAndSalaryDesc = Sort.by("empDept","empSalary").ascending();
		Sort sortByDeptAscAndSalaryDesc = Sort.by("empDept").ascending()
                .and(Sort.by("empSalary").descending());
		List<Employee> empDeptAscAndSalaryDesc = empRepo.findAll(sortByDeptAscAndSalaryDesc);
		empDeptAscAndSalaryDesc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		int pageNumber = 0; // first page
		PageRequest page = PageRequest.of(pageNumber, 2);
		Page<Employee> empPage = empRepo.findAll(page);
		List<Employee> empList = empPage.getContent();
		empList.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		int peNum = 0; // first page
		PageRequest pg = PageRequest.of(peNum, 3, Sort.by("empName").ascending());
		Page<Employee> empPg = empRepo.findAll(pg);
		List<Employee> empLst = empPg.getContent();
		empLst.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//to filter according to the column name--->i.e where clause
		 Employee emp = new Employee();
		 emp.setEmpDept("IT");   // We want to find all employees from IT dept
		 Example<Employee> example = Example.of(emp);
		 List<Employee> result = empRepo.findAll(example);
		 result.forEach(System.out::println);
		 System.out.println("------------------------------------------------------");
		 
		 Employee e =new Employee();
		 e.setEmpDept("HR");
		 e.setEmpGender("Male");
		 Example ex = Example.of(e);
		 List<Employee> res = empRepo.findAll(ex);
		 res.forEach(System.out::println);
		 System.out.println("------------------------------------------------------");
		 
		 ExampleMatcher matcher = ExampleMatcher.matching()
			        .withIgnoreCase("empName")
			        .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);
			Employee e2 = new Employee();
			e2.setEmpName("swapnil"); // will match "Swaobuk", "Swapnila", "Mr. Swapnil" etc.
			Example<Employee> exemp = Example.of(e2, matcher);
			List<Employee> output = empRepo.findAll(exemp);
			output.forEach(System.out::println);
	
	}

}
------------------------------------------------------
	@CreationTimestamp
	@Column(name="date_created",updatable = false)
	private LocalDateTime dateCreated;
	
	@Column(name="last_updated", insertable = false)
	@UpdateTimestamp
	private LocalDateTime lastUpdated;
------------------------------------------------------
--Primary Key constraint is combination of following 2 constraints--->(Without Pk-->IdentifierGenerationException)
Unique
Not Null

Note: User should only enter Non Primary key value, Primary key should be generated by us i.e application. That is when Generator comes into picture

--IdentifierGenerationException occurs when Hibernate fails to generate a primary key (ID) for an entity during the persist() or save() operation.
| **Cause**                              | **Description**                                                                    | **Example**                                                                                  | **Fix / Solution**                                                                                                |
| -------------------------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **1. Missing @GeneratedValue**         | You annotated the ID with `@Id` but didn‚Äôt tell Hibernate *how* to generate it.    | `java @Id private Integer id; `                                                              | Add a generation strategy:<br>`java @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; ` |
| **2. Unsupported Generation Strategy** | The chosen strategy doesn‚Äôt match your DB capabilities.                            | Using `SEQUENCE` in MySQL (which doesn‚Äôt support sequences).                                 | Use `IDENTITY` for MySQL.<br>Use `SEQUENCE` for Oracle/PostgreSQL.                                                |
| **3. Manually assigned ID not set**    | If you didn‚Äôt use `@GeneratedValue`, Hibernate expects you to set the ID manually. | `java @Id private Integer id;` and not setting `id`.                                         | Either set the ID manually or use `@GeneratedValue`.                                                              |
| **4. Sequence/Table not found**        | The sequence or table used for ID generation doesn‚Äôt exist in the DB.              | `java @SequenceGenerator(name="seq", sequenceName="user_seq")` but `user_seq` doesn‚Äôt exist. | Manually create the sequence in DB, or let Hibernate create it using `spring.jpa.hibernate.ddl-auto=update`.      |
| **5. Wrong column mapping**            | The ID column name doesn‚Äôt match the actual DB column.                             | DB column is `book_id`, but entity says `id`.                                                | Add `@Column(name="book_id")` above your ID field.                                                                |
| **6. Embeddable ID issues**            | When using `@EmbeddedId` or `@IdClass`, Hibernate can‚Äôt determine ID properly.     | Incorrectly mapped composite key.                                                            | Ensure all key fields are properly annotated and present in both ID class and entity.                             |


## üß© JPA Built-in Generation Strategies

| STRATEGY        | DATABASE SUPPORT                     | PERFORMANCE | BATCH INSERT | CODE EXAMPLE                                                                                                          | USE CASES                                   | PROS                              | CONS                             |
|-----------------|--------------------------------------|-------------|---------------|----------------------------------------------------------------------------------------------------------------------|---------------------------------------------|-----------------------------------|----------------------------------|
| **AUTO (Default)** | All databases                      | Varies      | Varies        | `@GeneratedValue(strategy = GenerationType.AUTO)`                                                                    | Database portability, simple projects       | Database agnostic, easy setup     | Unpredictable behavior across DBs |
| **IDENTITY**    | MySQL, SQL Server, PostgreSQL, H2, DB2 | Good        | ‚ùå             | `@GeneratedValue(strategy = GenerationType.IDENTITY)`                                                                | Simple auto-increment fields, small apps    | Simple, widely supported          | No batch inserts, pre-insert select |
| **SEQUENCE**    | Oracle, PostgreSQL, H2, DB2          | Excellent   | ‚úÖ             | ```java                                                                                                              |
|                 |                                      |             |               | @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "seq")                                              |
|                 |                                      |             |               | @SequenceGenerator(name = "seq", sequenceName = "user_seq")                                                         |
|                 |                                      |             |               | ```                                                                                                                 | High-performance enterprise apps            | Best performance, batch supported | Database-specific                 |
| **TABLE**       | All databases                        | Fair        | ‚úÖ             | ```java                                                                                                              |
|                 |                                      |             |               | @GeneratedValue(strategy = GenerationType.TABLE, generator = "tab")                                                 |
|                 |                                      |             |               | @TableGenerator(name = "tab", table = "id_gen")                                                                     |
|                 |                                      |             |               | ```                                                                                                                 | Legacy systems, no sequence support         | Database independent              | Slower, table locking issues      |

Note: For SEQUENCE, the table will be created for storing next_val. and IDNTITY support for AUTO-INCREMENT(in console query contains auto_increment).TABLE maintains seperate table for PK
see console for TABLE-->same way check for other --->3 queries for each operation-->degrades the performance
Hibernate: select tbl.next_val from hibernate_sequences tbl where tbl.sequence_name=? for update
Hibernate: update hibernate_sequences set next_val=?  where next_val=? and sequence_name=?
Hibernate: insert into book (book_name,book_price,book_id) values (?,?,
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Why Use Wrapper Classes Instead of Primitive Types
| **Aspect**          | **Primitive Type (`int`, `long`)**   | **Wrapper Type (`Integer`, `Long`)**   | **Explanation**                                                                                                                               |
| ------------------- | ------------------------------------ | -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| **Default Value**   | Always has a default (e.g. `0`)      | Can be `null`                          | Hibernate uses `null` to detect *new (unsaved)* entities. If ID = 0, Hibernate gets confused and may try to **update** instead of **insert**. |
| **Nullability**     | Cannot be `null`                     | Can be `null`                          | Database columns are often nullable ‚Äî primitives cannot represent null.                                                                       |
| **ID Generation**   | Causes issues with `@GeneratedValue` | Works perfectly with `@GeneratedValue` | Hibernate expects the ID to be `null` before insert, so it can generate one.                                                                  |
| **Optional Values** | Always initialized                   | Can be optional                        | Some business fields may not always have a value at creation time.                                                                            |
| **Boxing/Unboxing** | Not needed                           | Automatic                              | Negligible impact, but safer for ORM frameworks.                                                                                              |

Custom Generator---->We should implement Generator interface which has generate().
eg:-->OD1,OD2,OD3,....--->Prefix(Fixed=OD) + Suffix(Number-->Variable and increment by 1)

public class OrderIdGenerator implements IdentifierGenerator{

	@Override
	public Serializable generate(SharedSessionContractImplementor session, Object object) {
		
		String prefix = "OD";
		String suffix = "";
		try {
			Connection connection = session.getJdbcConnectionAccess().obtainConnection();
			Statement statement = connection.createStatement();
			String query = "SELECT ORDER_ID_SEQ.NEXTVAL as nextval FROM DUAL";
			ResultSet result = statement.executeQuery(query);
			if(result.next()) {
				int seqVal = result.getInt(1);
				suffix = String.valueOf(seqVal);
			}
		}catch (Exception e) {
			e.printStackTrace();
		}
		return prefix + suffix;
	}

}

Composite Primary Key--->
@Data
@Embeddable
public class AccountPK {
	
	private String accNum;
	
	private String accType;

}

@Entity
@Table(name = "account_tbl")
@Data
public class Account {
	
	private String holderName;
	
	private String branch;
	
	@EmbeddedId
	private AccountPK accountPK;

}

public interface AccountRepository extends JpaRepository<Account, AccountPK> {

}

Note:Generators are not applicable for composite primary key. If you have composite primary key, you have to set values manually.
The Class which is representing composite keys should implement Serializable interface(Marker interface-->Used to give special instructions to JVM)

Profiles in Spring Boot-->
Every project will have multiple environments(Platform which used to run our application)-->DEV ENV,STG ENV, SIT ENV, PROD ENV
Environment contains-->Server(Linux VM),DB Server,Log Server etc. Every environment has its own DB and every DB will have seperate configuartion properties(uname,password,url etc)
If we want to deploy our code to multiple environments then we have to change datasource properties in the application.prooperties file-->Chance of mistake
So to avoid mistakes, concept of profile comes in spring boot-->Profiles are used to configure environment specific properties
application.properties contains--->DB Properties,SMTP properties,Kafka properties,Redis properties,REST API endpoint URLs
src/main/resources/
 ‚îú‚îÄ‚îÄ application.properties              # Default (active if no profile set)
 ‚îú‚îÄ‚îÄ application-dev.properties           # For dev
 ‚îú‚îÄ‚îÄ application-test.properties          # For testing
 ‚îî‚îÄ‚îÄ application-prod.properties          # For production
 
--->Spring WebMVC----->simplifies Web Application Development process
 Dependency--->spring-boot-starter-web-->provides support for MVC based web application, RESTFul Services, Embedded container(Tomcat)
 Advantages-->It supports form binding(Form Data binds to Java Object)
              Flexibility in Form Binding(Type conversion-->convert data in particular data type)
			  Multiple presentation technologies(JSP and Thymeleaf)
			  Form tag library(Ready Made tag supports)
			  
MVC Architecture Flow
Client Request ‚Üí DispatcherServlet ‚Üí Controller ‚Üí Service ‚Üí DAO ‚Üí Database
       ‚Üë                                              ‚Üì
Client Response ‚Üê View ‚Üê Model ‚Üê Controller ‚Üê Service ‚Üê

---->Detailed Flow
CLIENT REQUEST
    ‚Üì
DispatcherServlet (Front Controller/Framework Servelet)---->Responsible for performing Pre-Processing and Post-Processing
    ‚Üì
Handler Mapping (Finds appropriate controller)---->As multiple controllers, DispatcherServlet doesn't know which method responsible to handle request, so it will give request to HandlerMapper it will scans url mapping and give that detail back to DispatcherServlet. DispatcherServelet will go to that Controller class and Controller method
    ‚Üì
Controller (Processes request)
    ‚Üì
Service Layer (Business logic)
    ‚Üì
DAO/Repository (Data access)
    ‚Üì
Database
    ‚Üë
Controller ‚Üê Service ‚Üê DAO (Return data)
    ‚Üì
Model (Adds data)
    ‚Üì
View Resolver (Finds view template)
    ‚Üì
View (JSP/Thymeleaf) + Model
    ‚Üì
CLIENT RESPONSE

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                            CLIENT BROWSER                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ HTTP Request (URL, Form Data, Parameters)
                                ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        DispatcherServlet                                ‚îÇ
‚îÇ  (Front Controller - Single entry point for all requests)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚Üì Delegates to appropriate components
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         Handler Mapping                                 ‚îÇ
‚îÇ  (Maps request to appropriate Controller)                               ‚îÇ
‚îÇ  - @RequestMapping, @GetMapping, @PostMapping etc.                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ Returns HandlerExecutionChain
                                ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         Controller                                      ‚îÇ
‚îÇ  (Processes business logic)                                             ‚îÇ
‚îÇ  - @Controller, @RestController                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ Calls Service Layer
                                ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         Service Layer                                   ‚îÇ
‚îÇ  (Business logic implementation)                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ Calls DAO/Repository
                                ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    DAO/Repository Layer                                 ‚îÇ
‚îÇ  (Data access operations)                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ Interacts with Database
                                ‚Üì
                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                          ‚îÇ DATABASE  ‚îÇ
                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚Üë
                                ‚îÇ Returns data
                                ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         Controller                                      ‚îÇ
‚îÇ  (Prepares Model data)                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ Returns ModelAndView or ResponseEntity(Model-->Represents data in key-value format, View-->Logical File Name)
								|(Note -->Controllers are loosely coupled with Presentation technology as Multiple presentation techniques are their-->To identify presentation technology it will talk to view resolver)
								| (ViewResolver identifies where is the view file in the project and what is the view technology(i.e Presentation Technology)
                                ‚Üì
								
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         View Resolver                                   ‚îÇ
‚îÇ  (Resolves view name to actual view template)                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ Returns View object
								| (After Identifying it will give that info to DispatcherServelet, which will send model data to View Component)
                                ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                            View                                         ‚îÇ
‚îÇ  (Renders response using template + model data)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ Rendered HTML/JSON/XML(i.e render model data in the view file and give it to DispatcherServelet)
                                ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        DispatcherServlet                                ‚îÇ
‚îÇ  (Sends response to client)                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ HTTP Response
                                ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                            CLIENT BROWSER                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
-------------------------------------------------------------------------------------
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        CLIENT                               ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ                    HTTP Request  ‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí   ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ                    ‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê‚Üê HTTP Response       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    DispatcherServlet                        ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ          ‚Üó Pre-processing                                   ‚îÇ
‚îÇ          ‚Üñ Post-processing                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ               ‚îÇ               ‚îÇ
          ‚ñº               ‚ñº               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Handler       ‚îÇ ‚îÇ    Controller    ‚îÇ ‚îÇ   View Resolver ‚îÇ
‚îÇ   Mapping       ‚îÇ ‚îÇ                 ‚îÇ ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ               ‚îÇ                       ‚îÇ
          ‚îÇ               ‚îÇ                       ‚îÇ
          ‚ñº               ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  URL to Controller‚îÇ ‚îÇ  Business Logic ‚îÇ ‚îÇ Logical to     ‚îÇ
‚îÇ   Mapping        ‚îÇ ‚îÇ   Processing    ‚îÇ ‚îÇ Physical View  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                          ‚îÇ
                                          ‚îÇ
                                          ‚ñº
                                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                 ‚îÇ      View       ‚îÇ
                                 ‚îÇ  (JSP/HTML/etc) ‚îÇ
                                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
								 
To Create Spring MVC app we need to add following dependencies-->
--spring-boot-starter-web
--spring-boot-devtools
--tomcat-embed-jasper(Only when using JSP as Presentation Technology, but spring supports Thymeleaf)<----Add externally

-Application.java          ‚Üê Main Spring Boot app
-ServletInitializer.java   ‚Üê WAR entry point--->i.e Required for Web Application Execution
configure(): Entry point for servlet container
application.sources(): Specifies the main configuration class

--How ServletInitializer Works
Deployment Flow:
External Tomcat Startup
        ‚Üì
Servlet Container looks for web.xml or ServletInitializer
        ‚Üì
ServletInitializer.configure() method is called
        ‚Üì
Spring Application Context is created
        ‚Üì
Your Spring Boot Application starts
        ‚Üì
Controllers and Services are initialized

--Form Tag Library
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

+---------------------+--------------------------------------+------------------------------------------------------------+
| Tag                 | Description                          | Syntax Example                                             |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:form>         | Main form container, binds to        | <form:form method="POST" modelAttribute="book">            |
|                     | command object                       |                                                            |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:input>        | Text input field                     | <form:input path="bookName"/>                              |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:password>     | Password input field                 | <form:password path="password"/>                            |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:textarea>     | Multi-line text input                | <form:textarea path="description" rows="5"/>                |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:select>       | Dropdown select box                  | <form:select path="category">                              |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:option>       | Single option in select              | <form:option value="FICTION">Fiction</form:option>          |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:options>      | Multiple options from collection     | <form:options items="${categories}"/>                       |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:radiobutton>  | Radio button input                   | <form:radiobutton path="type" value="EBOOK"/>               |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:checkbox>     | Checkbox input                       | <form:checkbox path="features" value="HARDBACK"/>           |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:errors>       | Display validation errors            | <form:errors path="bookName" cssClass="error"/>             |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:hidden>       | Hidden input field                   | <form:hidden path="bookId"/>                                |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:label>        | Form field label                     | <form:label path="bookName">Book Name</form:label>          |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:button>       | Button element                       | <form:button type="submit">Save</form:button>               |
+---------------------+--------------------------------------+------------------------------------------------------------+

modelAttribute--->maps form data to class mapping(Entity class is different)
Path Attribute--->Map fields to class variables

When you first load the page, you don‚Äôt have user input yet. So, you give Spring an empty object ‚Äî like a placeholder ‚Äî for the form to bind to.
@Controller
public class StudentController {
	
	@GetMapping("/")
	public String loadIndexPage(Model model) {
		Student sObj = new Student();
		model.addAttribute("student",sObj);
		return null;
	}

}

For every HTTP request, Spring MVC creates a new Model object.
This is by design for thread safety and request isolation
Static data (like dropdown options) should be reused via constants
Dynamic data (like form objects) should be created fresh each time
HTTP Request ‚Üí DispatcherServlet ‚Üí Controller Method ‚Üí NEW Model ‚Üí Response
      ‚Üì               ‚Üì                   ‚Üì            ‚Üì         ‚Üì
   Request 1       HandlerMapping      @GetMapping   Model 1   Response 1
   Request 2       HandlerMapping      @GetMapping   Model 2   Response 2
   Request 3       HandlerMapping      @GetMapping   Model 3   Response 3
   
Model is map(key-value pair). From first method once, whatever data you passing to model, view will be accessing that data in view page, once view page is 
loaded, that model object will be deleted from container. so we have to set those 3 lines of code in 2nd method. But it is not recommended to write it in 
2 places. so write it in 1 method and call it in two places

@Controller
public class StudentController {
	@Autowired
	private StudentService service;
	
	@GetMapping("/")
	public String loadIndexPage(Model model) {
		init(model);
		return "index";
	}
	
	//@InitBinder-->not working
	@ModelAttribute
	public void init(Model model) {
		model.addAttribute("student",new Student());
		model.addAttribute("courses", service.getCourses());
		model.addAttribute("prefTimings", service.getTimings());
	}
	
	//Endpoint to save student record	
	@PostMapping("/save")
	public String handSubmitBtm(Student s, Model model) {
		boolean isSaved = service.saveStudent(s);
		if(isSaved) {
			model.addAttribute("msg", "Data Saved....");
		}
		init(model);
		return "index";	
	}

}

@Controller
public class ProductController {
	
	@Autowired
	private ProductRepository repo;
	
	@GetMapping("/")
	public String loadForm(Model model) {
		model.addAttribute("p",new ProductEntity());
		return "index";	
	}
	
	@PostMapping("/product")
	public String handleSave(@ModelAttribute("p") ProductEntity p,Model model) {
		p = repo.save(p);
		if(p.getPid()!=null) {
		model.addAttribute("msg","Data Saved....");
		}
		return "index";
	}
}
-----------------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Home Page</title>
	</head>
	<body>
		<h2>Product Info</h2>
		<p><font color="green">${msg}</font></p>
		<form:form action="product" modelAttribute="p" method="POST">
			<table>
				<tr>
					<td>Name:</td>
					<td><form:input path="name"/></td>
				</tr>
				<tr>
					<td>Price:</td>
					<td><form:input path="price"/></td>
				</tr>
				<tr>
					<td>Quantity:</td>
					<td><form:input path="qty"/></td>
				</tr>
				<tr>
					<td></td>
					<td><input type="submit" value="save"></td>
				</tr>
			</table>
		</form:form>
		<a href="products">View Products</a>
	</bdoy>
</html>
--------------------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Products Page</title>
	</head>
	<body>
		<table>
			<thead>
				<tr>
					<th>S.NO</th>
					<th>Name</th>
					<th>Price</th>
					<th>Quantity</th>
				</tr>
			</thead>
			<tbody>
				<c:forEach items="${products}" var="product" varStatus="status">
					<tr>
						<td>${status.count}</td>
						<td>${product.name}</td>
						<td>${product.price}</td>
						<td>${product.qty}</td>
					</tr>
				</c:forEach>
			</tbody>
	 </body>
</html>
-------------------------------------------------------------------------------------------
# JSTL forEach Tag Breakdown

| Part                | Meaning          | Description                                           |
|---------------------|------------------|-------------------------------------------------------|
| <c:forEach          | JSTL Loop Tag    | Starts the loop iteration                             |
| items="${products}" | Collection to iterate | Refers to products attribute from Spring controller |
| var="product"       | Loop variable    | Each item in collection is assigned to product         |
| varStatus="index"   | Loop status      | Provides loop information (counter, index, etc.)       |


Embedded Databasee(i.e In Memory database/Temporary Database)-->Starts when app starts and Stops when app stops
Ex:H2 DB,HSQLDB,Derby
Note -->don't add devtools dependency otherwise it will restart server upon changes and data will be lost
JSTL:-->Whatever data we are inserting in the db table, we need to display in the another page. so need to iterate the list of records in jsp

---Thymeleaf vs JSP
JSP can't send response directly to browser, so it is converted to servelet(Takes more time)
HTML is faster than jsp, but HTML is only for static pages. so we are going to use Thymeleaf inside HTML, to support dynamic webpages
Thymeleaf is the template engine that can be integrated into HTML
create HTML pages in src/resources/templates
| **Feature**              | **Thymeleaf**                  | **JSP (Java Server Pages)**            | 
| ------------------------ | ------------------------------ | ---------------------------------------|
| **Natural Templates**    | ‚úÖ Yes ‚Äì works as static HTML   | ‚ùå No ‚Äì requires server to render     |
| **Spring Integration**   | ‚úÖ Excellent native support     | ‚ö†Ô∏è Requires additional configuration  |
| **Syntax**               | ‚úÖ HTML5-compliant, clean       | ‚ùå Mixes Java code with HTML          |
| **Learning Curve**       | ‚úÖ Easy for frontend developers | ‚ùå Steeper, requires Java knowledge   |
| **Performance**          | ‚úÖ Good (compiled templates)    | ‚úÖ Good (compiled to servlets)        |
| **Internationalization** | ‚úÖ Excellent support            | ‚úÖ Good support                       |
| **Fragment Reuse**       | ‚úÖ Layouts and fragments        | ‚úÖ Includes and taglibs               |
| **Tooling**              | ‚úÖ Good IDE support             | ‚úÖ Mature tooling                     |
------------------------------------------------------------------------------------------------------
--need to add thymeleaf-starter in pom.xml(tomcat-embed-jasper is not needed now and no need to configure view resolver)

| Tag                                            | Description                         |
| ---------------------------------------------- | ----------------------------------- |
| `<form th:action="@{/product}" method="post">` | Submits form to `/product` endpoint |
| `th:object="${p}"`                             | Binds form inputs to Product object |
| `th:field="*{name}"`                           | Maps field to `Product.name`        |
| `th:if` / `th:text`                            | Used to show messages dynamically   |


index.html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>Home Page</title>
</head>
<body>
	<div class="container">
		<h3>
			<p th:text="${msg}" class="text-success"></p>
		</h3>
	</div>

	<form th:action="@{/product}" th:object="${p}" method="post">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" th:field="*{name}" ></td>
			</tr>
			<tr>
				<td>Price:</td>
				<td><input type="number" th:field="*{price}" ></td>
			</tr>
			<tr>
				<td>Quantity:</td>
				<td><input type="number" th:field="*{quantity}" ></td>
			</tr>
			<tr>
				<td><a href="/">Reset</a></td>
				<td><input type="submit" value="Save" class="btn btn-primary" /></td>
			</tr>
		</table>
	</form>

	<div class="pt-3 pb-3">
		<a href="/products">View All Products</a>
	</div>
</body>
</html>

data.html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
	<meta charset="UTF-8">
	<title>Product Page</title>
	<script type="text/javascript">
		function deleteConfirm() {
			return confirm("Are you sure you want to delete this product?");
		}
	</script>
</head>

<body>
	<div class="container">
		<h1>View Products</h1>
		<p th:text="${msg}" class="text-danger">
		<a href="/" class="btn btn-primary">+Add New Product</a>
	</div>
	<table>
		<thead>
			<tr>
				<th>Product ID</th>
				<th>Product Name</th>
				<th>Product Price</th>
				<th>Product Quantity</th>
				<th>Action</th>
			</tr>
		</thead>
		<tbody>
			<tr th:if="${list == null or list.empty}">
				<td colspan="5" style="text-align: center;">
					No Records found
				</td>
			</tr>
			<tr th:each="product : ${list}" th:if="${list != null and !list.empty}">
				<td th:text="${product.pid}"></td>
				<td th:text="${product.name}"></td>
				<td th:text="${product.price}"></td>
				<td th:text="${product.quantity}"></td>
				<td>
					<a th:href="@{/delete(pid=${product.pid})}" class="btn btn-danger"
						onclick="return deleteConfirm()">Delete</a>
				</td>
			</tr>
		</tbody>
	</table>
</body>

Form Validation-->As record should be inserted only when the data is available
--Client Side Validation: Validations executes on browser
--Server Side Validation:---for this we have to add spring-boot-starter-validation, we will write validation on binding object
@Validated---->To tell the spring boot, that we are getting form data in form of binding object, you verify that form data ,
store into binding object satisfying validation rule or not
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>Home Page</title>
</head>
<body>
	<div class="container">
		<h3>
			<p th:text="${msg}" class="text-success"></p>
		</h3>
	</div>

	<form th:action="@{/product}" th:object="${p}" method="post">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" th:field="*{name}" ></td>
				<td th:if="${#fields.hasErrors('name')}" th:errors="*{name}" class="text-danger"></td>
			</tr>
			<tr>
				<td>Price:</td>
				<td><input type="number" th:field="*{price}" ></td>
				<td th:if="${#fields.hasErrors('price')}" th:errors="*{price}" class="text-danger"></td>
			</tr>
			<tr>
				<td>Quantity:</td>
				<td><input type="number" th:field="*{quantity}" ></td>
				<td th:if="${#fields.hasErrors('quantity')}" th:errors="*{quantity}" class="text-danger"></td>
			</tr>
			<tr>
				<td><a href="/">Reset</a></td>
				<td><input type="submit" value="Save" class="btn btn-primary" /></td>
			</tr>
		</table>
	</form>

	<div class="pt-3 pb-3">
		<a href="/products">View All Products</a>
	</div>
</body>
</html>

@Entity
@Data
public class Product {
	
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	private Integer pid;
	
	@Size(min = 3, max = 15, message = "Name must have between {min} and {max} characters")
	@NotBlank(message="Name is mandatory")
	private String name;
	
	@NotNull(message="Price should be not null")
	private Double price;
	
	@NotNull(message="Quantity should be entered")
	private Integer quantity;

}

@Controller
public class ProductController {
	
	@Autowired
	public ProductRepository repo;
	
	@GetMapping("/")
	public String loadForm(Model model) {
		model.addAttribute("p", new Product());   //To bind form to binding object
		return "index";
	}
	
	@PostMapping("/product")
	public String saveProduct(@Validated @ModelAttribute("p") Product p,BindingResult result,Model model) {
		if(result.hasErrors()) {
			System.out.println(p);
			return "index";
		}
		Product savedProduct = repo.save(p);
		System.out.println(savedProduct);
		if(savedProduct.getPid()!=null) {
			model.addAttribute("msg", "Product is saved in DB");
		}
		return "index";
	}
	
	@GetMapping("/products")
	public String loadAllProducts(Model model){
		List<Product> all = repo.findAll();
		model.addAttribute("list",all);
		return "data";
	}
	
	@GetMapping("/delete")
	public String deleteRecord(@RequestParam("pid")Integer pid,Model model) {
		repo.deleteById(pid);
		List<Product> all = repo.findAll();
		model.addAttribute("msg", "Product deleted Successfully");
		model.addAttribute("list",all);    //displays latest data
		return "data";
	}
	
	@GetMapping("/edit")
	public String editProduct(@RequestParam("pid") Integer pid, Model model) {
	    Product product = repo.findById(pid).orElse(new Product());
	    model.addAttribute("p", product);
	    return "index"; // same form, pre-filled with data
	}


}

-->While using edit button and click on save button, pid again coming as null value, JPA thinks it's a new record. We need to tell JPA that it's existing,
 so use hidden variable
 <body>
	<div class="container">
		<h3>
			<p th:text="${msg}" class="text-success"></p>
		</h3>
	</div>

	<form th:action="@{/product}" th:object="${p}" method="post">
		<input type="hidden" th:field="*{pid}" />
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" th:field="*{name}" ></td>
				<td th:if="${#fields.hasErrors('name')}" th:errors="*{name}" class="text-danger"></td>
			</tr>
-------------------------------------------------------------------------------------
@Controller
@RequestMapping("/grateful")
public class MsgController {
	
	@GetMapping("/welcome")          --------------->When both are @GetMapping Method url should also be unique, otherwise confusion/ambiguity while component scanning
	public String welcomeMsg(Model model) {
		model.addAttribute("msg","Welcome to the team");
		return "index";        //Returns a Thymeleaf template view
	}
	
	@GetMapping("greet")
	@ResponseBody                      ------>@Controller + @ResponseBody--->Method will become REST method
	public String greetMsg() {
		return "Greetings";     //@ResponseBody returns the string directly as the HTTP response, not as a template view.
	}

}

application.properties
spring.application.name=25-Web-MVC-EmbedServer-ResponseBodyApp
server.port=9090
server.servelet.context-path=/alchemist
#localhost:9090/alchemist/*  ---->this url should be formed


Note: When controller method returns string type, dispatcher servelet will consider it as a view file, with that name and search it--->error. 
So we use @ResponseBody--> dispatcher will think that, whatever this method is returning is direct response to the client, who sends the request
@Controller--->C2B communication---->Request---->WebPages
@RestController--->B2B communication--->Request--->Response

@ResponseBody can be used at class level as well as Method level

Mutliple URL pattern for single method
@GetMapping(value={"/hi","/hello","/"})

---Exception Handling in the Web MVC application--->Unexepected and unwanted situation is called Exception.(i.e program terminate abnormally)
Handling Exception and Conveying to user are two different things.
--Two ways of Exception Handling
-Local Exception Handling(Controller specific exception handling)-->@ExceptionHandler
-Global Exception Handling(Application Specific)
Note: Local Exception Handling is not recommended as code duplication, we need to seperate Business logic and secondary logic(Aspect Oriented Programming)

@Controller
public class DemoController {
	
	private Logger logger = LoggerFactory.getLogger(DemoController.class);
	
	@GetMapping("/")
	public String getMessage(Model model) {
		int i=1/0;
		model.addAttribute("msg","Hi, Hello");
		return "index";
	}
	
	@GetMapping("/greet")
	public String greetMsg(Model model) {
		String txt=null;
		txt.length();
		model.addAttribute("msg","Greetings");
		return "index"; 
	}
	
	//@ExceptionHandler(value=ArithmeticException.class)
	@ExceptionHandler(value=Exception.class)------------------>//Exception is super class for all types of Exception
	public String handleArithmeticException(Exception ae){
		String msg = ae.getMessage();
		logger.error(msg);          //logging Error Message
		return "errorPage";
	}
}
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
	<head>
		<meta charset="UTF-8">
		<title>Error Page</title>
	</head>
	<body>
		<h2>Some problem occurred, Please try after some time....</h2>
	</body>
</html>

Whenever, Exception comes in project, spring boot will check is their anu handler for it?-->If yes, then it will execute it and if NO-->whitelebel error

--Global Exception Handler

@ControllerAdvice
public class AppExceptionHandler {
	
	private Logger logger = LoggerFactory.getLogger(AppExceptionHandler.class);
	
	@ExceptionHandler(value=Exception.class)
	public String handleException(Exception e) {
		String errorText = e.getMessage();
		logger.error(errorText);
		return "errorPage";		
	}
	
	@ExceptionHandler(value=NullPointerException.class)
	public String handleNullPointerEx(NullPointerException e) {
		String errorText = e.getMessage();
		logger.error(errorText);
		return "errorPage";
	}

}

---Java MocroServices(Microservice-->Architectural design pattern)
--Monolith Architecture--->Maintenance, Single point of failure, Redeploy entire app
--Microservices Architecture-->Easy maintenance,High availablility,Fast Development,Quick releases,Technology independency(i.e each API can be developed with differnt languages)
Microservice == One REST API
Distribute Applications-->One project wants to communicate with other project
ex: Passport App---->Aadhar app---->DB
Here Passport app is consumer app, and Aadhar app is provider app(i.e Providing services to other apps)
UI and BackEnd can be differnt projects
--InterOperatibility means platform independent and language independent
Mediator language--XML/JSON
XML-->As a mediator to excbange data between one application to other application
JSON-->Platform Independent and language indpendent(Inter-Operatibility achieved)

--REST Architecture-->
-Provider/Resource-->The application which is giving services to other application is called as provider application, provider is also called as REST APIs
-Consumer/Client-->The application which is accessing the services from other applications is called as Consumer application
-How communication happens between Provider and Consumer?
HTTP protocol, will act as mediator between consumer and provider. Consumer and provider will exchange data in the form of XML/JSON
Note: XML and JSON are inter-operable

HTTP Protocol-->HTTP will act as a mediator between client and server, HTTP is stateless protocol
                HTTP Request
                HTTP RESPONSE
				HTTP methods
				HTTP status code 
-HTTP Methods-->GET(To get the data from the server)
                POST(To send the data to server, insert/crete record at server)
				PUT(To update data at server)
				DELETE(To delet data at the server)
Note: Every REST API method should be mapped to HTTP Method

-HTTP Status Code:-->When Client send request to the Server, then server will process that request and will send response to the client with status code
  1XX--->Informational Code
  2XX--->Success Code
  3XX--->ReDirection(You sent request to one server, it will redirect to other server)
  4XX--->Client Error(Sending Incorrect request)
  5XX--->Server Error
  
All codes
1xx Informational:
100 Continue
101 Switching Protocols
102 Processing
103 Early Hints

2xx Success:
200 OK
201 Created
202 Accepted
204 No Content
206 Partial Content

3xx Redirection:
301 Moved Permanently
302 Found
304 Not Modified
307 Temporary Redirect
308 Permanent Redirect

4xx Client Error:----->when 4xx entered in 400 they told bad request and go to 401 and mark it as unauthorized,  
400 Bad Request------->in 401 it told to go in 403 and mark it as Forbidden, one person still tried after it marked as forbidden he got it 404-->not found, he tried one method and got 405 Method not allow
401 Unauthorized
403 Forbidden
404 Not Found
405 Method Not Allowed
409 Conflict
429 Too Many Requests

5xx Server Error:
500 Internal Server Error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 Gateway Timeout

Quick Ref:
2xx = Success
3xx = Redirect  
4xx = Client Error
5xx = Server Error

HTTP Request‚ÄìResponse Cycle Diagram

                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ          CLIENT              ‚îÇ
                ‚îÇ (Browser / Postman / App)    ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îÇ  HTTP Request
                              ‚ñº
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ                   HTTP REQUEST                     ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ Request Line    ‚Üí  Method + URL + HTTP Version      ‚îÇ
     ‚îÇ   e.g. GET /api/course/101 HTTP/1.1                 ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ Request Headers ‚Üí  Metadata (key‚Äìvalue pairs)       ‚îÇ
     ‚îÇ   e.g. Content-Type: application/json               ‚îÇ
     ‚îÇ        Authorization: Bearer <token>                ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ Request Body    ‚Üí  Payload (actual data sent)       ‚îÇ
     ‚îÇ   e.g. { "courseName": "Java", "duration": "2m" }   ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îÇ  ‚Üì Sent to Server
                              ‚îÇ
                              ‚ñº
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ                     SERVER                         ‚îÇ
     ‚îÇ (API / Web Server / Database)                      ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îÇ  HTTP Response
                              ‚ñº
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ                   HTTP RESPONSE                    ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ Response Line   ‚Üí  Status Code + Message            ‚îÇ
     ‚îÇ   e.g. HTTP/1.1 200 OK                              ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ Response Headers ‚Üí  Metadata (content type, etc.)   ‚îÇ
     ‚îÇ   e.g. Content-Type: application/json               ‚îÇ
     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
     ‚îÇ Response Body   ‚Üí  Actual response data             ‚îÇ
     ‚îÇ   e.g. { "id": 101, "courseName": "Java" }          ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îÇ  ‚Üì Back to Client
                              ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ      CLIENT (Displays Data)   ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

--JSON(JavaScript Object Notation):-JSON is used to represent data in key-value format
JSON is umiversal format to exchange data over internet
Syntax:
{
 "id" : 101,
 "name" : "Rohit",
 "gender" : "Male",
 "Phno" : "8087217921",
 "address" : {
               "city" : "Ichalkaranji",
			   "state" : "Maharashtra"
			  } 
}
-key in double quotes and only string value is in double quotes
As a part of development, java object conveted to JSON and vice versa
We have to use 3rd party apis to work with JSON data in java applications
-JackSon api--->ObjectMapper class provides method to convert java to json and vice versa(Spring boot by default uses it, 
when we add spring web--by default jackson-databind-__.jar can be seen)
-GSon api

JackSon api-->ObjectMapper class
/*
 * JACKSON OBJECTMAPPER - COMPLETE REFERENCE
 * 
 * ObjectMapper is the main class for Jackson API that provides 
 * bidirectional conversion between Java Objects and JSON data
 */

ObjectMapper mapper = new ObjectMapper();

// ================= SERIALIZATION (Java Object ‚Üí JSON) =================
// Converting Java objects to JSON format

String jsonString = mapper.writeValueAsString(javaObject);
// ‚Üí Converts Java object to JSON string

mapper.writeValue(new File("data.json"), javaObject);
// ‚Üí Writes Java object as JSON to file

String prettyJson = mapper.writerWithDefaultPrettyPrinter()
                         .writeValueAsString(javaObject);
// ‚Üí Converts to formatted/readable JSON string

// ================= DESERIALIZATION (JSON ‚Üí Java Object) =================
// Converting JSON data back to Java objects

JavaObject obj1 = mapper.readValue(jsonString, JavaObject.class);
// ‚Üí Converts JSON string to Java object

JavaObject obj2 = mapper.readValue(new File("data.json"), JavaObject.class);
// ‚Üí Reads JSON file and converts to Java object

JavaObject obj3 = mapper.readValue(inputStream, JavaObject.class);
// ‚Üí Converts JSON from InputStream to Java object

// ================= WORKFLOW DIAGRAM =================
/*
 *        +----------------+      Serialization      +---------------+
 *        |                |    (Java ‚Üí JSON)        |               |
 *        |  Java Object   |  -------------------->  |   JSON Data   |
 *        |                |                         |               |
 *        +----------------+                         +---------------+
 *                ^                                         |
 *                | Deserialization                         |
 *                | (JSON ‚Üí Java)                          |
 *                |                                         |
 *                +-----------------------------------------+
 */

// ================= DEPENDENCY =================
/*
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.17.2</version>
</dependency>
*/

// ================= KEY FEATURES =================
// ‚Ä¢ Handles nested objects and collections
// ‚Ä¢ Supports annotations for customization
// ‚Ä¢ Thread-safe after configuration
// ‚Ä¢ Automatic type inference
// ‚Ä¢ Exception handling for invalid JSON

// ================= COMMON EXCEPTIONS =================
// JsonProcessingException - Invalid JSON during reading
// IOException - File/stream operations
// InvalidFormatException - Type mismatch

--Gson api

public class App {
	public static void main(String[] args) {
    	Address addr = new Address();
		addr.setCity("Ichalkaranji");
		addr.setState("Maharashtra");
		addr.setCountry("India");
		
		Customer c = new Customer();
		c.setId(1);
		c.setName("Rohit");
		c.setEmail("lavatero92@gmail.com");
		c.setPhno((long)80872179);
		c.setAddr(addr);
		
		/*
		 * Gson gson = new Gson(); String json = gson.toJson(c); System.out.println(c);
		 */
		
        File file = new File("customer.json");
        Gson gson = new Gson();
        try {
            // Write JSON to File
            FileWriter writer = new FileWriter(file);
            gson.toJson(c, writer);
            writer.close();
		
		/*Customer fromJson = gson.fromJson(json, Customer.class);
		System.out.println(fromJson);
        */
            FileReader reader = new FileReader(file);
            Customer fromJson = gson.fromJson(reader, Customer.class);
            reader.close();
            
            System.out.println("\nObject from JSON file:");
            System.out.println(fromJson);
        }catch(Exception e) {
        	e.printStackTrace();
        }
    }
}

@RestController
public class CutstomerRestController {
	
	@GetMapping("/")
	public Customer getCustomer() {
		Address addr = new Address();
		addr.setCity("Terwad");
		addr.setState("Maharashtra");
		addr.setCountry("India");
		
		Customer customer = new Customer();
		customer.setId(1);
		customer.setName("Prime");
		customer.setEmail("prime@gmail.com");
		customer.setPhno((long)996050);
		customer.setAddr(addr);
		
		return customer;          --->Return json when we hit localhost:${server.port}/
	}
}

--XML and JAX-B
XML is extensible markup language(inter-operable)
XML represents data in element format(start tag and end tag) ex-<id>101</id>
XML have  2 types of elements
-Simple Elements:--Contains data directory
-Compound Elements:--Element containing child element
ex: <person>
       <id>101</id>
	   <name>Smith</name>
	   <address>
	       <city>Ichalkaranji</city>
		   <state>MH</state>
	   </address>
    </person>
	
# MARSHALLING & UNMARSHALLING

## üîÑ CONVERSION PROCESS

      +-------------+    MARSHALLING     +-------------+
      |             |   (Object ‚Üí Data)  |             |
      |  JAVA OBJ   | ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî> |    XML/JSON |
      |             |                    |             |
      +-------------+                    +-------------+
            ^                                  |
            | UNMARSHALLING                    |
            | (Data ‚Üí Object)                  |
            |                                  |
            +‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî+

## üìù DEFINITIONS

### MARSHALLING (Serialization)
- **Java Object ‚Üí Structured Data** (XML/JSON)
- Also called: **Serialization**, **Encoding**
- **Purpose**: For transmission, storage, API calls

### UNMARSHALLING (Deserialization)  
- **Structured Data ‚Üí Java Object** 
- Also called: **Deserialization**, **Decoding**
- **Purpose**: For processing, data manipulation

## üõ†Ô∏è TECHNOLOGIES

### 1. JAX-B (Java Architecture for XML Binding)
```java
// MARSHALLING
JAXBContext context = JAXBContext.newInstance(Employee.class);
Marshaller marshaller = context.createMarshaller();
marshaller.marshal(employee, new File("employee.xml"));

// UNMARSHALLING  
Unmarshaller unmarshaller = context.createUnmarshaller();
Employee emp = (Employee) unmarshaller.unmarshal(new File("employee.xml"));
Note: To perform marshalling and Un-Marshalling, we need to create Binding class
Note: Upto JDK 1.8, JAX-B was part of JDK, but from 1.9v, it is not part of JDK, so we need to add in pom.xml

@Data
@XmlRootElement
public class Customer {
	
	private Integer id;
	
	private String name;
	
	private String email;
	
	private Long phno;

}

public class MarshalDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Customer customer = new Customer();
		customer.setId(1);
		customer.setName("Prime");
		customer.setEmail("prime@co.in");
		customer.setPhno((long)9899);
		
		try {
			JAXBContext context = JAXBContext.newInstance(Customer.class);
			Marshaller marshaller = context.createMarshaller();
			marshaller.marshal(customer,new File("Customer.xml"));
			System.out.println("XML file is created");
		} catch (JAXBException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}


--Provider/REST API development
@RestController
public class MsgRestController {
	
	@PostMapping("/msg")        //we have to check through postman--->405 in browser(whitelebel), browser will support only get methods(doesnot contain body)
	public ResponseEntity<String> saveMsg(){
		String responseBody = "Msg saved successfully....";
		return new ResponseEntity<String>(responseBody,HttpStatus.CREATED);
	}
	
	@GetMapping("/welcome")
	public ResponseEntity<String> welcomeMsg(){
		String msg = "Welcome to all people";
		return new ResponseEntity<String>(msg,HttpStatus.OK);----->To customize Response Body
	}
	
	@GetMapping("/greet")     --------------------------------->Method is not returning any status , but internally dispatcher servelet will prepare response and sent it(Can be seen in Postman)
	public String getGreeting() {
		String greet = "Good Morning, everyone";
		return greet;
	}

}
-------------------------------------------------------------------------------
@RestController
public class UserRestController {
	
	private  Map<Integer, User> dataMap =new HashMap<>();
	
	@PostMapping("/user")
	public ResponseEntity<String> addUser(@RequestBody User user){
		dataMap.put(user.getId(), user);
		System.out.println(dataMap);
		return new ResponseEntity<String>("User saved.....",HttpStatus.CREATED);
	}
	
	@GetMapping("/user")
	public User getUserByQueryParam(@RequestParam("userId") Integer userId) {
		User user = dataMap.get(userId);
		return user;
	}
	
	//example for multiple query parameters
	/*
	 * @GetMapping("/userData") public User getUserData(@RequestParam("name") String
	 * name, @RequestParam("email") String email ) { return null; }
	 */
	
	@GetMapping("/user/{id}")
	public User getUserByPathParam(@PathVariable("id")Integer userId) {
		User user = dataMap.get(userId);
		return user;
	}
	
	@GetMapping("/userData/{id}/data")
	public User getUserByPathParamUrlPattern(@PathVariable("id")Integer userId) {
		User user = dataMap.get(userId);
		return user;
	}

}


-When hit this url, check header in the postman--->Content-Type=application/Json
-Payload-->Business data, any data that is exchanged between consumer and provider in the body is called as a payload.
-Header-->Extra data you want to send consumer or provider(we can't pass business data here)-->Content-Type=application/Json(Understand what type of data client sends)
-@RequestBody--->To read Payload from HTTP POST Request(Telling that, get the data from request body and store into User object)
-@RequestPaaram-->To take single value 
-ResponseEntity-->To Test Rest API functionality
Note: if data is huge, go for body. Otherwise use url(Not sensitive data, send it in url)

--Query Param and Path Params--->Both are used to send data to server, sends data in URL
-Query Parameter----> www.youtube.com/watch?v=123(key and value format),Normally present at end of URL, starts with '?', 
and seperated by using '&'(e.g-->?v=seva&country=IN)------>Use @RequestParam to read query param from url
When client sends GET request with userId in query parameter. method will read parameter, using this gets data from map and return object in JSON format

-Path Parameter----->www.udemy.com/courses/java(direct value format)-->Path param will represent data directly, Path param can present anywhere in URL, starts with '/'
and will seperated only by '/'----->Use @PathParam to read the path parameter----->localhost:9090/user/1
Note: When Client is GET request, then client can use Query params or path params to send data to the server. GET request will not contain any Request Body
so we have to use either Query or path param to send the data. POST method doesn't require it, as it have body to send the data.
i.e when, we have parameter with @RequestParam, DispatcherServelet will understand that, userId will come as a query parameter--> It will understand that and 
check userId in query parameters. take it and give it to the method. Method return object --> DispatcherServelet return JSON(POST Processing)

	@PostMapping("/user")
	public ResponseEntity<String> addUser(String user){    ------->Instead of object if we send string it also works but, whatever json client is sending that should come
	                                                               as parameter to our method(raw JSON)-->write logic to convert JSON to java
																   But what if client sends xml--->code fails--->Tightly coupled with JSON, that's why we take object
																     Before processing, DispatcherServelet will read what data in the url,what is in body, in header
																   it observes Content-Type-->Give it to MsgConverter-->it give back converted data to DispatcherServelet and 
																   then passed to method

Note:
-When you want to get record with unique id-->Path Parameter(Based on ticket number, get data)
-If your method is giving more records as response-->Query Parameter(Based on author name, get book list)

--Consumes and Produces-->
consumes--->It represents which format supported by REST API method or In which format REST API can accept input data from client.
produces--->It represents in which format REST API method can provide response to clients
Note: POST Method-->consumes data
      GET Method--->produces data
Example:
    @PostMapping(
			value="/user",
			consumes= {"application/json"}
			)
	public ResponseEntity<String> addUser(@RequestBody User user){
		dataMap.put(user.getId(), user);
		System.out.println(dataMap);
		return new ResponseEntity<String>("User saved.....",HttpStatus.CREATED);
	}
	
	@GetMapping(
			value="/user", 
			produces= {"aplication/json"}
	)
	public User getUserByQueryParam(@RequestParam("userId") Integer userId) {
		User user = dataMap.get(userId);
		return user;
	}
	
Alternative way-->
@RestController
public class MyController {
    
    // JSON Response
    @GetMapping(value = "/users", produces = MediaType.APPLICATION_JSON_VALUE)
    public List<User> getUsers() {
        return userService.getAllUsers();
    }
    
    // XML Response
    @GetMapping(value = "/users", produces = MediaType.APPLICATION_XML_VALUE)
    public List<User> getUsersXml() {
        return userService.getAllUsers();
    }
    
    // Accept JSON request body
    @PostMapping(value = "/users", 
                consumes = MediaType.APPLICATION_JSON_VALUE,
                produces = MediaType.APPLICATION_JSON_VALUE)
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }
}
	
Client should send--->Accept=aplication/json or application/xml in header
The client must specify the Accept header to tell the server which format they want.
- Request Flow:
CLIENT REQUEST ‚Üí Spring DispatcherServlet ‚Üí Content Negotiation ‚Üí Message Converter ‚Üí Your Method
     ‚Üì                   ‚Üì                       ‚Üì                   ‚Üì               ‚Üì
   Accept:             Reads                Determines           Converts        Returns
application/json    Accept header          response format    Object ‚Üí JSON     Java Object

---jackson-dataformat-xml used in place of JAXB
@RestController
public class BookRestController {
	
	@GetMapping(
			value="/book",
			produces= {"application/json","application/xml"}
			)
	public Book getBook() {
		Book b = new Book();
		b.setId(1);
		b.setName("Java");
		b.setPrice(200d);
		return b;	
	}

}
Note: If we add JAXB dependency, above program will give data in xml format.(By default we get data in Json format)
If we want data to be stored in particular format mention it in 'Accept' attribute.

POST-->localhost:9090/book
       Content-Type: application/json(Header)  ----->i.e represents in which format client sending data to server in Request Body
	   Body: Raw-data-->JSON
GET-->localhost:8080/book
       Accept: aplication/json(Header)   -----> This header will represent in which format client expecting response from server
	   
--Swagger Documentation:--Swagger(Third party library) is used to generate REST API documentation
-The Problem
Spring Boot 3 uses Jakarta EE 9+ (package names: jakarta.servlet)
SpringFox (Swagger) uses legacy Java EE (package names: javax.servlet)
This causes ClassNotFoundException for javax.servlet.http.HttpServletRequest
-Add dependencies
<!-- Add SpringDoc OpenAPI -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.8.5</version>
</dependency>
-don't add these dependencies-->springfox-swagger2,springfox-swagger-ui
--Create SwaggerConfig Class with @Configuration
--spring.mvc.pathmatch.matching-strategy=ANT_PATH_MATCHER(application.properties)
--UI URL http://localhost:9090/swagger-ui.html directly access this url
Doc URL  http://localhost:9090/v3/api-docs     -->info about APIs(JSON Format)-->host,basepath,paths(url patterns),consumes,produces and Response data

--For Deployment
-add in pom.xnl--->Add tag <finalName>
<build>
	 <finalName>sb-irctc-api</finalName>
		<plugins>
			<plugin......

-Refresh and run as --> Maven build, Goals-->clean package(To package app)
-Launch EC2(Linux VM, Ubuntu,t2.micro,key-pair(e.g sbmsKey)), Security group-->Add rule-->Custom TCP(8080)-->in our case 9090
-Open Mobaxterm--->Basic SSH setting-->Remote Host-->(paste public IP) and Specify Username-->Ubuntu,Port:22
                   Advanced SSH setting-->Use private key(Check it)-->Select key-pair
-copy file path and upload file
-run following commands
$sudo apt install dafault-jdk
$sudo apt install java
$java -version
$java -jar sb-irctc-api.jar
--Now go to instance-->take public ip by selecting EC2
--Go to browser===> (public IP):8080/swagger-ui.html

---Consumer Development
--Client/Consumer-->application which is accessing services from other applications
3 ways to develop consumer
-RestTemplate(Out dated)---------------->Supports only synchronous communication
-WebClient(Introduced from Spring 5.X)-->supports both synchronous as well as Asynchronous communication
-FeignClient(Spring Cloud)
Note: In Realtime, APIs cannot be accessed by everyone(security)

--For using RestTemplate
   RestTemplate rt = new RestTemplate();
   ResponseEntity<Object of Response type> response=rt.postForEntity("url you want to access"."object data you want to send in body","Response type(how we want response)");-->for post request, 
   
   for get request--->getForEntity(url,ResponseType class, path variables comma seperated);
   
-public class ServiceImpl implements MTMService{
	private String BOOK_TICKET_URL = "http://localhost:9090/ticket";       //ip inplace of localhost when deployed on AWS
	private String GET_TICKET_URL = "http://localhost:9090/ticket/{ticketNum}";

	@Override
	public Ticket bookTicket(Passenger passenger) {
		RestTemplate rt = new RestTemplate();
		ResponseEntity<Ticket> response = rt.postForEntity(BOOK_TICKET_URL, passenger, Ticket.class);
		Ticket ticket = response.getBody();
		return ticket;
	}

	@Override
	public Ticket getTicketByNum(String ticketNumber) {
		RestTemplate rt = new RestTemplate();
		ResponseEntity<Ticket> response = rt.getForEntity(GET_TICKET_URL, Ticket.class, ticketNumber);
		Ticket ticket = response.getBody();
		return ticket;
	}

}

--WebClient-->Predefined interface(spring 5.x)--->We can send HTTP Request(GET,PUT,POST,DELETE)
Supports both sychronous and asynchronous communications.
Dependency-->web-flux-starter (spring reactive web)

@Service
public class ServiceImpl implements MTMService{
	private String BOOK_TICKET_URL = "http://localhost:9090/ticket";       //ip inplace of localhost when deployed on AWS
	private String GET_TICKET_URL = "http://localhost:9090/ticket/{ticketNum}";

	@Override
	public Ticket bookTicket(Passenger passenger) {
		WebClient webclient = WebClient.create();
		Ticket ticket = webclient.post()
				     .uri(BOOK_TICKET_URL)
					 .header("Accept","application/json")             //To send the header in request
				     //.body(BodyInserters.fromObject(passenger))    //deprecated
				     .bodyValue(passenger)                           //use it--->i.e convert passenger data from object to json
				     .retrieve()
				     .bodyToMono(Ticket.class)
				     .block();
		return ticket;
	}

	@Override
	public Ticket getTicketByNum(Integer ticketNumber) {
		//Get the instance of webclient(Implementaion class object)
		WebClient webclient = WebClient.create(); 
		//Send GET Request and map response to ticket obj
		Ticket ticket = webclient.get()                         //represent get request
				        .uri(GET_TICKET_URL,ticketNumber)      //If we want to send query param-->set it parameter here
				        .retrieve()                            //retrieve the response
				        .bodyToMono(Ticket.class)              //response map to Ticket class object and return object
				        .block();                             //wait till get response from IRCTC app and store into variable
		return ticket;
	}

}
-----------------------------------------------------------------------------------------------------
@Controller
public class MakeMyTripController {
	@Autowired
	private MTMService service;
	
	@GetMapping("/")
	public String loadForm(Model model) {
		model.addAttribute("passenger",new Passenger());
		return "index";
	}
	
	@PostMapping("book-ticket")
	public String bookTicket(@ModelAttribute("passenger")Passenger passenger, Model model) {
		Ticket bookedTicket = service.bookTicket(passenger);
		model.addAttribute("msg","Ticket is booked with ID:"+bookedTicket.getTicketNumber());
		return "index";
	}
	@GetMapping("/get-ticket")  
	public String getTicketDetails(
	        @RequestParam(value = "ticketNumber", required = false) Integer ticketNumber, 
	        Model model) {
	    
	    System.out.println("=== GET TICKET DEBUG ===");
	    System.out.println("Received ticketNum parameter: " + ticketNumber);
	    
	    if (ticketNumber != null) {
	        System.out.println("Calling service.getTicketByNum(" + ticketNumber + ")");
	        Ticket ticket = service.getTicketByNum(ticketNumber);
	        System.out.println("Service returned ticket: " + ticket);
	        model.addAttribute("ticket", ticket);
	        
	        if (ticket == null) {
	            System.out.println("‚ö†Ô∏è No ticket found for number: " + ticketNumber);
	        } else {
	            System.out.println("‚úÖ Ticket found: " + ticket.getTicketNumber());
	        }
	    } else {
	        System.out.println("‚ÑπÔ∏è No ticketNum parameter received");
	    }
	    
	    System.out.println("Returning view: ticket-form");
	    return "ticket-form";
	}
	
}

--Sychronous vs Asynchronous Communications
Synchronous Communication-->After Sending request, thread will wait for RESPONSE---->sync call(sync request)-->block()
Aysnc Communication--->After sending the request, thread will not wait for response-->Async call(Async request)-->subscribe()
//do one example

--------------------------------------------------------------------------------
public class WebClientSyncAsyncExample {

    public static void main(String[] args) throws InterruptedException {

        WebClient webClient = WebClient.create("https://jsonplaceholder.typicode.com");

        // --- Synchronous Call ---
        System.out.println("=== Synchronous Call Start ===");
        long startSync = System.currentTimeMillis();

        String syncResponse = webClient.get()
                .uri("/posts/1")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class)
                .block();  // <-- BLOCKING call

        long endSync = System.currentTimeMillis();
        System.out.println("Sync Response Received:");
        System.out.println(syncResponse);
        System.out.println("Time Taken (Sync): " + (endSync - startSync) + " ms");
        System.out.println("=== Synchronous Call End ===\n");


        // --- Asynchronous Call ---
        System.out.println("=== Asynchronous Call Start ===");
        long startAsync = System.currentTimeMillis();

        Mono<String> asyncResponse = webClient.get()
                .uri("/posts/1")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class);

        asyncResponse.subscribe(
                data -> {
                    long endAsync = System.currentTimeMillis();
                    System.out.println("Async Response Received:");
                    System.out.println(data);
                    System.out.println("Time Taken (Async): " + (endAsync - startAsync) + " ms");
                    System.out.println("=== Asynchronous Call End ===");
                },
                error -> System.err.println("Error occurred: " + error),
                () -> System.out.println("Request completed successfully.")
        );

        System.out.println("Main thread continues execution...");
        
        // Keep the program running long enough for async response to complete
        Thread.sleep(2000);
    }
}
------------------------------------------------------------------------------------------
package com.example.webclientdemo.controller;

import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@RestController
public class WebClientController {

    private final WebClient webClient = WebClient.create("https://jsonplaceholder.typicode.com");

    // --- Synchronous Example ---
    @GetMapping(value = "/sync", produces = MediaType.APPLICATION_JSON_VALUE)
    public String getSyncData() {
        System.out.println("=== Synchronous Request Start ===");
        long start = System.currentTimeMillis();

        // Blocking call
        String response = webClient.get()
                .uri("/posts/1")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class)
                .block(); // waits for response

        long end = System.currentTimeMillis();
        System.out.println("=== Synchronous Request End (Time: " + (end - start) + " ms) ===");
        return response;
    }

    // --- Asynchronous Example ---
    @GetMapping(value = "/async", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<String> getAsyncData() {
        System.out.println("=== Asynchronous Request Start ===");
        long start = System.currentTimeMillis();

        // Non-blocking call
        Mono<String> responseMono = webClient.get()
                .uri("/posts/1")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToMono(String.class)
                .doOnNext(resp -> {
                    long end = System.currentTimeMillis();
                    System.out.println("=== Asynchronous Response Received (Time: " + (end - start) + " ms) ===");
                });

        System.out.println("Main thread continues execution immediately (non-blocking).");
        return responseMono;
    }
}
----------------------------------------------------------------------------------------------------------
package com.example.webclientdemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebClientDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(WebClientDemoApplication.class, args);
    }
}
----------------------------------------------------------------------------------------------------------
--REST API Excption Handling
We should give meaningful msg when exception occurs,global exception handler

@RestController
public class DemoRestController {
	@GetMapping("/welcome")
	public String welcomeMsg() {
		String msg = "Welcome to REST API...";
		int i = 10/0;
		return msg;
	}

}
----------------------------------------------------------------
@Data
public class ErrorInfo {
	private String code;
	private String msg;
	private LocalDate date;
}
----------------------------------------------------------------
@RestControllerAdvice
public class AppExceptionHandler {
	@ExceptionHandler(value=Exception.class)
	public ResponseEntity<ErrorInfo> handleException(Exception e){
		String errMsg = e.getMessage();
		ErrorInfo info = new ErrorInfo();
		info.setCode(errMsg);
		info.setMsg("SBIEX0003");
		info.setWhen(LocalDate.now());
		return new ResponseEntity<>(info,HttpStatus.INTERNAL_SERVER_ERROR);
	}
	
	@ExceptionHandler(value=UserNotFoundException.class)
	public ResponseEntity<ErrorInfo> handleUserNotFoundException(UserNotFoundException e){
		String errMsg = e.getMessage();
		ErrorInfo info = new ErrorInfo();
		info.setCode(errMsg);
		info.setMsg("SBIEX0004");
		info.setWhen(LocalDate.now());
		return new ResponseEntity<>(info,HttpStatus.BAD_REQUEST);     //different status code---->400 client side exception
	}

}
---------------------------------------------------------------
-User Defined Exception:

public class UserNotFoundException extends Exception{
	private static final long serialVersionUID = 892744662240479766L;
	public UserNotFoundException() {
		
	}
	public UserNotFoundException(String msg) {
		super(msg);                              //RuntimeException constructor will be called
	}

}
------------------------------------------------------------------
@RestController
public class UserRestController {
	@GetMapping("/user/{userId}")
	public String getUserName(@PathVariable("userId") Integer userId) throws UserNotFoundException {
		if(userId == 100) {
			return "john";
		}else if(userId == 200) {
			return "smith";
		}else {
			throw new UserNotFoundException("User not Found");
		}
		
	}

}
-----------------------------------------------------------------
Note: When ArithmeticException occurs, it will check any handler for it or not--->if not, it will go for generic exception. For client app, we are senging meaningful message,
Sending response in JSON format to client app

---properties file vs yml(Yet Another MarkUP language) file
--properties file-->represents data in key-values format and used only in java applications
--yml file--->represents data in hierarchical format, universal format(Java,Ansible,K8s,Python),indent spacing is important
-For multiple values use list
ex:
hobbies:
    -singing
	-playinfg
	-dancing
	
--Actuators:-
Need to add dependency-->spring-boot-starter-actuator
 Used to provide production-ready features for our application(i.e monitor and manage our application)-->no of beans loaded,app health, conifg properties,
environments loaded,threads,JVM and heap etc
https://docs.spring.io/spring-boot/reference/actuator/index.html
https://docs.spring.io/spring-boot/reference/actuator/endpoints.html
URL->http://localhost:9090/actuator, http://localhost:9090/actuator/health
-To enable actuators-----> .include/.exclude
--application.yml-->
spring:
  application:
    name: 40-CSV-PDF-App
server:
  port: 9090
management:
  endpoints:
    web:
      exposure:
        include: '*'                     //Expose all endpoints
        exclude: 'mappings'              //mapping will not be ommited
  endpoint:
    shutdown:
      enabled: true                     //we have configured shutdown of app


URL-->http://localhost:9090/actuator/mapping ---->All URL patterns loaded by our application
      http://localhost:9090/actuator/beans ---> All classes loaded by our (Predefined and custom)
	  http://localhost:9090/actuator/threaddump
	  http://localhost:9090/actuator/heapdump
	  
Note:Shutdown is a special endpoint which is used to stop our application and it is mapped to POST request.
http://localhost:9090/actuator/shutdown	  

--------------------------------------------------------------------------------------------------------------------------------------------
--Microservices--->It is architectural design pattern
Microservices project means it contains collection of REST APIs, and every REST API responsible for one functionality(Independently deployable ,testable)
Advantages:--Easy maintenance,High availability,Fast Development, Quick Releases, Technology Independence(Each REST ApI can be developed with differnt technology)
Challenges:--Bounded context(Deciding No of microservices), lots of configuration and visibility
Microservices Architecture-->Their is no fixed architecture, customize architeture according to project requirement
Example
+-----------------------+       +-----------------------+       +-----------------------+
|         UI            | --->  |     API Gateway       | --->  |   Service Registry     |
| (Frontend / Angular)  |       | (Spring Cloud Gateway)|       |      (Eureka)          |
+-----------------------+       +-----------------------+       +-----------------------+
                                                                          |
                                                                          v
-------------------------------------------------------------------------------------------------------------
|                                                                                                           |
|   +----------------+       +----------------+       +------------------+       +------------------+        |
|   |   Service A    |<----->|   Service B    |<----->|   Admin Server   |<----->|  Zipkin Server   |        |
|   | (API-1)        |       | (API-2)        |       | (Monitoring)     |       | (Tracing)        |        |
|   +--------+-------+       +--------+-------+       +------------------+       +------------------+        |
|            |                        |                                                               |      |
|            |                        |                                                               |      |
|     +------+-----+          +--------+--------+                                                      |      |
|     |    Redis    |          |       Kafka     |                                                      |      |
|     | (Caching)   |          | (Event Stream)  |                                                      |      |
|     +-------------+          +-----------------+                                                      |      |
|                                                                                                      |      |
|     +---------------------------------------------------------------------------------------------+  |      |
|     |                               Config Server (Centralized Config)                            |  |      |
|     |         ‚Üë                    ‚Üë                     ‚Üë                    ‚Üë                    |  |      |
|     |         |                    |                     |                    |                    |  |      |
|     |    Gateway, Service A,   Service B,          Admin Server,         Zipkin Server             |  |      |
|     |   etc. all fetch configs at startup and refresh dynamically from here                        |  |      |
|     +---------------------------------------------------------------------------------------------+  |      |
-------------------------------------------------------------------------------------------------------------

--Service Registry-->It will maintain list of apis available in our project(apis acts as clients of Eureka server(Spring cloud) which acts as Service Registry)-->Name,status and URL
@SpringBootApplication
@EnableEurekaServer
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}

application.yml
---------------
spring:
  application:
    name: 41-SBMS-Service-Registry
server:
  port: 8761
eureka:
  client:
    register-with-eureka: false            //Other app should register with Eureka server, but same application should not

Note: If Service-Registry port is 8761, then client can discover service-registry and will register automatically with service-registry else, we have to register clients with service-registry manually
application.yml     ------>manual registration
---------------
eureka:
  client:
    service-url:
      defaultZone: http://localhost:9090/eureka/


--Admin Server-->It will provide dashboard to monitor and manage all apis actuator at one place(All apis acts as client to admin server also)
@EnableAdminServer
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}

application.yml
----------------
spring:
  application:
    name: 42-SBMS-Admin-Server
server:
  port: 1111

--Zipkin Server-->It is used for distributed tracing(i.e Tracing one request by one api). It will provide information about request processing time(Performace of apis)
Add sleuth dependency, to connect with zipkin server
Download jar-->zipkin.io/quickstart(Java--latest release)
default port: 9411------> http://localhost:9411/zipkin/
To run-->commands
curl -sSL https://zipkin.io/quickstart.sh | bash -s
java -jar zipkin.jar
-Instead of sleuth, add these following dependencies
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-tracing-bridge-brave</artifactId>
</dependency>

<dependency>
    <groupId>io.zipkin.reporter2</groupId>
    <artifactId>zipkin-reporter-brave</artifactId>
</dependency>


Note: Whatever api we develop acts as client for all following apis
http://localhost:8761 --->Service Registry
http://localhost:1111 ---->Admin Server
http://localhost:9411/zipkin/ --->Zipkin Server

--API GateWay-->Request Verifcation and Request validation.(Any request coming to api should come first to api gateway).It will acts as a entry point for all backend apis, it will act as mediator between incoming requestts and backend apis
ex-zuul proxy(Backend),spring cloud Gateway(Open Source),ApiGee(Google, Commercial)

--ConfigServer-->It is used to seperate configuration properties from our application-->For loosely coupling
Project + Project configuration Properties

--Redis Server-->It is used to maintain distributed cache(Cache memory)-->used to reduce number of db calls from our application to DB
Data = Dynamic + Static(Stor static data in Redis cache to reduce database calls)

--Apache kafka-->Message broker, used to develop event driven microservices(to send message from one app to another app)

---Create one application for Service registry, Admin Server and Zipkin Server
Add following dependencies-->
  Spring-web
  DevTools
  Actuator
  Eureka Discovery client
  Spring boot admin client
  zipkin
  sleuth ------> It will communicate with zipkin server

  application.yml
  ---------------
  spring:
  application:
    name: 43-GREET-API
  boot:
    admin:
      client:
        url: http://localhost:1111/                //To tell admin server available(spring.boot.admin.client.url=)
management:
  endpoints:
    web:
      exposure:
        include: '*'
server:
  port: 9090

------------------------------------
--For InterService communication, we will use feign client(Also can be done with RestTemplate)

@FeignClient("GREET-API")
public interface GreetFeignClient {
	@GetMapping("/greet")
	public String invokeGreetApi();         //RunTime implementation by using proxy design pattern
}
---------------
@RestController
public class WelcomeRestController {
	
	@Autowired
	private GreetFeignClient client;
	
	@GetMapping("/welcome")
	public String welcomeMsg() {
		String greetResponse = client.invokeGreetApi();
		return greetResponse + " Welcome to REST";
	}

}
------------------------
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}
-----------------------
Note: When call invokeGreetApi() method, feign client will take service-name and go to service registry and get the url of API. Then feign client will talk to Greet API by sending GET request with '/greet' as URL pattern pattern

---Load Balancer---> To achieve high availability(using FeignClient-->Already load balancing implemented in it)
-What if 1 million request---> 1 tomcat server can not handle it. 
In real time--> Application should not run in one server. so same application should run in multiple server.
Note: With RestTemplate,only one url so no load balancing.
 Feign client will get multiple URL, it will get confused which to use , to avoid confusion spring cloud contains Ribbon. FeignClient contact ribbon, 
 it will decide which URL to use to access GREET API(Logic is round robin). If get more traffic, we can increase instances.(Run configurations---->To do it manually)
 i.e Scalability-->Without stopping any instance, creating new instance
 Autoscaling---->System will decide how much servers it needed, based on traffic
 
---API Gateway(Spring Cloud API Gateway)-->Entry point for all microservices. Any request coming to backend services should go through API Gateway. In API Gateway, Filter logic and 
Routing logic available.(Mediator between UI and BackEnd)
 Filter-->stopping unwanted requests, valid request allowed
 Routing-->From API Gateway, where it should go
-In API Gateway-->we will have 3 types of logics
    Route,Predicate(if path matched, request directed to that uri),Filters

--Servelet based
-To Create API GateWay, add following dependencies
<dependencies>
    <!-- Spring MVC Gateway -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway-mvc</artifactId>
    </dependency>
    
    <!-- Spring Web MVC -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Eureka Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    
    <!-- Actuator -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- Dev Tools -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>
</dependencies>

-Routing-->Whenever request comes with '/welcome' url pattern, you go to welcome api, handle that request so on...It can have one url or multiple instances. 
Routing used to distribute request from one app to other app

-application.yml
-----------------
spring:
  application:
    name: 45-SBMS-API-GATEWAY

  main:
    web-application-type: servlet

  cloud:
    gateway:
      mvc:  # ‚úÖ not under server
        routes:
          - id: greet-api
            uri: lb://43-GREET-API
            predicates:
              - Path=/greet/**
          - id: welcome-api
            uri: lb://44-WELCOMEAPI-INTERSERVICECOMMUNICATION-MONITOR
            predicates:
              - Path=/welcome/**
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true

server:
  port: 2222

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
    register-with-eureka: true
    fetch-registry: true
  instance:
    prefer-ip-address: true

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always

logging:
  level:
    org.springframework.cloud.gateway.server.mvc: TRACE




  
-Routing Flow
  Client Request ‚Üí Gateway (Port 2222) ‚Üí Route Matching ‚Üí Service Discovery ‚Üí Load Balancing ‚Üí Target Service
     ‚Üì
http://localhost:2222/welcome ‚Üí Gateway ‚Üí WELCOME-API service instance

                    +-----------------+
                    |       UI        |
                    +--------+--------+
                             |
                             v
         +-------------------------------------------+
         |        API Gateway (Spring Cloud Gateway) |
         |-------------------------------------------|
         |  Port: 2222                               |
         |  - Routing                                |
         |  - Filters                                |
         |  - Authentication/Authorization           |
         +------------------+------------------------+
                             |
                             v
             +-----------------------------------+
             |  Service Registry (Eureka Server)  |
             |  Port: 8761                        |
             |  - Registers all microservices     |
             |  - Enables load balancing          |
             +------------------+-----------------+
                             |
     -------------------------------------------------------------
     |                           |                               |
     v                           v                               v
+-------------+          +----------------+           +-----------------+
|  API-1      |          |    API-2       |           |   Config Server |
|-------------|          |----------------|           |-----------------|
| Port: 9090  |          | Ports: 8081,   |           | Port: 8888      |
|             |          | 8082, 8083     |           | - Centralized   |
| @EnableEurekaClient |  | @EnableEurekaClient |      |   config mgmt   |
| @EnableFeignClients  |  | Feign client to 3rd API   |                 |
+----------+------------+  +-----------+--------------+-----------------+
           |                           |               
           |                           v
           |                  +------------------+
           |                  | 3rd Party API(s) |
           |                  +------------------+
           |
   ------------------------------
   |            |              |
   v            v              v
+------+    +---------+    +----------------+
|Redis |    |  Kafka  |    | Admin Server   |
|Port: |    |Port:9092|    | Port: 1111     |
|Cache |    |Message Q|    | Monitors Apps  |
+------+    +---------+    +----------------+
                             |
                             v
                      +---------------+
                      | Zipkin Server |
                      | Port: 9411    |
                      | Distributed   |
                      | Tracing       |
                      +---------------+

-Filter-->If we want to perform operation before processing your request then we use filer

@Component
public class MyFilter implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        System.out.println(">>> Request Info <<<");
        System.out.println("Method: " + request.getMethod());
        System.out.println("URI: " + request.getRequestURI());
        System.out.println("Headers:");

        Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            System.out.println(headerName + ": " + request.getHeader(headerName));
        }

        // Continue the chain
        chain.doFilter(request, response);

        System.out.println("<<< Response Status: " + response.getStatus());
    }
}


--Reactive Based API Gateway
<dependencies>
        <!-- Spring Cloud Gateway (Reactive) -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <!-- Eureka Client -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>

        <!-- Actuator for monitoring -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Devtools (optional) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
    </dependencies>

application.yml
----------------
server:
  port: 2222

spring:
  application:
    name: 46-sbms-reactive-apigateway

  main:
    web-application-type: reactive  # ‚úÖ WebFlux for reactive gateway

  cloud:
    gateway:
      routes:
        - id: greet-api
          uri: lb://43-GREET-API
          predicates:
            - Path=/greet/**
        - id: welcome-api
          uri: lb://44-WELCOMEAPI-INTERSERVICECOMMUNICATION-MONITOR
          predicates:
            - Path=/welcome/**
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka
    register-with-eureka: true
    fetch-registry: true
  instance:
    prefer-ip-address: true

management:
  endpoints:
    web:
      exposure:
        include: '*'
  endpoint:
    health:
      show-details: always

logging:
  level:
    org.springframework.cloud.gateway: TRACE
---------------------------------------------

@Component
public class CustomGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        System.out.println(">> Filter Execution Started::: ");
        ServerHttpRequest request =exchange.getRequest();
        RequestPath path = request.getPath();
        System.out.println(">> Pre Filter: "+path);
        System.out.println("--------------------------------------------");
        HttpHeaders headers = request.getHeaders();
        Set<String> keySet = headers.keySet();
        for(String key: keySet) {
        	System.out.print(key+" ");
        	System.out.println(headers.getValuesAsList(key));
        	
        }
        // Call the next filter in the chain
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            // Post Filter logic
            System.out.println("<< Post Filter: " + exchange.getResponse().getStatusCode());
        }));
    }

    @Override
    public int getOrder() {
        return -1; // Precedence, lower = higher priority
    }
}


---Redis Cache
 Database = Static tables + non-static tables
 Connecting with db = Load Driver, create connection, execute query, process data, close connection (Costly operation as it takes time, performance reduces)
 Instead we can store static data in cache and call db for dynamic data
 --Cache-->Temporary storage in key-value format. By using it we can reduce no of db calls
 
Redis--> Open source, In Memory database store. It can be used as a DB,Cache, Streaming engine and message broker.
Install Redis Server in PC
Java application is client for REDIS(default port: 6379)
dependency-->springboot-starter-redis---->JedisConnFactory class(To connect with Redis server)
Configuration of Redis we will set to JedisConnFactory class object(injected in RedisTemplate Class)
--We will use below components to communicate with Redis Server
-RedisConnectionFactory: It represents connection with Redis Server
-RedisTemplate: It provides method to perform operations with Redis Server
-OpsForHash: It is providing methods to perform operations based on Hash Key(CRUD Operations)
 put(..),get(..),entries(..),delete(..)
Example:  user:123:profile   ‚Üí  { "id":123, "name":"Rohit", "role":"Admin"}--->123(key):profile(table)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    üöÄ SPRING BOOT APPLICATION ARCHITECTURE             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                        ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                            ‚îÇ
‚îÇ   ‚îÇ     CONTROLLER LAYER  ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Handles HTTP calls ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Delegates to       ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ    Service Layer      ‚îÇ                                            ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                            ‚îÇ
‚îÇ              ‚îÇ                                                         ‚îÇ
‚îÇ              ‚ñº                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                            ‚îÇ
‚îÇ   ‚îÇ      SERVICE LAYER    ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Contains business  ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ    logic              ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Uses caching       ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ    annotations:       ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ     - @Cacheable      ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ     - @CachePut       ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ     - @CacheEvict     ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ     - @Caching        ‚îÇ                                            ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                            ‚îÇ
‚îÇ              ‚îÇ                                                         ‚îÇ
‚îÇ              ‚ñº                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                            ‚îÇ
‚îÇ   ‚îÇ    REPOSITORY LAYER   ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Interacts with DB  ‚îÇ                                            ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Executes queries   ‚îÇ                                            ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                            ‚îÇ
‚îÇ              ‚îÇ                                                         ‚îÇ
‚îÇ              ‚ñº                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ   ‚îÇ           üß† SPRING CACHE MANAGER (Redis Backend)             ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Central cache abstraction layer                           ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Connects Spring Cache ‚Üí Redis                             ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ                                                              ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ  Cache Operations via Annotations:                     ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ   @Cacheable  ‚Üí Read from cache                        ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ   @CachePut   ‚Üí Update cache after method execution    ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ   @CacheEvict ‚Üí Remove outdated cache entries          ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ   @Caching    ‚Üí Combine multiple cache actions         ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ     ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ              ‚îÇ                                                         ‚îÇ
‚îÇ              ‚ñº                                                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ   ‚îÇ    üîß REDIS TEMPLATE / CACHE WRITER COMPONENTS                ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚Ä¢ Handles communication between Cache Manager & Redis       ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ                                                              ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ Key Serializer‚îÇ Value Serializer‚îÇ Data Serializer       ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îÇ (e.g. String) ‚îÇ (e.g. JSON)    ‚îÇ (Object Mapping)      ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ     ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ              ‚îÇ                                                         ‚îÇ
‚îÇ              ‚ñº                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      üß± REDIS SERVER (In-Memory Cache)                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚Ä¢ High-performance in-memory key-value store                          ‚îÇ
‚îÇ  ‚Ä¢ Stores serialized JSON or Java objects                              ‚îÇ
‚îÇ  ‚Ä¢ Supports multiple data structures:                                  ‚îÇ
‚îÇ     - Strings                                                          ‚îÇ
‚îÇ     - Hashes                                                           ‚îÇ
‚îÇ     - Lists                                                            ‚îÇ
‚îÇ     - Sets / Sorted Sets                                               ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  Example Entries:                                                      ‚îÇ
‚îÇ     user:123:profile   ‚Üí  { "id":123, "name":"Rohit", "role":"Admin"}  ‚îÇ
‚îÇ     product:456:detail  ‚Üí  { "id":456, "price":4999, "stock":30 }      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Client  ‚îÇ ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Controller ‚îÇ ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Service    ‚îÇ ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ @Cacheable   ‚îÇ
‚îÇ  Request ‚îÇ     ‚îÇ   Layer    ‚îÇ     ‚îÇ   Layer     ‚îÇ     ‚îÇ   Method     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                               ‚îÇ
                                                               ‚ñº
                                                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                                     ‚îÇ   Check Redis    ‚îÇ
                                                     ‚îÇ      Cache       ‚îÇ
                                                     ‚îÇ                  ‚îÇ
                                                     ‚îÇ   Data Found?    ‚îÇ
                                                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                             ‚îÇ
                                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                           ‚îÇ                                   ‚îÇ
                                         Yes                                   No
                                           ‚îÇ                                   ‚îÇ
                                           ‚ñº                                   ‚ñº
                             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                             ‚îÇ Return cached data ‚îÇ              ‚îÇ   Query Database   ‚îÇ
                             ‚îÇ    (Fast access)   ‚îÇ              ‚îÇ  (Fetch from DB)   ‚îÇ
                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                       ‚îÇ                                   ‚îÇ
                                       ‚îÇ                                   ‚ñº
                                       ‚îÇ                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                       ‚îÇ                        ‚îÇ  Store in Redis    ‚îÇ
                                       ‚îÇ                        ‚îÇ      Cache         ‚îÇ
                                       ‚îÇ                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                       ‚îÇ                                   ‚îÇ
                                       ‚ñº                                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ
‚îÇ  Client  ‚îÇ ‚óÄ‚îÄ‚îÄ‚îÄ‚îÇ Controller ‚îÇ ‚óÄ‚îÄ‚îÄ‚îÄ‚îÇ  Service    ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ Response ‚îÇ     ‚îÇ   Layer    ‚îÇ     ‚îÇ   Layer     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Spring Boot Service      ‚îÇ ‚îÄ‚îÄ‚îÄ‚ñ∂   ‚îÇ  RedisTemplate<K, HK, V>  ‚îÇ ‚îÄ‚îÄ‚îÄ‚ñ∂  ‚îÇ opsForHash() (put/get/del)‚îÇ ‚îÄ‚îÄ‚îÄ‚ñ∂  ‚îÇ JedisConnectionFactory  ‚îÇ
‚îÇ  - Calls Redis operations  ‚îÇ        ‚îÇ  - High-level API for Redis‚îÇ        ‚îÇ - Hash operations          ‚îÇ        ‚îÇ - Connects to Redis   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ   server              ‚îÇ
                                                                                                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                                                                                                ‚îÇ
                                                                                                                                ‚ñº
                                                                                                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                                                                                                    ‚îÇ   Redis Server  ‚îÇ
                                                                                                                    ‚îÇ - Stores data   ‚îÇ
                                                                                                                    ‚îÇ   as Hashes     ‚îÇ
                                                                                                                    ‚îÇ key‚ÜíhashKey‚Üíval‚îÇ
                                                                                                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
--JedisConnectionFactory-----Inject into--->RedisTemplate--->OpsForHah

Example:
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>redis.clients</groupId>
			<artifactId>jedis</artifactId>
			<!--<version>5.1.5</version>--> <!-- ‚úÖ Compatible with Spring Boot 3.5.x -->
		</dependency>
		
--------------
Binding class

@Data
public class Country implements Serializable{
	
	private Integer sno;
	
	private String name;
	
	private String countryCode;

}
--------------
Redis config class

@Configuration
public class RedisConfig {
	@Bean
	public JedisConnectionFactory jedisconn() {
		JedisConnectionFactory jedis = new JedisConnectionFactory();
		//we can set redis server properties here
		/*
		 * jedis.setHostName("127.0.0.1"); jedis.setPort(6379);
		 * jedis.setPassword("yourPassword");
		 */
		return jedis;
	}
	
	@Bean
	public RedisTemplate<String, Country> redisTemplate(){         //kind of data stored in redis i.e Country type
		RedisTemplate<String, Country> rt = new RedisTemplate<>();    
		rt.setConnectionFactory(jedisconn());             //Injecting JedisConnectionFactory object here
		return rt;
	}
	
	
}
--------------
@RestController
public class CountryRestController {
	
	HashOperations<String, Integer, Country> opsForHash = null;       -----> HashOperations<key, key from table, value > opsForHash
	
	@Autowired
	public CountryRestController(RedisTemplate<String, Country> rt) {
		this.opsForHash = rt.opsForHash();
	}
	
	@PostMapping("/country")
	public String addCountry(@RequestBody Country country) {
		opsForHash.put("COUNTRIES", country.getSno(), country);
		return "Contry Added.....";
	}
	
	@GetMapping("/countries")
	public Collection<Country> getCountries() {
		Map<Integer,Country> entries = opsForHash.entries("COUNTRIES");
		Collection<Country> values = entries.values();
		return values;
	}

}

--Cloud Config Server-->When package jar/war, application.prooperties/application.yml also part of it. If property changed, need to package again(Tightly coupled)
We can externalize configuration properties by using config server. We will keep .yml in github and to load it create one app{Config server app}. When run api it 
will connect with config server and load properties(yml should match with our api/app name)
steps-->Maintain application configuration yml in github repo(app name and yml file should be same)
        Config server app will connect with GitHub repo to load all ymls
		Our APIs(Microservices) will connect with config server to load yml data based on application name.
Note: If we use config server, then we no need to repackage our application when we make some changes in properties

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        GitHub Repo         ‚îÇ  --->   ‚îÇ     Config Server App     ‚îÇ  --->   ‚îÇ      greet-api       ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  greet.yml                 ‚îÇ         ‚îÇ  (Fetches configs from    ‚îÇ
‚îÇ  welcome.yml               ‚îÇ         ‚îÇ   GitHub and serves to    ‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  admin.yml                 ‚îÇ         ‚îÇ   microservices)          ‚îÇ  --->   ‚îÇ    welcome-api       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                                               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                                                               ‚îÇ     admin-api        ‚îÇ
                                                                               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
---------------------------------------
        <dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-config-server</artifactId>
		</dependency>


@EnableConfigServer
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}

application.yml
------------
spring:
  application:
    name: 48-Config-Server-App
  cloud:
    config:
      server:
        git:
          uri: https://github.com/rohitlavate97/config_server_properties
          clone-on-start: true
server:
  port: 9090

--Config-server-client app
dependencies--> web-starter
                config-client
				dev-tools
				spring-cloud-starter-config
				


@RestController
public class WelcomeRestController {
	
	@Value("${msg}")
	private String msg;
	
	@GetMapping
	public String getWelcomeMsg() {
		return msg;
	}

}

application.yml
----------------
spring:
  application:
    name: 49-Config-Server-Client-App   # üëà The name used to fetch the correct YAML file from Config Server
  config:
    import: optional:configserver:http://localhost:9090  # üëà URL of your Config Server
server:
  port: 9091  # üëà Local port where this client (microservice) will run
  
We also can add profile also--->spring.profiles.active = dev

---Apache kafka
-Event Streaming is practice of capturing data in real time from event sources(Sources-->db,sensors,mobile devices,cloud services and software applications)
Using Event Streams, we can keep right information at right place at right time.
-Uses of Data-->Application data can be used to run analytics in real time serving various purposes like
               delivery advertisements
			   tracing abnormal user behaviors
			   displaying search based on relevance
			   showing recommendations based on previous activities
Ex: when we search product on amazon, we can see product in their apps i.e amzaon sales data to those apps(To promote business)
To share data between two applications, we need to establish pipeline between these apps(difficult)-->so we use message broker(Data stored in message queue and fb,youtube etc will take data from it)
Here webservices call is not possible, as every second data is generating

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     Amazon.in E-commerce Platform               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                   ‚îÇ                   ‚îÇ
         ‚ñº                   ‚ñº                   ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Event         ‚îÇ ‚îÇ   Product       ‚îÇ ‚îÇ   Order         ‚îÇ
‚îÇ   Producers     ‚îÇ ‚îÇ   Catalog       ‚îÇ ‚îÇ   Service       ‚îÇ
‚îÇ                 ‚îÇ ‚îÇ   Producer      ‚îÇ ‚îÇ   Producer      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                   ‚îÇ                   ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Apache Kafka Cluster                         ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ user_events ‚îÇ  ‚îÇproduct_updates‚îÇ ‚îÇorder_events ‚îÇ  ‚îÇemail_events‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ         ‚îÇ                ‚îÇ                ‚îÇ             ‚îÇ       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Partitions  ‚îÇ  ‚îÇ Partitions  ‚îÇ  ‚îÇ Partitions  ‚îÇ  ‚îÇPartitions‚îÇ‚îÇ
‚îÇ  ‚îÇ    P0-P7    ‚îÇ  ‚îÇ    P0-P5    ‚îÇ  ‚îÇ    P0-P5    ‚îÇ  ‚îÇ  P0-P3  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                   ‚îÇ                   ‚îÇ
         ‚ñº                   ‚ñº                   ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇConsumer ‚îÇ         ‚îÇConsumer ‚îÇ         ‚îÇConsumer ‚îÇ
    ‚îÇ Groups  ‚îÇ         ‚îÇ Groups  ‚îÇ         ‚îÇ Groups  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                   ‚îÇ                   ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    ‚îÇ    ‚îÇ         ‚îÇ    ‚îÇ    ‚îÇ         ‚îÇ    ‚îÇ    ‚îÇ
    ‚ñº    ‚ñº    ‚ñº         ‚ñº    ‚ñº    ‚ñº         ‚ñº    ‚ñº    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇYouTube‚îÇ‚îÇFacebook‚îÇ‚îÇLinkedIn‚îÇ‚îÇGmail ‚îÇ‚îÇNaukri‚îÇ‚îÇOthers‚îÇ‚îÇAnalytics‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò

--Types of applications by Message Flow Role
-Publishers-->Applications which store data into Apache kafka
-subscribers-->Application takes data from message queue
Note: One producer can have multiple subscribers

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Rider     ‚îÇ    ‚îÇ   Uber      ‚îÇ    ‚îÇ   Driver    ‚îÇ
‚îÇ   App       ‚îÇ    ‚îÇ  Backend    ‚îÇ    ‚îÇ   App       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ                   ‚îÇ                  ‚îÇ
      ‚îÇ 1. Book Cab       ‚îÇ                  ‚îÇ
      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ                  ‚îÇ
      ‚îÇ                   ‚îÇ                  ‚îÇ
      ‚îÇ                   ‚îÇ 2. Publish to    ‚îÇ
      ‚îÇ                   ‚îÇ    Kafka         ‚îÇ
      ‚îÇ                   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
      ‚îÇ                   ‚îÇ       ‚îÇ          ‚îÇ
      ‚îÇ                   ‚îÇ       ‚ñº          ‚îÇ
      ‚îÇ                   ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
      ‚îÇ                   ‚îÇ ‚îÇ   KAFKA     ‚îÇ  ‚îÇ
      ‚îÇ                   ‚îÇ ‚îÇ  - ride_requests‚îÇ
      ‚îÇ                   ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
      ‚îÇ                   ‚îÇ       ‚îÇ          ‚îÇ
      ‚îÇ                   ‚îÇ       ‚îÇ 3. Notify‚îÇ
      ‚îÇ                   ‚îÇ       ‚îÇ   Drivers‚îÇ
      ‚îÇ                   ‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ
      ‚îÇ                   ‚îÇ                  ‚îÇ
      ‚îÇ                   ‚îÇ 4. Driver Accepts‚îÇ
      ‚îÇ                   ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ                   ‚îÇ                  ‚îÇ
      ‚îÇ 5. Driver Assigned‚îÇ                  ‚îÇ
      ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                  ‚îÇ
      ‚îÇ                   ‚îÇ                  ‚îÇ
      ‚îÇ 6. Ride in Progress                  ‚îÇ
      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ
      ‚îÇ                   ‚îÇ                  ‚îÇ
	  
-Why messaging system?--->Messaging system provide a seamless integration between distributed applications with help of messages(i.e data is treated as messages means message in stream of data), 
collecting data from different sources in different format becomes easy.
Model-->Publish and Subscribe model

--Apache Kafka-->Distributed straming platform, used to process real time data feeds with high throughput and low latency(ex-->Flights data ,sensors data , news data etc...)
It works based on Publish and Subscribe model-->It allows Producers generate data/persist data in Apache kafka topics, and that topic can be read by any number of systems who need that data(Consumers)

Event driven microservices-->Within the project we can use 'Message Queues'
example-->While booking in uber, it will send nearest driver-->booking api generated an event, msg saved-->Listner for other api-->once event generated other api takes data
         api continuously listening to msg queue-->when message comes it takes for processing immediately(Listeners listen event, they take that message and process that msg)-->all the listeners for project

+-------------------+        +------------------------+        +----------------------+
|    Swiggy / App     | --->   |  Orchestrator Service  | --->   |     Message Queue    |
| (Places Order)    |        | (Publishes Event e.g., |        | (Kafka / RabbitMQ)   |
|                   |        | "OrderPlaced")         |        |                      |
+-------------------+        +------------------------+        +----------------------+
                                                                /          |            \
                                                               /           |             \
                                                              v            v              v
                                       +----------------+  +----------------+  +---------------------+
                                       |  db api |  |         Restaurant    |  |  Notification       |
                                       | (Consumes Msg) |  |  api           |  |  Service            |
                                       | (Save Order,   |  | (Prepare /     |  | (Sends SMS, Push)   |
                                       |  Update DB)    |  |  Update Status)|  |                     |
                                       +----------------+  +----------------+  +---------------------+

Kafka is publish/subscribe system. Behind the scenes, kafka is distributed, scales well, replicates data across brokers(servers), can survive broken downtime and much more--->NEFT Queues, Ticket queue

 +----------------------------------------------------------------------------------------------+
|                          Data Producers (Sources)                                            |
+----------------------------------------------------------------------------------------------+
|   Metrics   |     Logs     |   Transaction Data   |   IoT Data   |   App Events   |
+----------------------------------------------------------------------------------------------+
           \         |             |              |              |              /
            \        |             |              |              |             /
             \       |             |              |              |            /
              \      |             |              |              |           /
                      v             v              v              v
                                   +----------------------------+
                                   |          KAFKA             |
                                   |  (Distributed Pub/Sub Bus) |
                                   +----------------------------+
                      ^             ^              ^              ^
                     /               \             |               \
+----------------------------------------------------------------------------------------------+
|      Online Applications      |   Stream Processing Systems   |  Offline Processing Systems  | 
|  (Apache Solr, OpenTSDB etc.) |  (Samza, Spark, Storm, Flink) |  (Hadoop, Hive, etc.)       |
+----------------------------------------------------------------------------------------------+
                                        |
                                        v
                          +-------------------------------+
                          |  Analytics / Reporting Tools  |
                          |  (BI Dashboards, Monitoring)  |
                          +-------------------------------+

Kafka Advantages-->High Throughput(Support for 100's of messages),scalability(No downtime), No data loss, Durability, Replication(Message can be replicated across clusters, which supports multiple subscribers)

--Kafka Core API-->Producer API
                   Consumer API
                   Streams API---------->To create pipeline of streams of data
                   Connector API-------->If app wants to store data in queue-->1st app should connect to queue(i.e connector api)

--Kafka Installation-->
   Download and Run zookeeper
   Download and run apache kafka server
   Create topic(buckets in message queue) in apache kafka--->used to differentiate messages(everything can't be stored in single topic)
   
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ                    Kafka Cluster                           ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                        Topics                            ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ                   ‚îÇ                     ‚îÇ
              ‚ñº                   ‚ñº                     ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Topic: orders  ‚îÇ   ‚îÇ Topic: payments‚îÇ   ‚îÇ Topic: logs    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                    ‚îÇ                    ‚îÇ
          ‚ñº                    ‚ñº                    ‚ñº
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ Partition 0    ‚îÇ   ‚îÇ Partition 0    ‚îÇ   ‚îÇ Partition 0    ‚îÇ
 ‚îÇ Partition 1    ‚îÇ   ‚îÇ Partition 1    ‚îÇ   ‚îÇ Partition 1    ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                    ‚îÇ                    ‚îÇ
          ‚ñº                    ‚ñº                    ‚ñº
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ Consumer Group ‚îÇ   ‚îÇ Consumer Group ‚îÇ   ‚îÇ Consumer Group ‚îÇ
 ‚îÇ (Order Service)‚îÇ   ‚îÇ (Payment App)  ‚îÇ   ‚îÇ (Logging Tool) ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

--Spring boot and Apache Kafka application steps to build
step 1--> Download zookeeper and extract zip(URL: https://zookeeper.apache.org/releases.html)
step 2--> Download Apache Kafka (URL: https://kafka.apache.org/downloads)
step 3--> set path to ZOOKEEPER in environment variables upto bin folder(system variables-->path-->%apache-zookeeper-3.8.5-bin\bin)
step 4--> start ZOOKEEPER server using below command from kafka folder
       command: zookeeper-server-start.bat zookeeper.properties
	   Note: Above command is available in kafka/bin/windows folder
	   Note: zookeeper.properties file will be available in config folder, you can copy zookeeper.properties and server.properties file from kafka/config folder to kafka/bin/windwos folder
step 5--> start kafka server using below command from kafka folder
       command: kafka-server-start.bat server.properties   -->starts kafka on zookeeper
	   Note: server.properties file available in config folder-->copy to windwos folders
step 6--> create kafka topic using below command from kafka/bin/windows folder
       command: kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partition 1 --topic 03-sbms-topic      --->(2181-->default port for zookeeper server) --->deprecated command
	   new commadn: kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic CUSTOMER
step 7--> View created tipic by below command
       command(deprecated): kafka-tipic.bat --list --zookeeper localhost:2181
	   new command: kafka-topics.bat --list --bootstrap-server localhost:9092
step 8-->create spring boot producer app

<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>

 server.port=9090

 
(Client Request)
       ‚îÇ
       ‚ñº
+-----------------+       publish       +----------------------+       consume       +-----------------+
| Spring Boot App |  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  |      Apache Kafka     |  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  | Spring Boot App |
| (Publisher)     |                    | (Broker + Topics)     |                    | (Subscriber)    |
| PORT: 9090      |                    |                      ‚ñº                     | PORT: 7070      |
+-----------------+                    |     +-------------+                        +-----------------+
                                       |     |  Zookeeper  |                       
                                       |     |-------------|                       
                                       |     | - Manages   |                       
                                       |     |   Brokers   |                       
                                       |     | - Metadata  |                       
                                       |     | - Election  |                       
                                       |     +-------------+                       
                                       +----------------------+

public class KafkaConstants {
	public static final String TOPIC = "CUSTOMER";            //need to create this topic in the kafka
	public static final String GROUP_ID = "GROUP_CUSTOMERS";
	public static final String HOST = "localhost:9092";
}
--------------------------
@Data
public class Customer {
	private Integer customerId;
	private String customerName;
	private String customerEmail;
}
----------------------------
@Service("CustomerService")
public class CustomerService {
	@Autowired
	private KafkaTemplate<String, Customer> kafkaTemplate;
	
	public String add(List<Customer> customers) {
		if(!customers.isEmpty()) {
			for(Customer c : customers) {
				kafkaTemplate.send(KafkaConstants.TOPIC, c);
				System.out.println("*****Message is published to kafka topic*****");
			}
		}
		return "Customer record is added to the Kafka-Queue successfully";
	}
}
------------------------------
@Configuration
public class KafkaProduceConfig {
	@Bean
	public ProducerFactory<String,Customer> producerFactory(){
		Map<String, Object> configProp = new HashMap<>();
		configProp.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, KafkaConstants.HOST);
		configProp.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);    //key-->TopicName
		configProp.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);    //value-->customerdata
		return new DefaultKafkaProducerFactory<>(configProp);
	}
	
	@Bean(name = "KafkaTemplate")
	public KafkaTemplate<String, Customer> kafkaTemplate(){
		return new KafkaTemplate<>(producerFactory());
	}

}
------------------
üß† What Happens

ProducerFactory:
Creates Kafka producers using the given configuration (host, serializers, etc.).
Serializers ensure that String (topic key) and Customer (JSON message) are correctly sent to Kafka.

KafkaTemplate
Provides a high-level API to send messages easily from your CustomerService.
Autowired into your service like this:

@Autowired
private KafkaTemplate<String, Customer> kafkaTemplate;


You can now publish Customer objects to Kafka topics like:
kafkaTemplate.send(KafkaConstants.TOPIC, customer);
-----------------------
step 9-->create spring boot consumer app

<dependencies>
    <!-- Spring Boot Kafka -->
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka</artifactId>
    </dependency>

    <!-- JAXB for XML binding -->
    <dependency>
        <groupId>jakarta.xml.bind</groupId>
        <artifactId>jakarta.xml.bind-api</artifactId>
    </dependency>

    <dependency>
        <groupId>org.glassfish.jaxb</groupId>
        <artifactId>jaxb-runtime</artifactId>
    </dependency>

    <!-- Lombok (optional) -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>


public class KafkaConstants {
	public static final String TOPIC ="CUSTOMER";
	public static final String GROUP_ID = "GROUP_CUSTOMER";
	public static final String HOST ="localhost:9092";

}
-----------------
@XmlRootElement(name = "customer")
@XmlAccessorType(XmlAccessType.FIELD)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Customer {
	private Integer customerId;
	private String customerName;
	private String customerEmail;
}
-----------------
@EnableKafka
@Configuration
public class KafkaListenerConfig {
	
	@Bean
	public ConsumerFactory<String, Customer> consumerFactory() {
		/*
		 * JsonDeserializer<Customer> deserializer = new
		 * JsonDeserializer<>(Customer.class); deserializer.addTrustedPackages("*"); //
		 * allow deserialization from all packages
		 */
	    Map<String, Object> props = new HashMap<>();
	    props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, KafkaConstants.HOST);
	    props.put(ConsumerConfig.GROUP_ID_CONFIG, KafkaConstants.GROUP_ID);
	    props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
	    props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
	    props.put(JsonDeserializer.TRUSTED_PACKAGES, "*");
	    return new DefaultKafkaConsumerFactory<>(props, new StringDeserializer(), new JsonDeserializer<>(Customer.class));
	}

	
	@Bean
	public ConcurrentKafkaListenerContainerFactory<String, Customer> kafkaListenerContainerFactory() {
	    ConcurrentKafkaListenerContainerFactory<String, Customer> factory = new ConcurrentKafkaListenerContainerFactory<>();
	    factory.setConsumerFactory(consumerFactory());
	    return factory;
	}
}
------------------
@Component
public class KafkaMessageListener {

    @Autowired
    private CustomerService customerService;

    @KafkaListener(topics = KafkaConstants.TOPIC, groupId = KafkaConstants.GROUP_ID,
                   containerFactory = "kafkaListenerContainerFactory")
    public void consume(Customer customer) {
        System.out.println("‚úÖ Received Customer: " + customer);
        customerService.setLastCustomer(customer);
    }
}

------------------
import com.alchemist.model.Customer;

public interface CustomerService {
    void setLastCustomer(Customer c);
    Customer getLastCustomer();
}
----------------
@Service
public class CustomerServiceImpl implements CustomerService {

    private Customer lastCustomer;

    @Override
    public void setLastCustomer(Customer c) {
        this.lastCustomer = c;
    }

    @Override
    public Customer getLastCustomer() {
        return lastCustomer;
    }
}


----------------------

@RestController
public class ConsumerRestController {

    @Autowired
    private CustomerService customerService;

    @GetMapping("/lastCustomer")
    public Customer getLastReceivedCustomer() {
        Customer c = customerService.getLastCustomer();
        if (c == null)
            throw new RuntimeException("No message received yet from Kafka topic.");
        return c;
    }

    @GetMapping("/status")
    public String getStatus() {
        return "‚úÖ Kafka Consumer is running on port 7070";
    }
}

---------------------------
spring:
  application:
    name: 51-Apache-Kafka-Consumer
  kafka:
    consumer:
      group-id: GROUP_CUSTOMER
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "com.alchemist.model"
server:
  port: 7070
---------------------------

---Circuit Breaker in MicroServices--> Design Pattern for fault tolerence(Fault tolerent applications are called Resillience applications)

Client/API  ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  Circuit Breaker  ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  Remote Service
                      ‚îÇ
                      ‚îÇ (When Open/Failed)
                      ‚ñº
                Fallback/Error Message
				
				
				
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     Request     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client     ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ Circuit Breaker   ‚îÇ
‚îÇ    / API     ‚îÇ                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ                     ‚îÇ                    ‚îÇ
                     ‚îÇ (State: CLOSED)     ‚îÇ (State: OPEN)       ‚îÇ (State: HALF-OPEN)
                     ‚îÇ Normal Operation    ‚îÇ Fast Fail           ‚îÇ Test Limited Requests
                     ‚ñº                     ‚ñº                    ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ Remote Service  ‚îÇ     ‚îÇ Fallback / Error ‚îÇ   ‚îÇ Remote Service  ‚îÇ (Test Call)
            ‚îÇ (Healthy)       ‚îÇ     ‚îÇ Message Response ‚îÇ   ‚îÇ (If Recovers)   ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò					  



 CLOSED  ---- errors threshold ---->  OPEN
   ^                                    |
   |                                    | wait ‚Üí try
   +------------ HALF-OPEN <------------+
                 |  success ‚Üí CLOSED
                 |  failure ‚Üí OPEN



					  
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     Failure     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     Timeout     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    CLOSED    ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ     OPEN     ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ  HALF-OPEN  ‚îÇ
‚îÇ              ‚îÇ                 ‚îÇ              ‚îÇ                 ‚îÇ              ‚îÇ
‚îÇ ‚Ä¢ Normal     ‚îÇ                 ‚îÇ ‚Ä¢ Fast Fail  ‚îÇ                 ‚îÇ ‚Ä¢ Test       ‚îÇ
‚îÇ ‚Ä¢ Requests   ‚îÇ                 ‚îÇ ‚Ä¢ No Requests‚îÇ                 ‚îÇ   Requests   ‚îÇ
‚îÇ   Allowed    ‚îÇ                 ‚îÇ   Allowed    ‚îÇ                 ‚îÇ ‚Ä¢ Limited    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       Ôº°                                                                    ‚îÇ
       ‚îÇ                              Success                         Failure‚îÇ
       ‚îÇ                              (All Test Requests Pass)         (Any Test Fails)
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
	   
-If service A(m1 method) communicates with service B(m2 method)-->

UI/Client ‚Üí Service A ‚Üí Service B ‚Üí Database
    ‚îÇ           ‚îÇ           ‚îÇ           ‚îÇ
    ‚îÇ           ‚îÇ           ‚îÇ           ‚îÇ
 Frontend   API Layer  Business    Data
           Gateway     Logic      Persistence
		   
    If Service B is down-->Exception, we can use try and catch block for handling the Exception. but, if 1000's of requests-->not recommended approach
	So, we should go for Circuit breaker(Used to develop fault tolerence)---->configure Circuit breaker for service B(m2 method)--->If request failing consecutively(ex-->5 times)-->then on 6th time call m3 method
	Ex-->
	@CircuitBreaker(name="", fallbackmethod="m3")
	public String m2(){
	//logic to call Service-B using RestTemplate
	return str;
	}
	public String m3(){
	//alternate logic
	}
	
-circuit-breaker-config-properties-->when to execute m2() and m3()
                                    For how many requests we need to monitor
-Circuit breaker will have below 3 states-->CLOSED,OPEN,HALF-OPEN
| State         | Meaning                                  | Behavior                                                      |
| ------------- | ---------------------------------------- | ------------------------------------------------------------- |
| **CLOSED**    | System is working normally               | Requests flow normally to downstream service                  |
| **OPEN**      | Downstream service is failing repeatedly | Requests are *blocked immediately* and fallback logic is used |
| **HALF-OPEN** | Testing if service has recovered         | Sends **limited trial requests** to check service health      |

--What is Resilience4j-->Lightweight, easy to use fault tolerence library inspired by NetFlix Hystrix.It provides various features.
        Circuit Breaker-->Fault Tolerence
		Rate Limiter-->Block too many requests
		Time Limiter-->Limit time while calling remote operations
		Retry Mechanism-->Automatic retry for failed operations
		Bulkhead-->limit number of concurrent requests
		Cache-->Store results of costly remote operations
		
--Develop applications with circuit-breaker

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
	</dependencies>
--------------------------------------------
@Data
@AllArgsConstructor
@NoArgsConstructor
public class InterestRate {
	Integer id;
	String type;
	Double rateValue;
}
---------------------------------------------
@Service
public class LoanService {
	@Autowired
	private RestTemplate restTemplate;

	private static final String SERVICE_NAME = "loan-service";
	private static final String RATE_SERVICE_URL ="http://localhost:9091/rate/{type}";
	
	@CircuitBreaker(name = SERVICE_NAME, fallbackMethod = "getDefaultLoan")
	public InterestRate getAllLoansByType(String type) {
		System.out.println("*****Original Method called...*****");
		ResponseEntity<InterestRate> response = restTemplate.getForEntity(RATE_SERVICE_URL, InterestRate.class, type);
		return response.getBody();
	}
	
	// ‚úÖ Correct fallback: Same params + Exception
	public InterestRate getDefaultLoan(String type, Exception e) {
		System.out.println("*****Fallback method called.....****");
		return new InterestRate(0, type, 7.5);  // return safe default response
	}
}

---------------------------------------
@RestController
public class LoanController {
	@Autowired
	private LoanService loanService;
	
	@GetMapping(path ="/loans")
	public ResponseEntity<InterestRate> getLoansByType(@RequestParam("type") String type){
		return ResponseEntity.ok().body(loanService.getAllLoansByType(type.toUpperCase()));
	}
}
---------------------------------------
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
	
	@Bean
	public RestTemplate restTemplate() {
		return new RestTemplate();
	}

}
---------------------------------------------
application.yml
---------------------------------------------
server:
  port: 9090

spring:
  application:
    name: 52-Circuit_breaker-LoanService
  datasource:
    url: jdbc:h2:mem:cb-loan-db
    username: root
    password: 123
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
    database-platform: org.hibernate.dialect.H2Dialect
  h2:
    console:
      enabled: true

management:
  endpoints:
    web:
      exposure:
        include: health
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true

resilience4j:
  circuitbreaker:
    instances:
      loan-service:                           #name is the link between code and properties(must match with SERVICE_NAME)
        register-health-indicator: true
        failure-rate-threshold: 50
        minimum-number-of-calls: 5            #After sending 5 calls it evaluates how many failed
        sliding-window-type: COUNT_BASED      # COUNT_BASED or TIME_BASED
        sliding-window-size: 10              # Evaluate last 10 calls
        wait-duration-in-open-state: 10s     # Stay OPEN for 10 sec ‚Üí then go HALF-OPEN
        permitted-number-of-calls-in-half-open-state: 3  # Allow 3 test calls in HALF-OPEN
        automatic-transition-from-open-to-half-open-enabled: true
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Property Name                                               | Meaning                                             | Example                                                                |
| ----------------------------------------------------------- | --------------------------------------------------- | ---------------------------------------------------------------------- |
| `failure-rate-threshold: 50`                                | If **50% calls fail**, breaker will **OPEN**        | Out of 10 calls, if 5 fail ‚Üí OPEN state                                |
| `minimum-number-of-calls: 5`                                | Evaluate failures **only after at least 5 calls**   | Before 5 calls ‚Üí always CLOSED                                         |
| `sliding-window-type: COUNT_BASED`                          | Evaluate based on **last N calls**                  | Here N = 10                                                            |
| `sliding-window-size: 10`                                   | Looks at **last 10 calls** to decide                | If 6/10 fail ‚Üí failure rate = 60% ‚Üí OPEN                               |
| `wait-duration-in-open-state: 10s`                          | Stay in **OPEN state for 10 seconds**               | During this time ‚Üí **no calls go to actual service**, fallback is used |
| `permitted-number-of-calls-in-half-open-state: 3`           | While HALF-OPEN, allow **3 test calls**             | If they succeed ‚Üí go to **CLOSED**                                     |
| `automatic-transition-from-open-to-half-open-enabled: true` | Automatically move to HALF-OPEN after wait duration | After 10 seconds, allow 3 test calls                                   |

---------------------------------------------------------------------------
--Develop rate-service
---------------------------------------------------------------------------


<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>
---------------------------
@Data
@AllArgsConstructor
@NoArgsConstructor
public class InterestRate {
	private Integer id;
	private String type;
	private Double rateValue;
}
--------------------------
@RestController
@RequestMapping("/rate")
public class RateController {

    @GetMapping("/{type}")
    public ResponseEntity<InterestRate> getRateByType(@PathVariable("type") String type) {

        System.out.println("****** Rate Service Called ******");

        if(type.equalsIgnoreCase("HOME")) {
            return ResponseEntity.ok(new InterestRate(101, "HOME", 7.5));
        }
        else if(type.equalsIgnoreCase("PERSONAL")) {
            return ResponseEntity.ok(new InterestRate(102, "PERSONAL", 11.2));
        }
        else if(type.equalsIgnoreCase("CAR")) {
            return ResponseEntity.ok(new InterestRate(103, "CAR", 9.0));
        }

        // Simulate service failure on unknown types
        throw new RuntimeException("Rate not found for type: " + type);
    }
}
--------------------------
server:
  port: 9091

spring:
  application:
    name: 52-Rate-Service
--------------------------


--Spring Security-->
-----------------
-Authentication(Verifying Credentials) + Authorization(User Access specific functionality)
Note:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
-When we add this dependency in pom.xml file, then by default our application will be secured with basic authentication. It will generate random password to access our application.When we access our application url in browser then,it 
will display 'Login Form' to authenticate our request.In order to access Secured REST API from Postman, we need to set Auth values in postman to send request.
    Auth: Basic Auth
	UserName: User
	Password: <Copy-from-console>
	
-When Secured REST-API available, we need to pass credentials in the Header(key-value) of Client.
-To override default credentials, we can configure security credentials in applicaion.properties/application.yml like below,
spring.security.user.name=admin
spring.security.user.password=password
#spring.security.user.roles=USER,ADMIN
-->Enter above username and password in Postman header to access the REST API

--Securing specific URL Pattern-->
-------------------------------
When we add securiry-starter--> it will apply security filter to all HTTP methods of our application. But in reality, we need to secure only few methods not all methods in our app-->Cusotmize security configuration
Ex: For banking application
    /login---> Security not needed
	/transfer--> Security required
	/balance---> Security required
	/about-us---> Security not required

@Configuration
@EnableWebSecurity
public class SecurityConfigurer{
     @Bean
	 public SecurityFilterChain securityFilter(HttpSecurity http) throws Exception{
	   http.authorizeHttpRequests(request)->request
	                             .antMatchers("/","/login","/about","/swagger-ui.html")
								 .permitAll()
								 ).formLogin();
	   return http.build();
	}
}

-Develop app
@RestController
public class SecurityRestController {
	@GetMapping("/hi")
	public String sayHi() {
		return "Hi, How are you?";
	}
	
	@GetMapping("/hello")
	public String sayHello() {
		return "Hello, how are you?";
	}
	
	@GetMapping("/contact")
	public String getContact() {
		return "Call us::+918600852978";
	}
}

@Configuration
@EnableWebSecurity
public class SecurityConfigurer {
	@Bean                                                                           //called when application is started
	public SecurityFilterChain securityFilter(HttpSecurity http) throws Exception{
		System.out.println("Security Filter Called.....");
		//Customize Security
		http.authorizeHttpRequests((req) ->
		//req.antMatchers("/contact").permitAll()       //deprecated
		req.requestMatchers("/contact").permitAll()                         //any request matches with this pattern will be permited
		.anyRequest().authenticated()                                       //else authenticated by user form login 
		).formLogin();
		return http.build();
	}
}

application.properties
spring.application.name=54-Spring-Securiry-App
spring.security.user.name=admin
spring.security.user.password=admin@123
server.port=9090
----------------------
-Database Authentication-->Hardcode values in application.properties not recommended, but real time app will be available in db,internally code is executed by spring security. Only if right credentials provided,
then it will allow to access the page
-Their is predefined class in the spring security named User. So whatever credetials in application.properties, loaded to User Object by Spring Security.


+-----------------------------------+                   +---------------------------------------------------------------+                    +--------------------------------------------+
|  Login Page                       | --------------->  |                     SPRING SECURITY FLOW                     | --------------->    |      application.properties                |
|                                   |                   |---------------------------------------------------------------|                    |--------------------------------------------|
| Username: [__________]            |                   |  +-------------+       +--------------------+     +----------+|                    | user.name = abhi                           |
| Password: [__________]            |                   |  |    User     | --->  | UserDetailsService | --> |AuthManager||                    | user.pwd  = abc@123                        |
| [ Login Button ]                  |                   |  +-------------+       +--------------------+     +----------+|                    +--------------------------------------------+
+-----------------------------------+                   +---------------------------------------------------------------+



                +---------------------------+
                |   User Sends Login Data   |
                |  (username + password)    |
                +------------+--------------+
                             |
                             v
             +-------------------------------------+
             | UsernamePasswordAuthenticationFilter|
             | (Intercepts login request)          |
             +----------------+--------------------+
                              |
                              v
              +--------------------------------+
              | AuthenticationManager.authenticate() |
              +----------------+-----------------+
                               |
                               v
                 +---------------------------------+
                 | AuthenticationProvider (DAO)    |
                 |   -> DaoAuthenticationProvider  |
                 +----------------+----------------+
                                  |
                                  v
                 +----------------------------------+
                 | UserDetailsService.loadUserByUsername() |
                 |  (Loads User from DB)                    |
                 +----------------+-------------------------+
                                  |
                                  v
                  +----------------------------------+
                  | UserDetails (Wrapper of User)    |
                  | Provides username, password, roles|
                  +----------------+-----------------+
                                  |
                                  v
               +-------------------------------------+
               | PasswordEncoder.matches(raw, hash)  |
               | Verifies password from DB           |
               +----------------+--------------------+
                                |
                                v
              +-------------------------------------+
              | If success ‚Üí returns Authentication  |
              | object (contains principal + roles)  |
              +----------------+--------------------+
                               |
                               v
             +--------------------------------------+
             | SecurityContextHolder.setContext()   |
             | (Stores authenticated user globally)  |
             +----------------+---------------------+
                              |
                              v
               +-----------------------------------+
               | User is now Authenticated ‚úÖ       |
               | Can access protected endpoints     |
               +-----------------------------------+
Authmanager(Predefined interface)-->to load data User Object, it will use UserDetailsService, which acts as a mediator between User Object and Authmanager
so we have to configure AuthManager, so that it can check credentials in db, not in properties file

--Spring boot app with JDBC Authentication:-->
-------------------------------------------
step 1--> create user and authorities table
    
CREATE TABLE `users` (
  `username` VARCHAR(50) NOT NULL,
  `password` VARCHAR(120) NOT NULL,
  `enabled` TINYINT(1) NOT NULL,
  PRIMARY KEY (`username`)
);

CREATE TABLE `authorities` (
  `username` VARCHAR(50) NOT NULL,
  `authority` VARCHAR(50) NOT NULL,
  KEY `username` (`username`),
  CONSTRAINT `authorities_ibfk_1` FOREIGN KEY (`username`)
    REFERENCES `users` (`username`)
);
-->contains user roles data

step 2--> insert record into tables

insert into users values('admin','$2a$12$LlOKsem5HNKzdI.xjycFRebyRjzdIhVrdXuehk8du7272j1ILl1Ki',1);     <----decrypt --password=admin@123--->
insert into users values('user','$2a$12$9Y5BFUvctEQj5jPtAX5NIuH1AUr0AROiklwjUjuI8yC0d1O2d3nQC',1);

insert into authorities values('admin','ROLE_ADMIN');
insert into authorities values('admin','ROLE_USER');
insert into authorities values('user','ROLE_USER');

--Add dependency in pom.xml
<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

step 3--> Configure application.yml
spring:
  application:
    name: 55-JDBC-Authentication-App
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    url: jdbc:mysql://localhost:3306/sbms?createIfNotExists
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update

step 4-->create REST controller

@RestController
public class UserController {
	@GetMapping("/admin")                //method accessed by admin only
	public String admin() {
		return "<h3>Welcome Admin:)</h3>";
	}
	
	@GetMapping("/user")                //method accessed by User only
	public String user() {
		return "<h3>Hello User:)</h3>";
	}
	@GetMapping(value="/")              //Anybody can access this method
	public String welcome() {
		return "Welcome:)";
	}
}

step 5--> create SecurityConfiguration class with JDBC Authentication manager

@Configuration
@EnableWebSecurity
public class SecurityConfigurator {
	
	private static final String ADMIN = "ADMIN";
	private static final String USER ="USER";
	
	@Autowired
	private DataSource dataSource;          //To get credentials from db
	
	@Autowired
	public void authManager(AuthenticationManagerBuilder auth) throws Exception{
		auth.jdbcAuthentication()
		  .dataSource(dataSource)
		  .passwordEncoder(new BCryptPasswordEncoder())
		  .usersByUsernameQuery("select username,password,enabled from users where username=?")
		  .authoritiesByUsernameQuery("select username,authority from authorities where username=?");	  
	}
	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((req) ->
		             req.requestMatchers("/admin/**").hasRole(ADMIN)
		             .requestMatchers("/user/**").hasAnyRole(ADMIN,USER)
		             .requestMatchers("/").permitAll()
		             .anyRequest().authenticated()
		             ).formLogin();
		return http.build();
	}

}

Note : For Authentication Manager, we have given datasource, password encoder and query to load the data. It will retrieve data from db and authenticate

--InMemory Authentication
-------------------------
<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
</dependencies>
	
@RestController
public class MsgRestController {
	
	@GetMapping("/greet")
	public String greetMsg() {
		return "Good Evening--> :)";
	}
	
	@GetMapping("/welcome")
	public String welcomeMsg() {
		return "Welcome to our Application... :)";
	}
	
	@GetMapping("/contact")
	public String getContact() {
		return "Contact: +918600852978";
	}
	
	@GetMapping("/")
	public String homePage() {
		return "Hi";
	}

}



@Configuration
@EnableWebSecurity
public class SecurityConfigurer {
	
	@Bean
	public InMemoryUserDetailsManager configureUsers() {
		UserDetails adminUser = User.withDefaultPasswordEncoder()
				                    .username("Rohit")
				                    .password("admin@123")
				                    .authorities("ADMIN")
				                    .build();
		
		UserDetails normalUser = User.withDefaultPasswordEncoder()
                .username("Pramod")
                .password("pramod@123")
                .authorities("USER")
                .build();
		return new InMemoryUserDetailsManager(adminUser,normalUser);
	}
	
	  @Bean
	  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
	        http.authorizeHttpRequests((req) -> req
	                .requestMatchers("/", "/contact")
	                .permitAll()
	                .anyRequest().authenticated()
	            )
	            .formLogin();  // enables Spring Security login form
	        
	        return http.build();
	    }
}
----------------------------
-How to work with UserDetailsService in Spring Security
----------------------------
AuthManager is responsible to perform authentication in spring security, to perform authentication we need to load User data. To load User data UserDetailsService class method. loadUseryByName() is available,
which laods data from db or properties file 


[1] Login Form (Username + Password)
        |
        v
        ‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí‚Üí
        |  User submits credentials to Spring Security filter chain
        |
        v
[2] UsernamePasswordAuthenticationFilter
        |
        | Extracts username & password ‚Üí sends to AuthenticationManager.authenticate()
        v
[3] AuthenticationManager
        |
        | Delegates authentication to AuthenticationProvider (e.g., DaoAuthenticationProvider)
        v
[4] DaoAuthenticationProvider
        |
        | Calls ‚Üí UserDetailsService.loadUserByUsername(username)
        v
[5] UserDetailsService
        |
        | Fetches user from DB via UserRepository
        v
[6] UserRepository --------------> [7] Database (users, authorities tables)
                                      |
                                      | Returns User entity (username, password, roles)
                                      v
        <----------------------------- User entity returned to UserDetailsService
        |
        v
[8] UserDetails (Wrapper object around User)
        |
        | Returned to DaoAuthenticationProvider
        v
[9] DaoAuthenticationProvider
        |
        | Compares raw password with encrypted password via PasswordEncoder.matches()
        | If match ‚Üí creates Authentication object (Principal + Authorities)
        v
[10] AuthenticationManager
        |
        | Returns fully authenticated Authentication object
        v
[11] SecurityContextHolder.setContext(Authentication)
        |
        v
[12] ‚úÖ Authentication Successful ‚Äî User logged in
        |
        v
[13] User can now access protected endpoints based on roles (e.g., /admin, /user)



                     ----------------------
       2             |        3            |
   AuthManager <---->| UserDetailsService  | 4
      ^            6 | (loadUserByName())  |---------------------> UserRepo --> DB
      |              -----------------------                         
      |                        |                                       
      |                        v 5                                      
   -------                 +--------+                                  
  |   1   |                |  User  |                                  
  | Form  |                +--------+                                  
  |       |                                              
   -------   
   
-UserDetailsService is a predefined interface which contains loadUserByName(String name) method. This is used to load User record for Authentication purpose.
We can implement UserDetailsService interface and we can write the logic to retrieve User record for Authentication purpose. If we give UserDetailsService object to
AuthenticationManagerBuilder, then AuthManager will call this method for every login request.

--Custom UserDetailsService
------------------------------
@RestController
public class MsgController {
	@GetMapping("/")
	public String welcomeMsg() {
		return "Welcome";
	}
	@GetMapping("/hi")
	public String hiMsg() {
		return "Hi";
	}
	@GetMapping("/hello")
	public String helloMsg() {
		return "Hello";
	}
}

------
@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        System.out.println("......Called.........");
        
        // Encode password with BCrypt
        String encodedPassword = "$2a$12$.TWaQyWEMQ9y3CK7r.alauD97fF2d/rsgNhrhd2H8m5YgnPH4SYYO"; // encoded "admin@123"---->https://bcrypt-generator.com/
        
        return new User("Rohit", encodedPassword, Collections.emptyList());
    }
}
-------
import static org.springframework.security.config.Customizer.withDefaults;
@Configuration
@EnableWebSecurity
public class SecurityConfigurer {

    @Autowired
    private CustomUserDetailsService userDetailsService;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/").permitAll()  // Allow root without authentication
                .anyRequest().authenticated()
            )
            .formLogin(withDefaults())   // enables form-based login with default login page
            .httpBasic(withDefaults());  // enables basic authentication with default settings

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {      // needed for Custom login controller / JWT / manual authentication
        return config.getAuthenticationManager();
    }

    // Use BCrypt instead of NoOpPasswordEncoder
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        
        // Add debug prints
        System.out.println("Authentication Provider Setup:");
        System.out.println("UserDetailsService: " + userDetailsService);
        System.out.println("PasswordEncoder: " + passwordEncoder());
        
        return provider;
    }
}
------
--At start of application, @Configuration classes will be loaded and methods will be executed when @Bean is mentioned
SecurityFilterChain ‚Üí contains multiple filters
     ‚Üì
SecurityContextPersistenceFilter ‚Üí manages SecurityContext lifecycle
     ‚Üì
SecurityContext ‚Üí holds Authentication (the logged-in user)


                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ SecurityFilterChain  ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Loging Form--->‚îÇ     AuthManager      ‚îÇ------------------> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               |                                           ‚îÇ      Authentication Sources (any one or combination)   ‚îÇi.e default or yml file or InMemory auth or JdbcAuth or UserDtlsvc
                                                           ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ UserDetailsService   ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                      ‚îÇ  User  ‚îÇ
                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
					  
1Ô∏è‚É£ SecurityFilterChain

Every HTTP request first passes through the SecurityFilterChain.It decides whether the request needs authentication or can be accessed publicly.If it needs authentication, the request is forwarded to the AuthenticationManager.

2Ô∏è‚É£ Login Form ‚Üí AuthManager

When the user enters their username and password in the login form and submits it,the credentials are sent to the AuthenticationManager.The AuthManager acts like a central brain that decides how to validate those credentials.

3Ô∏è‚É£ AuthManager ‚Üí Authentication Sources

The AuthManager checks where authentication information should come from:A default user auto-generated by Spring Boot,A username/password defined in application.yml or application.properties,

An in-memory configuration (like your InMemoryUserDetailsManager),A database using JDBC authentication,Or a custom implementation of UserDetailsService.

4Ô∏è‚É£ UserDetailsService

If using a database or custom logic, the AuthManager delegates to the UserDetailsService.UserDetailsService.loadUserByUsername(username) retrieves the user‚Äôs record.It returns a UserDetails object containing:

username,

password (usually encrypted),

roles/authorities (e.g., ROLE_ADMIN, ROLE_USER).

5Ô∏è‚É£ User

The actual user data object that represents authenticated identity.If the password matches and account is enabled, Spring Security authenticates the user.
UsernamePasswordAuthenticationToken is created and stored in the SecurityContext.After that, the user can access protected endpoints.
--------------------------------------------------------------------
--OAuth 2.0
-------------
Register a User--->Use 3rd party like Google account,Facebook account,GitHub Account etc
-It is industry standard protocol for Authentication. OAuth 2.0 focus on client developer simplicity, while providing specific authorization flows for web applicationss, desktop apps, mobile phones and living rooms devices. 
This specification and its extensions are being developed within the IETF OAuth working group(OAuth.net/2)

                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                          ‚îÇ        User (Client)     ‚îÇ
                          ‚îÇ   (Wants to access app)  ‚îÇ
                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                        ‚îÇ
                                        ‚ñº
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ 1Ô∏è‚É£ Authorization Request           ‚îÇ
                     ‚îÇ User tries to log in via Google,   ‚îÇ
                     ‚îÇ GitHub, etc.                       ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                                   ‚ñº
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ 2Ô∏è‚É£ Authorization Server (e.g. Google) ‚îÇ
                     ‚îÇ Shows "Allow access?" consent screen ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                                   ‚ñº
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ 3Ô∏è‚É£ User Grants Permission           ‚îÇ
                     ‚îÇ Authorization Code sent back to     ‚îÇ
                     ‚îÇ Client Application (Redirect URI)   ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                                   ‚ñº
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ 4Ô∏è‚É£ Client App Exchanges Code        ‚îÇ
                     ‚îÇ Sends Authorization Code + Secret   ‚îÇ
                     ‚îÇ to Token Endpoint                   ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                                   ‚ñº
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ 5Ô∏è‚É£ Authorization Server verifies     ‚îÇ
                     ‚îÇ and responds with Access Token      ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                                   ‚ñº
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ 6Ô∏è‚É£ Client App uses Access Token     ‚îÇ
                     ‚îÇ to call Resource Server API         ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                                   ‚ñº
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ 7Ô∏è‚É£ Resource Server verifies token    ‚îÇ
                     ‚îÇ and returns protected data          ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

| Step                          | Actor                                                  | Description                                                                              |
| ----------------------------- | ------------------------------------------------------ | ---------------------------------------------------------------------------------------- |
| **1Ô∏è‚É£ Authorization Request** | **Client App ‚Üí Authorization Server**                  | The user clicks "Login with Google". The app redirects to Google‚Äôs OAuth login endpoint. |
| **2Ô∏è‚É£ Login & Consent**       | **User ‚Üí Authorization Server**                        | The user logs in and allows the app to access their profile/email.                       |
| **3Ô∏è‚É£ Authorization Code**    | **Authorization Server ‚Üí Client App**                  | The server sends an **authorization code** (short-lived) to the app‚Äôs redirect URI.      |
| **4Ô∏è‚É£ Token Request**         | **Client App ‚Üí Authorization Server (Token Endpoint)** | The app exchanges the authorization code + client secret for an **access token**.        |
| **5Ô∏è‚É£ Access Token Issued**   | **Authorization Server ‚Üí Client App**                  | The server returns an **access token** (and optionally a refresh token).                 |
| **6Ô∏è‚É£ Access Resource**       | **Client App ‚Üí Resource Server (API)**                 | The app calls a protected resource API using the **Bearer token**.                       |
| **7Ô∏è‚É£ Data Returned**         | **Resource Server ‚Üí Client App**                       | The API verifies the token and returns user data.                                        |



     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ               ‚îÇ            ‚îÇ                              ‚îÇ            ‚îÇ                       ‚îÇ            ‚îÇ                        ‚îÇ
     ‚îÇ     User      ‚îÇ            ‚îÇ     Client Application        ‚îÇ            ‚îÇ  Authorization Server  ‚îÇ            ‚îÇ    Resource Server      ‚îÇ
     ‚îÇ (Resource     ‚îÇ            ‚îÇ  (e.g., your web/mobile app)  ‚îÇ            ‚îÇ (e.g., Google, Auth0)  ‚îÇ            ‚îÇ   (API hosting data)    ‚îÇ
     ‚îÇ  Owner)       ‚îÇ            ‚îÇ                              ‚îÇ            ‚îÇ                       ‚îÇ            ‚îÇ                        ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ 1Ô∏è‚É£ Click "Login with Google"     ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ 2Ô∏è‚É£ Redirect to Auth Server (Login Page) ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ            3Ô∏è‚É£ User logs in, grants access                              ‚îÇ
            ‚îÇ                                  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ 4Ô∏è‚É£ Auth Server sends Authorization Code ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ 5Ô∏è‚É£ Client exchanges Code for Access Token                               ‚îÇ
            ‚îÇ                                  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ             6Ô∏è‚É£ Access Token returned    ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ 7Ô∏è‚É£ Client calls API using Bearer Token  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ         8Ô∏è‚É£ API verifies token   ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ   Returns Protected Resource ‚úÖ  ‚îÇ
            ‚îÇ                                  ‚îÇ                                         ‚îÇ                                 ‚îÇ

| Step | Flow                              | Description                                                           |
| ---- | --------------------------------- | --------------------------------------------------------------------- |
| 1Ô∏è‚É£  | User ‚Üí Client App                 | User clicks ‚ÄúLogin with Google‚Äù.                                      |
| 2Ô∏è‚É£  | Client App ‚Üí Authorization Server | Redirect to Google‚Äôs OAuth endpoint.                                  |
| 3Ô∏è‚É£  | User ‚Üí Authorization Server       | User logs in and grants consent.                                      |
| 4Ô∏è‚É£  | Authorization Server ‚Üí Client App | Authorization **Code** returned to app.                               |
| 5Ô∏è‚É£  | Client App ‚Üí Authorization Server | App exchanges code for **Access Token** (and optional Refresh Token). |
| 6Ô∏è‚É£  | Authorization Server ‚Üí Client App | Token is issued.                                                      |
| 7Ô∏è‚É£  | Client App ‚Üí Resource Server      | Token used to request protected resource.                             |
| 8Ô∏è‚É£  | Resource Server ‚Üí Client App      | Token validated and resource returned. ‚úÖ                              |


     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îêclient-id + ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        
     ‚îÇ             ‚îÇ----------->‚îÇ                              ‚îÇ           
     ‚îÇHackerRank   ‚îÇ client-secret                             ‚îÇ 
	 ‚îÇ             ‚îÇ            ‚îÇ                              ‚îÇ 
     ‚îÇ (Resource   ‚îÇ<-----------‚îÇ             GitHub           ‚îÇ           
     ‚îÇ  Owner)     ‚îÇ Token      ‚îÇ                              ‚îÇ     
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ                              ‚îÇ
       ‚îÇ    ^                   ‚îÇ                              ‚îÇ------>DB	 
	   ‚îÇ 	‚îÇ 					‚îÇ                              ‚îÇ
	   ‚îÇ	‚îÇ				    ‚îÇ                              ‚îÇ
	   ‚îÇ 	‚îÇ	Login Page	    ‚îÇ                              ‚îÇ
	   V	‚îÇ   <---------------‚îÇ                              ‚îÇ
		End User--------------->‚îÇ                              ‚îÇ
				 Login creds	‚îÇ                              ‚îÇ
								‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        
 
‚úÖExplanation

When a user clicks ‚ÄúSign up with GitHub‚Äù on HackerRank:
-Redirect to GitHub (Authorization Server):HackerRank redirects the user to GitHub‚Äôs authorization page, including parameters like
client_id (assigned to HackerRank by GitHub),
redirect_uri,
scope,
and response_type=code.
These tell GitHub that the request comes from a registered third-party app (HackerRank).
-GitHub verifies the request:
GitHub checks the client_id and ensures this request comes from a valid registered application (HackerRank).It now understands this is not a direct user login, but a login on behalf of HackerRank.
-GitHub shows login page:
GitHub displays its own login page (or consent page if already logged in).The end user enters their GitHub credentials here.
GitHub (as the Authorization Server) validates the user using its own Resource Server (database).
-Authorization code returned to HackerRank:
Once authentication succeeds, GitHub asks for user consent (if needed).After approval, GitHub redirects the user back to HackerRank‚Äôs predefined redirect_uri ‚Äî
including an Authorization Code in the URL.
-HackerRank exchanges code for Access Token:
HackerRank‚Äôs backend (not the user‚Äôs browser) sends:
client_id
client_secret
the received authorization_code
to GitHub‚Äôs token endpoint.GitHub validates these and returns an Access Token (and optionally a Refresh Token).
-HackerRank uses the Access Token:
HackerRank uses this Access Token to request user profile data (like email, username) from GitHub‚Äôs Resource Server APIs ‚Äî e.g. https://api.github.com/user.
-User Dashboard Displayed:
Once HackerRank receives valid data, it creates or updates the user‚Äôs local account and shows the user dashboard (logged-in state).
----------------------------------------------------------------
---Develop Spring Boot OAuth2 app
-Add Dependencies
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-oauth2-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

-Create OAuth app in GitHub
   Login-->Settings-->Developer Setting-->OAuth Apps-->Create App-->Copy client_Id and client_secret(callback URL-->After receiving token from github which endpoint should be executed i.e which page should be displayed which method should be executed)
   set Authorization callback URL= http://localhost:9090/login/oauth2/code/github

@RestController
public class WelcomeRestController {
	
	
	@GetMapping("/")
	public String welcomeMsg() {
		return "Welcome to the Home Page...!";
	}
	
	@GetMapping("/greet")
	public String greetMsg() {
		return "Greeting to all of you.....!";
	}

}

spring:
  application:
    name: 58-OAuth2-GithubApp
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: mentionhere
            client-secret: mentionhere
server:
  port: 9090
---------------------------------------------------------------------
--Spring boot with JWT(JSON web token)---->https://jwt.io/
________________________
-JWTs are an open, industry standard RFC 7519 method for representing claims securely between two parties
-JWT is a compact, URL-safe way to securely transmit information between two parties ‚Äî typically a client (like a frontend app) and a server (like a Spring Boot backend) ‚Äî as a digitally signed token.
-Structure of JWT
A JWT consists of three parts, separated by dots (.):

xxxxx.yyyyy.zzzzz    i.e {Base64Url(header)}.{Base64Url(payload)}.{Base64Url(signature)}

Header ‚Üí Contains metadata about the token, such as the algorithm used (e.g., HS256) and token type (JWT).
{ "alg": "HS256", "typ": "JWT" }
Payload ‚Üí Contains user-related data (called claims), like username, roles, or expiration time.
{ "sub": "rohit", "role": "ADMIN", "exp": 1735600000 }
Signature ‚Üí Used to verify the token‚Äôs authenticity.
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

| Claim   | Meaning                            |
| ------- | ---------------------------------- |
| **iss** | Issuer ‚Äî who issued the token      |
| **sub** | Subject ‚Äî whom the token refers to |
| **aud** | Audience ‚Äî intended recipient      |
| **exp** | Expiration time                    |
| **nbf** | Not before time                    |
| **iat** | Issued at time                     |
| **jti** | Unique identifier for the token    |


-How JWT Works (Spring Boot Flow)
User logs in ‚Üí sends username & password to the server.
Server validates credentials ‚Üí if correct, it generates a JWT and returns it to the client.
Client stores the token (e.g., in localStorage or cookies).
For each request, the client sends the JWT in the Authorization header:
Authorization: Bearer <token>
Server verifies the token using the secret key ‚Äî if valid, access is granted; if invalid or expired, request is denied.

                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ          Client (UI)         ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                          (1) Send Login Request  
                         POST /authenticate (username, password)
                                   ‚îÇ
                                   ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ   Authentication Controller        ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                          (2) Pass credentials to
                              AuthenticationManager
                                   ‚îÇ
                                   ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ     AuthenticationManager           ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                      (3) Call UserDetailsService
                          to load user from DB
                                   ‚îÇ
                                   ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ        UserDetailsService           ‚îÇ
                ‚îÇ (loads user from DB, verifies pwd)  ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                           (4) Return UserDetails
                                   ‚îÇ
                                   ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ   JWT Utility / Token Provider      ‚îÇ 
                ‚îÇ (generate JWT for valid user)       ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                         (5) Return JWT Token
                                   ‚îÇ
                                   ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ          Client (UI)         ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                 (6) Send Request with JWT in Header
                     Authorization: Bearer <token>
                                   ‚îÇ
                                   ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ   JWT Authentication Filter        ‚îÇ
                ‚îÇ (intercepts request, validates JWT)‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                      (7) If valid ‚Üí Set Authentication
                                   ‚îÇ
                                   ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ    Protected REST Controller       ‚îÇ
                ‚îÇ (executes request, returns data)   ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
                          (8) Response to Client

| Step | Component          | Responsibility                         |
| ---- | ------------------ | -------------------------------------- |
| 1    | Client             | Sends username & password              |
| 2    | Controller         | Receives credentials                   |
| 3    | AuthManager        | Verifies authentication                |
| 4    | UserDetailsService | Loads user details                     |
| 5    | JWT Utility        | Generates signed token                 |
| 6    | Client             | Sends token in header for each request |
| 7    | JWT Filter         | Validates token & authorizes user      |
| 8    | Controller         | Returns secured data                   |



‚úÖ Advantages
Stateless ‚Äî no need to store session on server.
Compact ‚Äî easy to transmit in headers or URLs.
Secure ‚Äî signed (and optionally encrypted).
Widely used ‚Äî works well with REST APIs.

--Create Spring boot app with JWT Token
----------------------------------------
-Step 1: Add dependencies

In Modern Spring Boot (with JJWT 0.11.x)
JJWT switched to Jackson for JSON handling (jjwt-jackson dependency).
So no more JAXB dependency is required.
Jackson handles encoding/decoding of token payloads and signatures.
‚úÖ Therefore, if you include jjwt-jackson, you don‚Äôt need JAXB anymore.
   
<dependencies>
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Spring Boot Security -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>

    <!-- JWT (JSON Web Token) - JJWT Library by io.jsonwebtoken -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.5</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.11.5</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.11.5</version>
        <scope>runtime</scope>
    </dependency>

    <!-- (Optional) Spring Boot DevTools -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- (Optional) Lombok for concise code -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>

--‚úÖ Recommended pom.xml Test Section (Modern Setup)
<dependencies>

    <!-- Spring Boot Web + Security + JWT dependencies here -->
    <!-- (not shown for brevity) -->

    <!-- ‚úÖ Test dependencies -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
        <exclusions>
            <!-- ‚ùå Remove JUnit 4 engine -->
            <exclusion>
                <groupId>org.junit.vintage</groupId>
                <artifactId>junit-vintage-engine</artifactId>
            </exclusion>
        </exclusions>
    </dependency>

    <!-- ‚úÖ Enables JUnit 5 (Jupiter) -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <scope>test</scope>
    </dependency>

    <!-- ‚úÖ For Spring Security-specific testing (optional but recommended) -->
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>

</dependencies>

-step 2:Create Request and Response binding class

@Data
public class AuthenticationRequest {
	private String username;
	private String password;
}


public class AuthenticationResponse implements Serializable{
	private final String jwt;
	
	public AuthenticationResponse(String jwt) {
		this.jwt = jwt;
	}
	
	public String getJwt() {
		return jwt;
	}
}

-step 3: Create UserDetailsService for credentials configuration

@Service
public class CustomUserDetailsService implements UserDetailsService {

	private Map<String, String> users = Map.of(
			"rohit", new BCryptPasswordEncoder().encode("rohit@123"),
			"admin", new BCryptPasswordEncoder().encode("admin@123")
			);

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		if (!users.containsKey(username))
			throw new UsernameNotFoundException("User not found: " + username);

		String password = users.get(username);
		return User.withUsername(username).password(password).roles("USER").build();
	}
}

-step 4: JwtUtil class---->Code is used to generate the token

@Service
public class JwtUtil {

    // Must be at least 32 characters long for HS256
    private static final String SECRET_KEY = "mysecretkeythatismorethan32charslong";

    // üîπ Extract all claims from JWT
    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()                 //object helps to decode and verify JWT tokens//
                .setSigningKey(getSigningKey())     //tells Use this key to verify the token‚Äôs signature.
                .build()                            //Builds the actual JWT parser instance.
                .parseClaimsJws(token)              //Parses the JWT token string you pass in. Performs signature verification using the secret key. If valid, it returns a Jws<Claims> object
                .getBody();
    }

    // üîπ Generic method to extract any claim
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // üîπ Convert secret string to signing key
    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(SECRET_KEY.getBytes());
    }

    // üîπ Extract username (subject) from JWT
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // üîπ Extract expiration date
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // üîπ Check if token is expired
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    // üîπ Generate new JWT token for a user
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }

    // üîπ Create the token
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10)) // 10 hours
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    // üîπ Validate token
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
}


üîπ Step-by-Step Explanation of  extractAllClaims(String token) method

1Ô∏è‚É£ Jwts.parserBuilder()
   - Creates a JWT parser builder.
   - This is part of the JJWT (io.jsonwebtoken) library.
   - Think of it as an object that helps to decode and verify JWT tokens.

2Ô∏è‚É£ .setSigningKey(getSigningKey())
   - Every JWT is digitally signed with a secret key (HS256, HS512, etc.).
   - To verify that the token is authentic and untampered, you must provide 
     the same secret key that was used when generating the token.
   - So, getSigningKey() returns your key:
        private SecretKey getSigningKey() {
            return Keys.hmacShaKeyFor(SECRET_KEY.getBytes());
        }
   - This tells the parser:
     ‚ÄúUse this key to verify the token‚Äôs signature.‚Äù

3Ô∏è‚É£ .build()
   - Builds the actual JWT parser instance.
   - After this, you can use it to parse and validate JWT strings.

4Ô∏è‚É£ .parseClaimsJws(token)
   - Parses the JWT token string you pass in.
   - Performs signature verification using the secret key.
   - If the token is invalid (tampered, expired, or uses wrong signature),
     it throws exceptions like:
       ‚Ä¢ io.jsonwebtoken.SignatureException
       ‚Ä¢ io.jsonwebtoken.ExpiredJwtException
       ‚Ä¢ io.jsonwebtoken.MalformedJwtException
   - If valid, it returns a Jws<Claims> object ‚Äî a JWT split into:
       ‚Üí Header (algorithm & type)
       ‚Üí Payload / Claims (username, roles, expiry, etc.)
       ‚Üí Signature

5Ô∏è‚É£ .getBody()
   - Extracts the Claims (payload) part from the JWT.
   - Claims is essentially a Map<String, Object> containing key-value pairs like:
        {
          "sub": "admin",
          "iat": 1730324019,
          "exp": 1730367219
        }


-step 5: Filter Class

@Component
public class JwtRequestFilter extends OncePerRequestFilter {

    @Autowired
    private CustomUserDetailsService userDetailService;

    @Autowired
    private JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        // 1Ô∏è‚É£ Extract Authorization header
        final String authorizationHeader = request.getHeader("Authorization");

        String username = null;
        String jwt = null;

        // 2Ô∏è‚É£ Check for Bearer Token
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            username = jwtUtil.extractUsername(jwt);
        }

        // 3Ô∏è‚É£ Validate Token and set Authentication
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {

            UserDetails userDetails = this.userDetailService.loadUserByUsername(username);

            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());  //We set null because the password was already verified earlier ‚Äî and we never store credentials in the security context for safety reasons.

                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); //This attaches request-specific details (e.g., remote IP, session ID).Useful for security audits and context-aware authentication.

                // ‚úÖ Set the authentication in SecurityContext
                SecurityContextHolder.getContext().setAuthentication(authentication);   //It stores the authenticated user in Spring Security‚Äôs global context.
            }
        }

        // 4Ô∏è‚É£ Continue the filter chain
        filterChain.doFilter(request, response);
    }
}

-step 6: WebSecurityConfig class

@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

    @Autowired
    private JwtRequestFilter jwtRequestFilter;  // ‚úÖ your custom JWT filter

    @Autowired
    private CustomUserDetailsService customUserDetailsService;

    // 1Ô∏è‚É£ Password encoder bean
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // 2Ô∏è‚É£ AuthenticationProvider setup (links UserDetailsService + PasswordEncoder)
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(customUserDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        return provider;
    }

    // 3Ô∏è‚É£ AuthenticationManager bean (required for login/auth controller)
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    // 4Ô∏è‚É£ Main Security Filter Chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // ‚ùå Disable CSRF for stateless APIs
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/authenticate", "/register").permitAll() // ‚úÖ Public endpoints
                .anyRequest().authenticated() // üîí All other endpoints need JWT
            )
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS) // ‚úÖ No session storage
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class); // ‚úÖ Apply JWT filter

        return http.build();
    }
}

-Step 7: RestController class

@RestController
@RequestMapping("/api")
public class HelloRestController {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private CustomUserDetailsService userDetailsService;

    // ‚úÖ Test endpoint (secured)
    @GetMapping("/hello")
    public String helloUser() {
        return "Hello, User üëã ‚Äî Your JWT is valid!";
    }

    // ‚úÖ Authentication endpoint (public)
    @PostMapping("/authenticate")
    public ResponseEntity<?> createAuthenticationToken(@RequestBody AuthenticationRequest authRequest) throws Exception {
        try {
            // 1Ô∏è‚É£ Authenticate username & password
            authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(authRequest.getUsername(), authRequest.getPassword())
            );
        } catch (BadCredentialsException e) {
            throw new Exception("‚ùå Invalid username or password", e);
        }

        // 2Ô∏è‚É£ Load user details
        final UserDetails userDetails = userDetailsService.loadUserByUsername(authRequest.getUsername());

        // 3Ô∏è‚É£ Generate JWT token
        final String jwt = jwtUtil.generateToken(userDetails);

        // 4Ô∏è‚É£ Return token as JSON
        return ResponseEntity.ok(new AuthenticationResponse(jwt));
    }
}

--Go to Postman

POST http://localhost:9090/api/authenticate

{
  "username": "rohit",
  "password": "rohit@123"
}

GET ‚Üí http://localhost:8080/api/hello

Headers:
Authorization: Bearer <your-jwt-token>

| Class Name**             | **Purpose / Responsibility**                                           | **Key Methods / Functionality**                                            | **Flow Role**                                                         |
| -------------------------| ---------------------------------------------------------------------- | -------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| AuthenticationRequest    | DTO for capturing login input from user                                | Fields: `username`, `password`                                             | Receives credentials from client during login (`/authenticate`)       |
| AuthenticationResponse   | DTO for returning JWT token as JSON response                           | Constructor + `getJwt()`                                                   | Sends generated token back to client                                  |
| CustomUserDetailsService | Implements Spring Security‚Äôs `UserDetailsService` for authentication   | `loadUserByUsername()` ‚Äî loads user and encoded password from map          | Verifies user credentials and roles during authentication             |
| JwtUtil                  | Handles all **JWT generation**, **parsing**, and **validation** logic  | `generateToken()`, `extractUsername()`, `validateToken()`                  | Creates JWT after login and validates JWT in subsequent requests      |
| JwtRequestFilter         | A `OncePerRequestFilter` that intercepts requests and validates tokens | `doFilterInternal()` ‚Äî extracts, verifies JWT, and sets `SecurityContext`  | Ensures only authenticated users can access protected routes          |
| WebSecurityConfig        | Core Spring Security configuration                                     | Defines `PasswordEncoder`, `AuthenticationProvider`, `SecurityFilterChain` | Configures authentication rules, JWT filter, disables sessions & CSRF |
| HelloRestController      | REST API controller handling login and secure endpoints                | `/authenticate` ‚Üí generates JWT <br> `/hello` ‚Üí secured test endpoint      | Provides login entry point and protected endpoint                     |

--Spring BATCH-->To develop Robust batch applications
--------------
-Batch is used to process bulk operations(ex: sending monthly salary to all employees )
-We can process millions of records in fraction of seconds(ex Reads csv data and store into DB)
-Spring Batch Terminology--->

| **Term**                                   | **Description / Purpose**                                               | **Example / Analogy**                                                          |
| ------------------------------------------ | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| **Job**                                    | A *container for steps* ‚Äî represents the entire batch process.          | ‚ÄúPayroll Processing Job‚Äù that runs multiple steps (read, process, write).      |
| **Step**                                   | A single, independent *phase* of a job.                                 | Reading CSV ‚Üí Processing data ‚Üí Writing to DB.                                 |
| **JobInstance**                            | Represents a *logical run* of a job (based on job name and parameters). | Running ‚ÄúPayrollJob‚Äù for January 2025 vs. February 2025 creates two instances. |
| **JobExecution**                           | Represents a *specific execution* attempt of a JobInstance.             | If a job fails and is restarted, a new JobExecution is created.                |
| **StepExecution**                          | Represents execution metadata for a specific step.                      | Tracks start time, end time, read/write count, etc., for each step run.        |
| **JobRepository**                          | Stores metadata about jobs, steps, and their executions.                | Think of it as Spring Batch‚Äôs internal database for tracking progress.         |
| **JobLauncher**                            | Used to *trigger job execution* with specific parameters.               | `jobLauncher.run(job, jobParameters)`                                          |
| **JobParameters**                          | Input values passed to a job to differentiate instances.                | `date=2025-10-30` or `file=input.csv`                                          |
| **ItemReader**                             | Reads input data from a source (file, DB, API, etc.).                   | Reads 1000 employee records from a CSV.                                        |
| **ItemProcessor**                          | Applies business logic or transformation to each item.                  | Converts salary to USD or filters invalid records.                             |
| **ItemWriter**                             | Writes processed data to the output (DB, file, etc.).                   | Saves valid employee records into database.                                    |
| **Chunk**                                  | A *group of items* processed together in one transaction.               | Read 10 ‚Üí Process 10 ‚Üí Write 10 (commit).                                      |
| **ExecutionContext**                       | Stores state between job/step restarts.                                 | Saves ‚Äúlast processed record ID‚Äù for restart recovery.                         |
| **JobBuilderFactory / StepBuilderFactory** | Helper classes for defining jobs and steps fluently.                    | `jobBuilderFactory.get("myJob").start(step).build()`                           |
| **JobParametersIncrementer**               | Automatically creates new JobParameters for each run.                   | Adds a timestamp parameter for every new execution.                            |
| **SkipListener / RetryListener**           | Handles skip/retry logic for fault tolerance.                           | Skips invalid records or retries on transient DB errors.                       |
| **JobExplorer**                            | Used to *query job metadata* (read-only view).                          | Check job status or history programmatically.                                  |


                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ      JobLauncher       ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ         Job            ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ       Step(s)          ‚îÇ
                ‚îÇ  (One or Multiple)     ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ        ItemReader          ‚îÇ
            ‚îÇ  (Reads data source: DB,   ‚îÇ
            ‚îÇ   CSV, XML, etc.)          ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ       ItemProcessor        ‚îÇ
            ‚îÇ (Processes / transforms    ‚îÇ
            ‚îÇ  the read data)            ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ        ItemWriter          ‚îÇ
            ‚îÇ (Writes processed data to  ‚îÇ
            ‚îÇ  target: DB, File, etc.)   ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚îÇ  Step Execution Listener  ‚îÇ
             ‚îÇ  (Before/After Step)      ‚îÇ
             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚îÇ    Job Execution Listener ‚îÇ
             ‚îÇ    (Before/After Job)     ‚îÇ
             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò



                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ   JobLauncher      ‚îÇ
                ‚îÇ  (Starts the Job)  ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ       Job          ‚îÇ
                ‚îÇ (1..N Steps)       ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ       Step         ‚îÇ
                ‚îÇ (Read‚ÄìProcess‚ÄìWrite)‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                 ‚îÇ                 ‚îÇ
        ‚ñº                 ‚ñº                 ‚ñº
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ ItemReader   ‚îÇ  ‚îÇ ItemProcessor‚îÇ  ‚îÇ ItemWriter   ‚îÇ
 ‚îÇ (Reads data) ‚îÇ  ‚îÇ (Transforms) ‚îÇ  ‚îÇ (Writes data)‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ   JobRepository    ‚îÇ
                ‚îÇ (Stores metadata:  ‚îÇ
                ‚îÇ  Job/Step status)  ‚îÇ
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


Explanation:
-JobLauncher: Entry point that starts a batch job.
-Job: Represents the whole batch process.
-Step: A phase inside the job (each with reader‚Äìprocessor‚Äìwriter).
-ItemReader: Fetches data.
-ItemProcessor: Processes/transforms data.
-ItemWriter: Writes processed data.
-Listeners: Handle pre/post logic for jobs and steps.
-JobRepository: Stores metadata about jobs, steps, and their executions.


customers.csv
     ‚Üì
FlatFileItemReader  ‚Üí reads line by line
     ‚Üì
LineMapper          ‚Üí maps CSV ‚Üí Customer object
     ‚Üì
ItemProcessor       ‚Üí optional cleaning/transformation
     ‚Üì
RepositoryItemWriter ‚Üí saves to DB (via JPA)


--Create Batch application
----------------------------
<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-batch</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.batch</groupId>
			<artifactId>spring-batch-test</artifactId>
			<scope>test</scope>
		</dependency>
</dependencies>

-----Create table manually if error

CREATE TABLE BATCH_JOB_INSTANCE (
    JOB_INSTANCE_ID BIGINT NOT NULL PRIMARY KEY,
    VERSION BIGINT,
    JOB_NAME VARCHAR(100) NOT NULL,
    JOB_KEY VARCHAR(32) NOT NULL,
    CONSTRAINT JOB_INST_UN UNIQUE (JOB_NAME, JOB_KEY)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION (
    JOB_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
    VERSION BIGINT,
    JOB_INSTANCE_ID BIGINT NOT NULL,
    CREATE_TIME DATETIME(6) NOT NULL,
    START_TIME DATETIME(6) DEFAULT NULL,
    END_TIME DATETIME(6) DEFAULT NULL,
    STATUS VARCHAR(10),
    EXIT_CODE VARCHAR(2500),
    EXIT_MESSAGE VARCHAR(2500),
    LAST_UPDATED DATETIME(6),
    CONSTRAINT JOB_INST_EXEC_FK FOREIGN KEY (JOB_INSTANCE_ID)
    REFERENCES BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION_PARAMS (
    JOB_EXECUTION_ID BIGINT NOT NULL,
    PARAMETER_NAME VARCHAR(100) NOT NULL,
    PARAMETER_TYPE VARCHAR(100) NOT NULL,
    PARAMETER_VALUE VARCHAR(2500),
    IDENTIFYING CHAR(1) NOT NULL,
    CONSTRAINT JOB_EXEC_PARAMS_FK FOREIGN KEY (JOB_EXECUTION_ID)
    REFERENCES BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION (
    STEP_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
    VERSION BIGINT NOT NULL,
    STEP_NAME VARCHAR(100) NOT NULL,
    JOB_EXECUTION_ID BIGINT NOT NULL,
    CREATE_TIME DATETIME(6) NOT NULL,
    START_TIME DATETIME(6) DEFAULT NULL,
    END_TIME DATETIME(6) DEFAULT NULL,
    STATUS VARCHAR(10),
    COMMIT_COUNT BIGINT,
    READ_COUNT BIGINT,
    FILTER_COUNT BIGINT,
    WRITE_COUNT BIGINT,
    READ_SKIP_COUNT BIGINT,
    WRITE_SKIP_COUNT BIGINT,
    PROCESS_SKIP_COUNT BIGINT,
    ROLLBACK_COUNT BIGINT,
    EXIT_CODE VARCHAR(2500),
    EXIT_MESSAGE VARCHAR(2500),
    LAST_UPDATED DATETIME(6),
    CONSTRAINT JOB_EXEC_STEP_FK FOREIGN KEY (JOB_EXECUTION_ID)
    REFERENCES BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION_CONTEXT (
    STEP_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
    SHORT_CONTEXT VARCHAR(2500) NOT NULL,
    SERIALIZED_CONTEXT TEXT,
    CONSTRAINT STEP_EXEC_CTX_FK FOREIGN KEY (STEP_EXECUTION_ID)
    REFERENCES BATCH_STEP_EXECUTION(STEP_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION_CONTEXT (
    JOB_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
    SHORT_CONTEXT VARCHAR(2500) NOT NULL,
    SERIALIZED_CONTEXT TEXT,
    CONSTRAINT JOB_EXEC_CTX_FK FOREIGN KEY (JOB_EXECUTION_ID)
    REFERENCES BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION_SEQ (
    ID BIGINT NOT NULL,
    UNIQUE_KEY CHAR(1) NOT NULL,
    CONSTRAINT UNIQUE_KEY_UN UNIQUE (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_STEP_EXECUTION_SEQ (ID, UNIQUE_KEY)
SELECT 0, '0' FROM DUAL WHERE NOT EXISTS (SELECT * FROM BATCH_STEP_EXECUTION_SEQ);

CREATE TABLE BATCH_JOB_EXECUTION_SEQ (
    ID BIGINT NOT NULL,
    UNIQUE_KEY CHAR(1) NOT NULL,
    CONSTRAINT UNIQUE_KEY_UN UNIQUE (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_JOB_EXECUTION_SEQ (ID, UNIQUE_KEY)
SELECT 0, '0' FROM DUAL WHERE NOT EXISTS (SELECT * FROM BATCH_JOB_EXECUTION_SEQ);

CREATE TABLE BATCH_JOB_INSTANCE_SEQ (
    ID BIGINT NOT NULL,
    UNIQUE_KEY CHAR(1) NOT NULL,
    CONSTRAINT UNIQUE_KEY_UN UNIQUE (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_JOB_INSTANCE_SEQ (ID, UNIQUE_KEY)
SELECT 0, '0' FROM DUAL WHERE NOT EXISTS (SELECT * FROM BATCH_JOB_INSTANCE_SEQ);


application.yml
---------------
spring:
  application:
    name: 60-Spring-BatchApp
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/sbms
    username: root
    password: admin@123
    hikari:
      maximum-pool-size: 10
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update
  batch:
    jdbc:
      initialize-schema: always       #schema required for batch operation intialize always
	  
--keep csv file in the src/main/resources folder
 CUSTOMER_ID,firstname,lastname,email,gender,contactNum,country,dob
1,Rohit,Lavate,rohit.lavate@example.com,Male,9876543210,India,1995-06-15
2,Ananya,Sharma,ananya.sharma@example.com,Female,8765432109,India,1998-09-22
3,Michael,Smith,michael.smith@example.com,Male,7456123987,USA,1990-02-12
4,Sophia,Johnson,sophia.johnson@example.com,Female,7890654321,UK,1992-11-30
5,Arjun,Patel,arjun.patel@example.com,Male,9123456780,India,1996-04-05
6,Lisa,Wong,lisa.wong@example.com,Female,8523697410,China,1993-08-17
7,David,Kim,david.kim@example.com,Male,9632587410,South Korea,1988-01-25
8,Nina,Lopez,nina.lopez@example.com,Female,7410258963,Mexico,1997-05-10
9,Ali,Khan,ali.khan@example.com,Male,8521479630,Pakistan,1994-12-02
10,Emma,Brown,emma.brown@example.com,Female,7894561230,Australia,1991-07-18

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "CUSTOMER_INFO")
public class Customer {
	@Id
	@Column(name = "CUSTOMER_ID")
	private int id;
	private String firsname;
	private String lastname;
	private String email;
	private String gender;
	private String contactNum;
	private String country;
	private String dob;
}


public interface CustomerRepository extends JpaRepository<Customer, Integer>{

}
    
	  
public class CustomerProcessor implements ItemProcessor<Customer, Customer> {

    @Override
    public Customer process(Customer customer) throws Exception {
        // Example transformation: capitalize first name
        customer.setFirsname(customer.getFirsname().toUpperCase());
        return customer;
    }
}


| **Version**      | **Classes Used**                             | **Status**  | **Notes**                                                    |
| ---------------- | -------------------------------------------- | ----------- | ------------------------------------------------------------ |
| Spring Batch 4.x | `JobBuilderFactory`, `StepBuilderFactory`    | ‚úÖ Supported | Works automatically with `@EnableBatchProcessing`            |
| Spring Batch 5.x | `JobRepository`, `StepBuilder`, `JobBuilder` | üö´ Replaced | You must define repositories & transaction managers manually |

-----------
Old way

@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    // --- Item Reader ---
    @Bean
    public FlatFileItemReader<Customer> customerReader() {
        FlatFileItemReader<Customer> itemReader = new FlatFileItemReader<>();
        itemReader.setResource(new FileSystemResource("src/main/resources/customers.csv"));
        itemReader.setName("customer-item-reader");
        itemReader.setLinesToSkip(1); // skip header row
        itemReader.setLineMapper(lineMapper());
        return itemReader;
    }

    private LineMapper<Customer> lineMapper() {
        DefaultLineMapper<Customer> lineMapper = new DefaultLineMapper<>();

        DelimitedLineTokenizer lineTokenizer = new DelimitedLineTokenizer();
        lineTokenizer.setDelimiter(",");
        lineTokenizer.setStrict(false);
        lineTokenizer.setNames("id", "firstname", "lastname", "email", "gender", "contactNum", "country", "dob");

        BeanWrapperFieldSetMapper<Customer> fieldSetMapper = new BeanWrapperFieldSetMapper<>();
        fieldSetMapper.setTargetType(Customer.class);

        lineMapper.setLineTokenizer(lineTokenizer);
        lineMapper.setFieldSetMapper(fieldSetMapper);

        return lineMapper;
    }

    // --- Item Processor ---
    @Bean
    public CustomerProcessor customerProcessor() {
        return new CustomerProcessor();
    }

    // --- Item Writer ---
    @Bean
    public RepositoryItemWriter<Customer> customerWriter() {
        RepositoryItemWriter<Customer> writer = new RepositoryItemWriter<>();
        writer.setRepository(customerRepository);
        writer.setMethodName("save");
        return writer;
    }

    // --- Step ---
    @Bean
    public Step step() {
        return stepBuilderFactory.get("step-1")
                .<Customer, Customer>chunk(10)
                .reader(customerReader())
                .processor(customerProcessor())
                .writer(customerWriter())
                .build();
    }

    // --- Job ---
    @Bean
    public Job job() {
        return jobBuilderFactory.get("customer-import")
                .flow(step())
                .end()
                .build();
    }
}
--------
New Ways


@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Autowired
    private CustomerRepository customerRepository;

    // --- Item Reader ---
    @Bean
    public FlatFileItemReader<Customer> customerReader() {                    //Reads data line by line from a CSV file.Each line ‚Üí converted into a Customer object using lineMapper().The first line (header) is skipped.
        FlatFileItemReader<Customer> itemReader = new FlatFileItemReader<>();
        itemReader.setResource(new FileSystemResource("src/main/resources/customers.csv"));
        itemReader.setName("customer-item-reader");
        itemReader.setLinesToSkip(1);
        itemReader.setLineMapper(lineMapper());
        return itemReader;
    }

    private LineMapper<Customer> lineMapper() {          //DelimitedLineTokenizer ‚Üí splits each line into fields using commas.The fields are assigned by name (id, firstname, etc.).BeanWrapperFieldSetMapper ‚Üí automatically binds those field names to your Customer entity‚Äôs properties.
        DefaultLineMapper<Customer> lineMapper = new DefaultLineMapper<>();

        DelimitedLineTokenizer lineTokenizer = new DelimitedLineTokenizer();
        lineTokenizer.setDelimiter(",");
        lineTokenizer.setStrict(false);
        lineTokenizer.setNames("id", "firstname", "lastname", "email", "gender", "contactNum", "country", "dob");

        BeanWrapperFieldSetMapper<Customer> fieldSetMapper = new BeanWrapperFieldSetMapper<>();
        fieldSetMapper.setTargetType(Customer.class);

        lineMapper.setLineTokenizer(lineTokenizer);
        lineMapper.setFieldSetMapper(fieldSetMapper);

        return lineMapper;
    }

    // --- Item Processor ---
    @Bean
    public CustomerProcessor customerProcessor() {  //Used for:Cleaning data,Converting formats,Filtering invalid records
        return new CustomerProcessor();
    }

    // --- Item Writer ---
    @Bean
    public RepositoryItemWriter<Customer> customerWriter() {
        RepositoryItemWriter<Customer> writer = new RepositoryItemWriter<>();
        writer.setRepository(customerRepository);
        writer.setMethodName("save");
        return writer;
    }

    // --- Step ---
    @Bean
    public Step step(JobRepository jobRepository, PlatformTransactionManager transactionManager) {  //Each chunk of 10 records is read ‚Üí processed ‚Üí written in one transaction.If any record in the chunk fails, the entire chunk rolls back.JobRepository and TransactionManager are provided by Spring Batch automatically.
        return new StepBuilder("step-1", jobRepository)
                .<Customer, Customer>chunk(10, transactionManager)
                .reader(customerReader())
                .processor(customerProcessor())
                .writer(customerWriter())
                .build();
    }

    // --- Job ---
    @Bean
    public Job job(JobRepository jobRepository, Step step) {   //Defines a Job named "customer-import".Contains a single Step (step-1).You can later add more steps (e.g., validation, reporting).
        return new JobBuilder("customer-import", jobRepository)
                .start(step)
                .build();
    }
}



@RestController
public class CustomerRestController {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job job;

    @GetMapping("/load")
    public String loadData() {
        try {
            // Build job parameters with unique timestamp (to prevent "Job already completed" errors)
            JobParameters jobParams = new JobParametersBuilder()
                    .addLong("startAt", System.currentTimeMillis())
                    .toJobParameters();

            JobExecution execution = jobLauncher.run(job, jobParams);
            return "‚úÖ Batch Job Status: " + execution.getStatus();

        } catch (Exception e) {
            e.printStackTrace();
            return "‚ùå Job failed: " + e.getMessage();
        }
    }
}
----------------
Spring Scheduler---> @EnableScheduling(Class level) and @Scheduled(Method level)
----------------
-Spring Scheduling-->Allows you to schedule tasks or methods to be executed at specific times or intervals, provides a convinient way to automate repetitive tasks, background processing or any operation that
needed executition periodically. Tasks like( perform at regular intervals)
ex --> Generate reports or performing data backups at specific time
       sending periodic notification or reminders
	   Running background jobs or batch processing
-Achieved by using @Scheduled annotation-->By adding it and configuring the scheduling properties, you can specify when and how often the method should be executed
-Attributes
  fixedRate-->interval between start times and consecutive task executions. It means the task will be executed at a fixed rate, regardless of the duration of previous task execution
             ex:- fixedRate=5000ms-->task will be executed every 5 seconds, regardless of how long previous execution.(if dalay in any task, task may overlap)
  fixedDelay-->delay between completion of previous task execution and the start of next execution, regardless of how long the task execution takes.
-CRON Expression--> To define Scheduling pattern for tasks or methods, provide powerful way to specify the timing of task execution
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ second (0‚Äì59)
 ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ minute (0‚Äì59)
 ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ hour (0‚Äì23)
 ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ day of month (1‚Äì31)
 ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ month (1‚Äì12 or JAN‚ÄìDEC)
 ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ day of week (0‚Äì6 or SUN‚ÄìSAT)
 ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
 * * * * * *
 
 | Cron Expression     | Meaning                  |
| ------------------- | ------------------------ |
| `0 0 2 * * ?`       | Every day at 2:00 AM     |
| `0 0/10 * * * ?`    | Every 10 minutes         |
| `0 0 9 ? * MON-FRI` | Every weekday at 9:00 AM |
| `0 */5 * * * *`     | Every 5 minutes          |
| `0 15 10 * * ?`     | Every day at 10:15 AM    |

// üïí Every minute
EVERY_MINUTE = "0 * * * * ?";
    // üïê Every hour (at minute 0)
EVERY_HOUR = "0 0 * * * ?";
    // üåû Every day at noon
EVERY_DAY_AT_NOON = "0 0 12 * * ?";
    // üïó Every minute between 8 AM and 6 PM
BETWEEN_8AM_AND_6PM = "0 * 8-18 * * ?";
    // üìÜ On the 1st day of every month at midnight
	
FIRST_DAY_OF_MONTH = "0 0 0 1 * ?";
| Expression         | Meaning                                 |
| ------------------ | --------------------------------------- |
| `0/5 * * * * ?`    | Every **5 seconds**                     | / ‚Üí ‚Äústep‚Äù or ‚Äúevery nth‚Äù, It specifies increments (steps) of time.
| `0 0/10 * * * ?`   | Every **10 minutes**                    |
| `0 0 9-17/2 * * ?` | Every **2 hours between 9 AM and 5 PM** |  So / means ‚Äústart at X, then repeat every N units‚Äù.

| Symbol | Meaning           | Example             | Description                  |
| ------ | ----------------- | ------------------- | ---------------------------- |
| `*`    | Any value         | `* * * * * ?`       | Every second/minute/hour/day |
| `/`    | Step              | `0/10 * * * * ?`    | Every 10 seconds             |
| `?`    | No specific value | `0 0 12 * * ?`      | Every day at noon            |
| `-`    | Range             | `0 0 9-17 * * ?`    | Every hour from 9 AM to 5 PM |
| `,`    | List              | `0 0 9,12,15 * * ?` | At 9 AM, 12 PM, and 3 PM     |


	
	

                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ     Application Start     ‚îÇ
                  ‚îÇ   (Spring Boot Context)   ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ   Scheduler Component     ‚îÇ
                  ‚îÇ  @Scheduled(cron = "...") ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ triggers
                                ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ      JobLauncher          ‚îÇ
                  ‚îÇ jobLauncher.run(job, params) ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ launches
                                ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ         Job               ‚îÇ
                  ‚îÇ (e.g. "customer-import")  ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                 Step                     ‚îÇ
        ‚îÇ (e.g. read-process-write chunk = 10)     ‚îÇ
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
        ‚îÇ FlatFileItemReader ‚Üí CustomerProcessor ‚Üí ‚îÇ
        ‚îÇ RepositoryItemWriter                    ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ     JobRepository DB      ‚îÇ
                  ‚îÇ   (stores batch metadata) ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ  Job Completion Listener  ‚îÇ
                  ‚îÇ   Logs Success / Failure  ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
</dependencies>


@Component
public class TaskSchedulerService {

	// 1Ô∏è‚É£ Every minute
	@Scheduled(cron = "0 * * * * ?")
	public void runEveryMinute() {
		System.out.println("‚è± Every minute: " + LocalTime.now());
	}

	// 2Ô∏è‚É£ Every hour
	@Scheduled(cron = "0 0 * * * ?")
	public void runEveryHour() {
		System.out.println("üïê Every hour: " + LocalTime.now());
	}

	// 3Ô∏è‚É£ Every day at noon
	@Scheduled(cron = "0 0 12 * * ?")
	public void runAtNoon() {
		System.out.println("üåû Noon task: " + LocalTime.now());
	}

	// 4Ô∏è‚É£ Every day between 8 AM and 6 PM, every hour
	@Scheduled(cron = "0 0 8-18 * * ?")
	public void runBetween8and6() {
		System.out.println("üíº Working hours task: " + LocalTime.now());
	}

	// 5Ô∏è‚É£ 1st day of every month at 1 AM
	@Scheduled(cron = "0 0 1 1 * ?")
	public void runOnFirstDayOfMonth() {
		System.out.println("üìÖ First day of month task: " + LocalTime.now());
	}

	// üî• Manual trigger method
	public void runManualTask() {
		System.out.println("üöÄ Manual trigger executed at: " + LocalTime.now());
	}
}


@RestController
@RequestMapping("/api/scheduler")
public class SchedulerController {

    @Autowired
    private TaskSchedulerService schedulerService;

    // ‚úÖ Manual trigger endpoint
    @GetMapping("/trigger-now")
    public String triggerNow() {
        schedulerService.runManualTask();
        return "‚úÖ Manual scheduler triggered successfully!";
    }
}

--Mono or Flux Objects(Reactive programming-->Non Blocking execution based on events)
-----------------------
Spring WebFlux is the reactive web framework in Spring (parallel to Spring MVC), designed for non-blocking, asynchronous, and event-driven applications.
It is built on Project Reactor, which introduces two core types:
| Type        | Emits              | Example Use Case                                       |
| ----------- | ------------------ | ------------------------------------------------------ |
| **Mono<T>** | **0 or 1** element | Fetch a single record from DB, return one API response |
| **Flux<T>** | **0‚Ä¶N** elements   | Fetch multiple records, stream data to clients         |

| Use Case                                      | Type                            |
| --------------------------------------------- | ------------------------------- |
| Fetch or process one record                   | `Mono<T>`                       |
| Fetch or stream multiple records              | `Flux<T>`                       |
| Error handling or empty response              | `Mono.error()` / `Mono.empty()` |
| Continuous data stream (e.g., WebSocket, SSE) | `Flux<T>`                       |

Think of:
Mono ‚Üí ‚ÄúA promise of a single value‚Äù
Flux ‚Üí ‚ÄúA stream of many values‚Äù
Both represent asynchronous pipelines (like Java‚Äôs Stream, but reactive and async).

üëâ Mono.just() emits one item and completes.
You can also use:
Mono.empty() ‚Äì emits nothing, completes.
Mono.error() ‚Äì emits an error.

| Operator          | Description              |
| ----------------- | ------------------------ |
| `map()`           | Transform value          |
| `flatMap()`       | Asynchronously transform |
| `filter()`        | Conditional filtering    |
| `zip()`           | Combine publishers       |
| `concatWith()`    | Combine sequentially     |
| `delayElements()` | Emit with delay          |
| `onErrorResume()` | Fallback on error        |

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CustomerEvent {
	private String name;
	private Date eventDate;
}


@RestController
public class ReactiveRestController {
	@GetMapping("/single")
	public Mono<String> sigleResponse(){
		String msg ="Hello World";
		return Mono.just("Hello world");
		//return Mono.justOrEmpty(msg);   //To avoid NullPointerException-->if object available it pass or return empty value
	}
	
	@GetMapping("/multiple")
	public Flux<Integer> multipleResponses(){
		return Flux.range(1, 10);
	}
	
	@GetMapping(value = "/stream", produces = "text/event-stream")
    public Flux<Integer> streamMultiResponses() {
        // Emits numbers 1‚Äì10, one every 10 seconds
        return Flux.range(1, 10)
                   .delayElements(Duration.ofSeconds(10));
    }
	
	@GetMapping(value = "/event", produces = MediaType.APPLICATION_JSON_VALUE)
	public Mono<CustomerEvent> getEvent() {
		CustomerEvent event = new CustomerEvent("John",new Date());
		return Mono.justOrEmpty(event);
	}
	
  @GetMapping(value = "/events", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
   public Flux<CustomerEvent> getCustomerStream() {  
    // Creating two sample CustomerEvent objects with name and current timestamp
    CustomerEvent event1 = new CustomerEvent("Rohit", new Date());
    CustomerEvent event2 = new CustomerEvent("Pramod", new Date());
    
    // Storing them in an array
    CustomerEvent[] eventArray = {event1, event2};
    
    // Creating a Flux (reactive stream) from the array of events
    // Flux.fromArray() creates a publisher that emits each element in the array
    Flux<CustomerEvent> dataFlux = Flux.fromArray(eventArray);
    
    // Creating another Flux that emits a sequential number every 5 seconds
    // This acts as a timer that controls how often data is emitted
    Flux<Long> internalFlux = Flux.interval(Duration.ofSeconds(5));
    
    // Combining (zipping) both Flux streams together
    // Each emitted item from internalFlux (timer) will be paired with one item from dataFlux
    // Tuple2 represents a pair of (timer value, event object)
    Flux<Tuple2<Long, CustomerEvent>> zip = Flux.zip(internalFlux, dataFlux);
    
    // Extracting only the CustomerEvent (second element of the tuple)
    // Tuple2::getT2 means ‚Äúget the second value‚Äù from each tuple
    Flux<CustomerEvent> fluxMap = zip.map(Tuple2::getT2);
    
    // Returning the stream of CustomerEvent objects as Server-Sent Events (SSE)
    // This will send one event every 5 seconds to the client
    return fluxMap;
  }
}

Netty started on port 9090 (http)

--Unit Testing(JUnit5 and Mockito)
--------------
It is the process of testing individual components of software application, used to identify the bugs available in our code.
-JUnit-->It is Java based framework, used to implement unit testing for java application(Open Source)--> junit.org/junit5/
JUnit5 = JUnit Platform + JUnit Jupiter +JUnit vintage
JUnit Platform-->Provide runtime to run junit unit test
JUnit Jupiter--> Provided Annotation to implement JUnit testCases-->@Test,@ParameterizedTest,@ValueSource,@BeforeAll.@AfterAll,@BeforeEach,@AfterEach
Vintage-->Provides backward compatibility(JUnit3, JUnit4 tests support)
-In unit testing, we have to implement with Isolation # isolated Unit testing-->Testing component independently
-When you are going for unit testing first you have to understand what is your target.--->Understand does this method have dependency on other method, 
if independent-->easy for unit testing
if dependent method(e.g RestController method have dependency on the Service class methods)-->so while unit testing restcontroller method,service method should not be executed
-By using 'Mocking' we can perform unit testing with isolation, instead of injecting real service to RestController inject MockService to RestController
-'Mocking'-->Process of Creating subtitute object for the real object is called as Mocking
     Mock Object = Real Object 
     isolated testing-->testing only target method
	 
	               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                   ‚îÇ         Test Class          ‚îÇ
                   ‚îÇe.g., CustomerControllerTest)‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  ‚îÇ
                                  ‚îÇ  (creates fake behavior)
                                  ‚ñº
                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                      ‚îÇ      Mock Object     ‚îÇ
                      ‚îÇ (e.g., CustomerService mock)‚îÇ
                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                     ‚îÇ
             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ  (Injects mock instead of real bean)
             ‚ñº
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ     Class Under Test        ‚îÇ
  ‚îÇ (e.g., CustomerController)  ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚îÇ Calls method on mock
                 ‚ñº
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ        Mocked Method        ‚îÇ
      ‚îÇ  (predefined fake behavior) ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
           Returns fake data instantly
                     ‚îÇ
                     ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ      Test Assertions        ‚îÇ
       ‚îÇ (StepVerifier / Assertions) ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Code Coverage-->identifying how many lines of code is tested as part of unit testing(As per industry standard-->80%)
  Form binding,entity Classes,Getter,Setter,Constants Class--->Unit testing not required
  target/site/jococo/index.html--->Code coverage reportDAO
  example-->Jococo,SonarQube, Cobertura etc
  by adding plugin in pom.xml-->ex-->Jococo plugin