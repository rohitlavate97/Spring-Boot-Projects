Servers used for configuaration in Microservices development with Spring boot
-Service Registry
-Admin Server
-API Gateway

Development flow:
-From backend to UI
-API Gatewway acts as a mediator between FrontEnd and BackEnd

-Spring Core provides IOC and DI, to develop classes with loosely coupling
-Use Interface to provide common methods(increases readability)
Dependency Injection: Injecting dependent object into target object using target class variable/setter/constructor
-Different Types of Injection
--Constructor Injection
--Setter Injection
--Field Injection

What if we perform both constructor Injection and Setter Injection-->First construction injection will happen. then, it will
initialize the variable then setter injection will happen and it will reinitialize the same variable so final value be setter injection value
Note: Setter injection will override construction injection

In Spring, IOC is responsible for Dependency Injection
IOC manages and collaborate object(i.e Creating and injecting object). IOC is a principle which is used to manage and collaborate dependencies among the objects in the application
For IOC container, we need to provide Java Classes as input as it don't know which is target class. Along with Java classes we have to provide configuration(through Xml or annotartions)
IOC will load classes and then create object and will perform DI(i.e it provides spring beans-->Class which is managed by IOC)

Ways to Start the IOC
-BeanFactory(Outdated)
-ApplicationContext(interface)

Class managed by IOC is called as Spring Bean

ApplicationContext ctx = new ClassPathXmlApplicationContext(String xmlFilePath);


Beans.xml-----> should be created in src/main/java
-----------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- bean definitions here -->
    <bean id="credit" class="com.alchemist.beans.CreditCardPayment"/>
    <bean id="debit" class="com.alchemist.beans.DebitCardPayment"/>
    <bean id="payment" class="com.alchemist.beans.PaymentService">
    <!-- to avoid Nullpointer exception as PaymentService don't have by default constructor-->
       <!--constructor-arg name="payment" ref="debit"/-->----------------This is the constructor injection
       <!--constructor-arg name="payment" ref="credit"/-->
       <property name="iPayment" ref="credit"/>--------------------------- this is how settter injection done, property name should be interface referece variable
     </bean>
</beans>
-----------------------------------------------------------------------------
Note: 'ref' attribute represents which object should be injected
-Field injection is only possible with Annotations

Spring Bean Scope-->Decides how many objects should be crated for spring bean class
-Singleton(Default)--> Every Spring Bean is Singleton, whenever we start IOC container, by default it will create objects for singlton bens and when we call getBean()(everytime it checks scope when we call this method) then it will create object for others(for memory management)
-Prototype--->Every time new object will be created
-Request
-Session
Note: Request and Session scopes are used in Spring web MVC

Syntax:
    <bean id="car" class="com.alchemist.beans.CarService" scope="prototype">
       <constructor-arg name="car" ref="petrol"/>
     </bean>

Manual Wiring--> injecting dependent object into target objects with 'ref' attribute is Manual Wiring
Autowiring-->To identify objects and injecting into the Target objects
works on below modes
-byName--->for setter injection--->based on bean id of bean matching with interface variable
-byType--->for setter injection--->based on type of variable, dependent bean will be identified(bean id doesn't matter)
-Constructor
-none

Syntax:
--byName--->identity dependent based on variable name matching with bean id
<bean id="car" class="com.alchemist.beans.CarService" autowire="byName">
--When we write 'autowire' attribute in the bean definition, that bean will be considered as Target Class

--byType--->identity dependent bean based on variable type
  autowire-candidate="false"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" autowire-candidate="false"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">
     </bean>
  primary="true"
    <bean id="engine" class="com.alchemist.beans.PetrolEngine" primary="true"/>
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <!--bean id="car" class="com.alchemist.beans.CarService" autowire="byName"-->
    <bean id="car" class="com.alchemist.beans.CarService" autowire="byType">

--constructor--->First it will check byName, then goes for byType, we can use primary="true" for any bean which we want to inject
    <bean id="engine1" class="com.alchemist.beans.DieselEngine"/>
    <bean id="car" class="com.alchemist.beans.CarService" autowire="constructor">
     </bean>

Spring Annotations: Annotations are used to provide metadata
---------------------------------------------------------------------------
@Configuration:->Instead of XML, java class can be marked as Configuration
@Component,@Service,@Repository-->To represent java class as spring bean class
@Scope-->To represent scope of the bean
@Qualifier-->When multiple beans of same type, it is used to identity bean based on the given name for DI
@Autowired:-->used to enable auto-wiring in a class
@Primary-->To give priority for the bean for auto-wiring
@Bean:-->The @Bean annotation in Spring Boot is used to declare a method that produces a bean to be managed by the Spring IoC (Inversion of Control) container. This annotation is typically used within a @Configuration class, which signifies that the class's primary purpose is to define bean definitions. @Component auto-detects your beans, @Bean explicitly 
declares them.For third-party library classes or when you need custom instantiation logic
@ComponentScan(basePackages={"com.alchemist","edu.scaler"})-->It is the process of identifying spring bean classes available in project based on base packages name
Note:--Class that communicates with db is called Persistence Class/DAO Class. Whatever Exception getting from DB i.e SQLException will be truncated into our java side
--Classes which are utility like sending mail. generateReport are represented by @Component
--interfaces which has business logic get implementation class @Service annotation

-->Example name
package com.alchemist;------->Always keep Appconfig.java in base package rather than config package
@Configuration
@ComponentScan(basePackages = "com.alchemist")
public class AppConfig {

}

-eager loading-->IOC container creates object immediately from singleton beans
-lazy loading-->For Prototype ban when you create object then only object created

Autowiring with Spring Annotation(@Autowired)-->
@Autowired can be used at 3 places
-Variable level--Field injection
-Constructor level--Constructor injection
-Setter Mehtod level--Setter Injection

--Autowiring byName
-@Service
 public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

-@Repository("reportDAO")    //to do autowiring by name
 public class OracleDBReportDAO implements ReportDAO {

--Using @Qualifier
@Repository("mysqlDBDAO")
public class MysqlDBDAO implements ReportDAO {

@Repository("oracleDBDAO")
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    @Qualifier("oracleDBDAO")
    private ReportDAO reportDAO;

--Using @Primary
@Repository("oracleDBDAO")
@Primary
public class OracleDBDAO implements ReportDAO {

@Service
public class ReportService {
    @Autowired
    private ReportDAO reportDAO;

--Autowiring with Setter

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public void setReportDAO(@Qualifier("oracleDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

    public void generateReport() {
        System.out.println("ReportService - Generating Report");
        reportDAO.getData();
        System.out.println("ReportService - Report Generated");
    }

}
Note: also we can use @Primary

--Autowiring with Constructor

@Service
public class ReportService {
    private ReportDAO reportDAO;
    @Autowired
    public ReportService(@Qualifier("mysqlDBDAO") ReportDAO reportDAO) {
        this.reportDAO = reportDAO;
    }

Note: If we remove @Autowired here, still DI will happens as ReportService is Spring bean,i.e IOC should create object for ReportService when you have only one parameterized constructor in class @Autowired is optional. Wnen you have 2 constructors, DI will not happen withoult @Autowired
If we have one no param constructor and one Param constructor, then by default it will call 0-param constructor and DI will not happen

Spring bean life-Cycle
----------------------
init(),getData,destroy()
Bean life-Cycle methods can be executed in 3 ways
-Declarative approach(Xml file to configure)
    <!--Add attribute init-method and destroy-mehtod for Bean Lifecycle-->
    <bean id="dao" class="com.alchemist.UserDAO"
    init-method="init"
    destroy-method="destroy"
    />
	
-Programmatic approach(By using Interface)

public class UserDAO implements InitializingBean,DisposableBean{
	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

-Annotation approach
@Component
public class UserDAO{
	
	@PostConstruct
	public void init() {
		System.out.println("Getting db connection.....");
	}
	
	public void getData() {
		System.out.println("Getting the data from thd db...");
	}
	
	@PreDestroy
	public void destroy() throws Exception{
		System.out.println("Closing db connection.....");
	}

}

Main Class for all approaches
package com.alchemist;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class Application {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");---->XML Approach
		ApplicationContext context=new AnnotationConfigApplicationContext(AppConfig.class);----> annotation approach
		UserDAO dao = context.getBean(UserDAO.class);
		dao.getData();
		/*If we add this much code-->destroy() will not be executed, as in in main method no code to 
		 * to execute-->JVM shutdown i.e main method terminated--->IOC container have not got chance 
		 * to remove the object. so in order to see execution of destroy() add following code */
		ConfigurableApplicationContext ctxt = (ConfigurableApplicationContext)context;
		ctxt.close();

	}

}

@DependsOn:-->Wnen one bean dependent on another bean, we specify that DependsOn. (also this can be used in XML also)
We can specify single or multiple beans
@DependsOn("dao") 
@DependsOn(value={"dao","service"})

Ex-->Class A and Class B, Class B should fetch data from db and store into redis, then Class A will fetch data from redis. It will increase performance.
so here Class A dependent on Class B
In some cases, for creating object scanning happens according to alphabetical order--->Causes isssue

@Component("userDao") //writing the name of the bean
public class UserDao implements InitializingBean,DisposableBean{

@Service
@DependsOn("userDao")
public class UserService {
	public UserService() {
		System.out.println("Getting data from Redis...");
	}
----------------------------------------Spring Core Completed----------------------------------------------------------------------------------------------
Project Lombok-->Project Lombok is a Java library that helps you reduce boilerplate code,
i.e., the repetitive stuff like getters, setters, constructors, toString(), and equals() methods — by generating them automatically during compilation.
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.38</version>
</dependency>

| Annotation                 | Purpose                                                                                      |
| -------------------------- | -------------------------------------------------------------------------------------------- |
| `@Getter` / `@Setter`      | Creates getters and setters                                                                  |
| `@ToString`                | Generates `toString()`                                                                       |
| `@EqualsAndHashCode`       | Generates `equals()` and `hashCode()`                                                        |
| `@NoArgsConstructor`       | Generates a no-argument constructor                                                          |
| `@AllArgsConstructor`      | Generates a constructor with all fields                                                      |
| `@RequiredArgsConstructor` | Generates a constructor for final fields                                                     |
| `@Data`                    | Combines `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor` |
| `@Builder`                 | Enables the **Builder pattern**                                                              |
| `@Value`                   | Creates an **immutable class** (like `final` + all fields `private final`)                   |
| `@Slf4j`                   | Adds a logger instance automatically (`log.info("message")`)                                 |
-----------------------------------------------------------------------------------------------------------------------------

Spring Boot--->It is the Extension for Spring Framework
It is one approach, to develop Spring Based application with less configuration-->Develops Standalone, Web and Distributed i.e Microservices
Spring Boot = Spring - XML configuration + Auto Configuration + Embedded Servers + Actuator
We have following advantages-->
-Starter POM-->Simplifies Maven/Graddle build configuaration
It contains web-starter,datajpa-starter,Security-starter and mail-starter
--Auto Configuration--->Whatever common configuaration required for Spring boot will be taken care by Spring boot
e.g-->Creating db connection pool,Deploy Web Application in embeded server, Start IOC container, Component Scanning etc

Note: As Spring Boot executes from main(), war or jar doesn't matters

pom.xml------------>Add the following dependency
        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

@Service
public class ReportService {
	
	public ReportService() {
		/*
		 * this class is added to showcase that object is created by IOC when @Service
		 * annotation is added on the top of the class
		 */
		System.out.println("Report Service :: Constructor");
	}

}

--@SpringBootApplication--->@SpringBootConfiguration(-->@Configuration) + @EnableAutoConfiguration(-->AppConfig.java need not to write) + @ComponentScan

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

[32m :: Spring Boot :: [39m             [2m (v3.4.10)[0;39m

[2m2025-10-12T22:01:40.746+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m Starting Application using Java 17.0.16 with PID 9772 (D:\Projects\Spring-Boot-Projects\13-SB-first-App\target\classes started by Admin in D:\Projects\Spring-Boot-Projects\13-SB-first-App)
[2m2025-10-12T22:01:40.749+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m No active profile set, falling back to 1 default profile: "default"
[2m2025-10-12T22:01:41.406+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat initialized with port 8080 (http)
[2m2025-10-12T22:01:41.419+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.apache.catalina.core.StandardService  [0;39m [2m:[0;39m Starting service [Tomcat]
[2m2025-10-12T22:01:41.419+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.apache.catalina.core.StandardEngine   [0;39m [2m:[0;39m Starting Servlet engine: [Apache Tomcat/10.1.46]
[2m2025-10-12T22:01:41.452+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.a.c.c.C.[Tomcat].[localhost].[/]      [0;39m [2m:[0;39m Initializing Spring embedded WebApplicationContext
[2m2025-10-12T22:01:41.453+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mw.s.c.ServletWebServerApplicationContext[0;39m [2m:[0;39m Root WebApplicationContext: initialization completed in 657 ms
Report Service :: Constructor
[2m2025-10-12T22:01:41.738+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mr$InitializeUserDetailsManagerConfigurer[0;39m [2m:[0;39m Global AuthenticationManager configured with UserDetailsService bean with name inMemoryUserDetailsManager
[2m2025-10-12T22:01:41.855+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mo.s.b.w.embedded.tomcat.TomcatWebServer [0;39m [2m:[0;39m Tomcat started on port 8080 (http) with context path '/'
[2m2025-10-12T22:01:41.864+05:30[0;39m [32m INFO[0;39m [35m9772[0;39m [2m--- [13-SB-first-App] [           main] [0;39m[36mcom.alchemist.Application               [0;39m [2m:[0;39m Started Application in 1.469 seconds (process running for 1.852)

Here in the console we can see IOC container started autoconfiguration,
Tomcat Started,Component scanning done by default,Security provided automatically

Spring Boot Actuator:---->It is a built-in module that exposes a set of production-ready endpoints (called Actuator Endpoints) to let you:
-Monitor application health
-Check configurations and environment properties
-View metrics (CPU, memory, threads, requests, etc.)
-Manage log levels at runtime
-View application beans and mappings
-Integrate with monitoring tools like Prometheus, Grafana, New Relic, etc.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

Default Endpoint-->http://localhost:8080/actuator
Common Endpoints
| Endpoint             | Description                                               |
| -------------------- | --------------------------------------------------------- |
| `/actuator/health`   | Shows application health (e.g., "UP" or "DOWN").          |
| `/actuator/info`     | Displays custom app info (version, name, etc.).           |
| `/actuator/metrics`  | Shows performance metrics like memory, CPU, GC, etc.      |
| `/actuator/beans`    | Lists all Spring Beans loaded in the context.             |
| `/actuator/env`      | Shows environment variables and configuration properties. |
| `/actuator/mappings` | Displays all HTTP mappings (useful for debugging).        |
| `/actuator/loggers`  | View and change log levels at runtime.                    |

---->application.properties
# Expose all endpoints
management.endpoints.web.exposure.include=*

# Change base path (optional)
management.endpoints.web.base-path=/manage

# Custom info endpoint data
info.app.name=PayrollApp
info.app.version=1.0.0
info.app.owner=Rohit Lavate

🧩 Use Case Example
In a real app (like your payroll or compliance system at Morningstar 👔):
-/actuator/health → used by a load balancer to check if service is alive
-/actuator/metrics/jvm.memory.used → used by Grafana to monitor memory
-/actuator/loggers → allows changing log level without restarting app

--Embedded servers
Apache Tomcat, Jetty, and Netty
| Feature             | Tomcat              | Jetty                         | Netty                          |
| ------------------- | ------------------- | ----------------------------- | ------------------------------ |
| Type                | Servlet container   | Servlet container             | NIO framework                  |
| Spring Boot default | ✅ Yes               | ❌ No                          | ❌ No                           |
| Performance         | Good                | Very good                     | Excellent                      |
| Concurrency         | Medium              | High                          | Very high                      |
| Blocking model      | Blocking            | Async (supports non-blocking) | Fully non-blocking             |
| Footprint           | Moderate            | Small                         | Small                          |
| Reactive support    | ❌                   | Partial                       | ✅ Full                         |
| Ideal for           | REST APIs, web apps | Microservices                 | Reactive, event-driven systems |

Class containing main() called as Start/Execution class/Main Class of spring boot.
Entry point for Spring boot application is run()-->It is static method(ClassName.methodName() to call).Starts IOC Container, IOC container object is return type of this method(i.e ConfigurableApplicationContext),
and also perform Component scanning
  ConfigurableApplicationContext context = SpringApplication.run(Application.class,args);
  Car c = context.getBean(Car.class);
 
--ConfigurableApplicationContext is an interface,it will provide implementation class of that class hold into variable
@SpringBootApplication
@RestController
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext context=SpringApplication.run(Application.class, args);---->Contains logic to start the IOC
		System.out.println(context.getClass().getName());
	}
}
--When we use 'web-starter'(i.e web-apps + REST API) in pom.xml----->AnnotationConfig'ServletWebServer'ApplicationContext class will be used to create object for IOC container
--For StandAlone application i.e boot-starter--->AnnotationConfigApplicationContext
--For Reactive Applications ie starter-webflux---->AnnotationConfig'ReactiveWebServer;ApplicationContext class
--If pom.xml contains--> web-starter + webflux-->Priority given to web-starter i.e among 3 web-starter gets priority

SpringBoot Banner-->3 modes as following
--Console(default)-->prints on the console
--log-->Prints on the log file
--off-->don't print banner

create a file-->src/main/resources/banner.txt
  ____             _             _       
 / ___| _ __  _ __(_)_ __  _   _| |_ ___ 
 \___ \| '_ \| '__| | '_ \| | | | __/ _ \
  ___) | |_) | |  | | | | | |_| | ||  __/
 |____/| .__/|_|  |_|_| |_|\__,_|\__\___|
       |_|        ${spring-boot.version}

Application: ${spring.application.name}------>You can use Spring placeholders:
Profile: ${spring.profiles.active}

--application.properties
spring.main.banner-mode=off--->To disable the banner
spring.main.banner-mode=log---->Setting to log file

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApplication.class);
        app.setBannerMode(Banner.Mode.OFF);
        app.run(args);
    }
}

-Dynamic custom Banner via Java Class
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApp.class);
        app.setBanner(new Banner() {
            @Override
            public void printBanner(Environment environment, Class<?> sourceClass, PrintStream out) {
                out.println("🌼 Custom Dynamic Banner 🌼");
                out.println("Active Profile: " + environment.getActiveProfiles()[0]);
            }
        });
        app.run(args);
    }
}

-->Internals of SpringApplication.run() step by step — 

⚙️ 1️⃣ Entry Point
SpringApplication.run(MyApp.class, args);

you’re actually calling a 'static helper' method that does this:

public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
    return new SpringApplication(primarySource).run(args);
}


So there are two main phases:
new SpringApplication(primarySource) → sets up the Spring Boot launcher.
.run(args) → starts the full lifecycle.

⚙️ 2️⃣ Phase 1: new SpringApplication()
This constructor prepares metadata about your application.
Key internals:
Detects Application type:
SERVLET → for web apps using Tomcat/Jetty.
REACTIVE → for WebFlux.
NONE → for CLI apps.

Registers ApplicationContext class to use (like AnnotationConfigServletWebServerApplicationContext).
Loads SpringApplicationRunListeners → these are “listeners” that react to lifecycle events (e.g., starting, environmentPrepared, etc.).
Initializes the main class (from the one having @SpringBootApplication).

⚙️ 3️⃣ Phase 2: run(args)
Here’s the internal flow simplified (core sequence):
🔹 Step 1: prepareEnvironment()
Creates or loads the Spring Environment (ConfigurableEnvironment)
Reads all property sources:
application.properties / application.yml
System environment variables
Command-line arguments
Applies profiles and merges configurations.

🔹 Step 2: printBanner()
Loads and prints the banner.txt (if spring.main.banner-mode ≠ off).
Uses BannerPrinter internally.

🔹 Step 3: createApplicationContext()
Creates an ApplicationContext instance based on app type:
For web apps → AnnotationConfigServletWebServerApplicationContext.
For reactive → AnnotationConfigReactiveWebServerApplicationContext.
For non-web → AnnotationConfigApplicationContext.

🔹 Step 4: prepareContext()
Loads ApplicationContextInitializers (custom setup before beans load).
Sets up environment in the context.
Publishes an event: ApplicationContextInitializedEvent.

🔹 Step 5: refreshContext()
This is the heart of Spring — triggers the entire bean creation lifecycle:
Scans packages (@ComponentScan)
Registers beans (@Bean, @Configuration, @Component)
Resolves dependency injection
Applies AOP proxies
Triggers @PostConstruct
Publishes ContextRefreshedEvent
Essentially, this is where IoC container starts and your app beans become live.

🔹 Step 6: afterRefresh()
Starts embedded web servers (Tomcat, Jetty, etc.) if it’s a web app.
Calls any ApplicationRunner or CommandLineRunner beans.

🔹 Step 7: runListeners.finished() and Context ready
Fires final events like ApplicationReadyEvent.
Returns a fully initialized ConfigurableApplicationContext.

🧠 Summary (in Simple Terms)

Here’s the flow as a quick visual:

SpringApplication.run()
│
├── Create SpringApplication object
├── Prepare Environment
├── Print Banner
├── Create ApplicationContext
├── Prepare Context
├── Refresh Context (Bean creation)
├── Run CommandLineRunner / ApplicationRunner
└── Application is READY ✅

🧩 Bonus: Key Interfaces Inside run()
| Component                                 | Purpose                                                    |
| ----------------------------------------- | ---------------------------------------------------------- |
| `SpringApplicationRunListener`            | Gets lifecycle events (startup, environmentPrepared, etc.) |
| `ApplicationContextInitializer`           | Customizes the context before beans load                   |
| `ApplicationRunner` / `CommandLineRunner` | Runs after app startup                                     |
| `SmartLifecycle`                          | Manages start/stop hooks                                   |

----->Spring Boot Startup Call Tree
SpringApplication.run(MyApp.class, args)
│
├─> SpringApplication.<init>(primarySource)
│   ├─ Detect application type (SERVLET / REACTIVE / NONE)
│   ├─ Set ApplicationContext class
│   └─ Load SpringApplicationRunListeners
│
├─> SpringApplication.run(args)
│   ├─ getRunListeners(args)
│   │   └─ Instantiate listeners from META-INF/spring.factories
│   │
│   ├─ listeners.starting()
│   │   └─ ApplicationStartingEvent
│   │
│   ├─ prepareEnvironment(listeners, args)
│   │   ├─ Create ConfigurableEnvironment (StandardEnvironment / WebEnvironment)
│   │   ├─ Load property sources:
│   │   │    ├─ application.properties / .yml
│   │   │    ├─ System env variables
│   │   │    └─ Command-line args
│   │   ├─ Apply profiles
│   │   └─ listeners.environmentPrepared(environment)
│   │
│   ├─ printBanner(environment)
│   │   └─ BannerPrinter.print(environment, sourceClass)
│   │
│   ├─ createApplicationContext()
│   │   ├─ AnnotationConfigServletWebServerApplicationContext (Web)
│   │   ├─ AnnotationConfigReactiveWebServerApplicationContext (Reactive)
│   │   └─ AnnotationConfigApplicationContext (Non-web)
│   │
│   ├─ prepareContext(context, environment, listeners)
│   │   ├─ context.setEnvironment(environment)
│   │   ├─ context.setId(...)
│   │   ├─ Apply ApplicationContextInitializers
│   │   └─ listeners.contextPrepared(context)
│   │
│   ├─ refreshContext(context)
│   │   └─ AbstractApplicationContext.refresh()
│   │       ├─ prepareBeanFactory()
│   │       ├─ postProcessBeanFactory()
│   │       ├─ invokeBeanFactoryPostProcessors()
│   │       ├─ registerBeanPostProcessors()
│   │       ├─ initMessageSource()
│   │       ├─ initApplicationEventMulticaster()
│   │       ├─ onRefresh() (hook for subclasses)
│   │       ├─ registerListeners()
│   │       ├─ finishBeanFactoryInitialization()
│   │       │    ├─ Instantiate singleton beans
│   │       │    ├─ Resolve DI
│   │       │    ├─ Apply @PostConstruct
│   │       │    └─ Apply AOP proxies
│   │       └─ finishRefresh()
│   │            └─ Publish ContextRefreshedEvent
│   │
│   ├─ afterRefresh(context, args)
│   │   ├─ Start embedded web server (if Web app)
│   │   ├─ Run ApplicationRunner beans
│   │   └─ Run CommandLineRunner beans
│   │
│   └─ listeners.finished(context, null)
│       └─ Publish ApplicationReadyEvent

Spring Boot Runners:--->
They are special interfaces that allow you to execute code once the application context is fully loaded 
but before the application starts accepting requests. They're perfect for initialization tasks, data setup, or validation checks.
Ex;-->In db their is static data, to get that data one time only when we start application is starting and save in the app.
UseCases-->Load Static table data when application starts, Delete data from staging tables(i.e Temporary table), Send notification regarding application startup
Two runners in the spring boot-->
--ApplicationRunner---->run()
--CommandLineRunner---->run()
Note: Both are functional interface, only one abstract method is available i.e run()
Key Point: Runners execute after the application context is fully refreshed but before the application is marked as fully ready (before ApplicationReadyEvent).
Spring Boot Startup:
├── Context Refresh (Bean creation, Dependency Injection)
├── Web Server Starts
├── ApplicationStartedEvent Published
├── 🏃 Runners Execute (in @Order sequence)
│   ├── CommandLineRunner @Order(1)
│   ├── ApplicationRunner @Order(2)
│   └── Other runners...
└── ApplicationReadyEvent Published (App is READY!)

@Component
public class MyApplicationRunner implements ApplicationRunner{

	@Override
	public void run(ApplicationArguments args) throws Exception {
		// TODO Auto-generated method stub
		System.out.println("ApplicationRunner run().. method");
	}

}

spring-boot-autoconfigure-x.x.x.jar---->
It contains all the pre-written configuration classes that Spring Boot uses to automatically set up:
-Data sources (JDBC, JPA, MongoDB)
-Web servers (Tomcat, Jetty, Undertow)
-Spring MVC
-Security
-Actuator
-Mail, Kafka, Redis, Quartz, etc.

META-INF/spring-factories---->Contains initializers and listeners
In the run()-->createBootStrapContext() and getRunListeners(args)-->From factories file they load classes available, they will create object and they
will call methods. These classes load configuration required for our application
SpringApplication.run()
        │
        ├── createBootstrapContext()
        │      └── DefaultBootstrapContext created
        │      └── Initializers registered (for logging, env)
        │
        ├── getRunListeners(args)
        │      └── Load EventPublishingRunListener
        │      └── Prepare lifecycle event handlers
        │
        ├── listeners.starting()
        │      └── Fire ApplicationStartingEvent
        │
        ├── prepareEnvironment()
        │      └── Load application.properties / YAML
        │
        ├── createApplicationContext()
        │      └── Instantiate main ApplicationContext
        │
        ├── refreshContext()
        │      └── Load all beans
        │
        └── callRunners()
               └── Execute CommandLineRunner / ApplicationRunner
public ConfigurableApplicationContext run(String... args) {
    long startTime = System.nanoTime();

    // 1️⃣ Create initial context
    DefaultBootstrapContext bootstrapContext = createBootstrapContext();

    ConfigurableApplicationContext context = null;
    configureHeadlessProperty();

    // 2️⃣ Create listeners for startup events
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting(bootstrapContext, this.mainApplicationClass);

    try {
        // 3️⃣ Prepare environment
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);

        // 4️⃣ Create and refresh ApplicationContext
        context = createApplicationContext();
        prepareContext(bootstrapContext, context, environment, listeners, applicationArguments);
        refreshContext(context);

        // 5️⃣ Call CommandLineRunners / ApplicationRunners
        afterRefresh(context, applicationArguments);
        listeners.started(context);
        callRunners(context, applicationArguments);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, listeners);
    }

    listeners.ready(context);
    return context;
}

Spring Data JPA--->used to develop Persistence layer logic, Simplifies CRUD operations implemenations in project
--Java JDBC,Spring JDBC, Hibernate Framework,Spring ORM, Spring Data JPA-->Ways to develop persistence logic
--In Spring Data JPA, we need to write 0 methods to perform CRUD operations, uses Hibernate framework internally.(If performance is crucial for application,
then directly go with JDBC as it will execute query directly on db)
Java App--->Spring Data JPA(Hibrenate ORM-->JDBC)-->DB
--If you want everything in object format, then go with Hibernate framework/Spring Data JPA
Note: If we have 5000 DB tables then, we have to create 5000 DAO classes. Every dao class should contains 4 common methods so it will become 20000 methods 
with same logic(This is not recommended--->To avoid boilerplate code we use Spring Data JPA)
--In Spring Data JPA-->DAO is called as Repository, and it provided Repository interfaces as follows
CrudRepository(CRUD operations method)
JpaRepository(CRUD operations method + Pagination + Sorting + QBE)
--data-jpa-starter
Driver will be loaded
Connection will be created
SessionFactory will be created
Transaction will be happening

Repository (I)
   ↑
   └── CrudRepository (I)        --> (12 methods)
           ↑
           └── PagingAndSortingRepository (I)
                   ↑
                   └── JpaRepository (I)
                           ↑
                           └── QueryByExampleExecutor (I)

JpaRepository is grandchild of CrudRepository
| Interface                      | Extends From                                       | Purpose                                                                               |
| ------------------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Repository**                 | —                                                  | Marker interface (root of Spring Data hierarchy).                                     |
| **CrudRepository**             | Repository                                         | Provides CRUD operations like `save()`, `findById()`, `delete()`, etc. (≈12 methods). |
| **PagingAndSortingRepository** | CrudRepository                                     | Adds pagination and sorting support (`findAll(Pageable)`, `findAll(Sort)`).           |
| **JpaRepository**              | PagingAndSortingRepository, QueryByExampleExecutor | Adds JPA-specific methods like `flush()`, `saveAndFlush()`, and batch operations.     |
| **QueryByExampleExecutor**     | —                                                  | Provides methods for Query by Example (QBE) functionality.                            |
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--CrudRepository 
| Method                  | Signature                                                 | Description                                                   | Example                               |
| :---------------------- | :-------------------------------------------------------- | :------------------------------------------------------------ | :------------------------------------ |
| **save**                | `<S extends T> S save(S entity)`                          | Saves a single entity. Inserts if new, updates if ID exists.  | `repo.save(emp);`                     |
| **saveAll**             | `<S extends T> Iterable<S> saveAll(Iterable<S> entities)` | Saves all entities in batch. Inserts new, updates existing.   | `repo.saveAll(listOfEmployees);`      |
| **findById**            | `Optional<T> findById(ID id)`                             | Retrieves entity by ID. Returns `Optional` to avoid nulls.    | `repo.findById(1L);`                  |
| **existsById**          | `boolean existsById(ID id)`                               | Checks if an entity with the given ID exists.                 | `repo.existsById(5L);`                |
| **findAll**             | `Iterable<T> findAll()`                                   | Retrieves all entities in the repository.                     | `repo.findAll();`                     |
| **findAllById**         | `Iterable<T> findAllById(Iterable<ID> ids)`               | Retrieves all entities for the given IDs.                     | `repo.findAllById(List.of(1L,2L));`   |
| **count**               | `long count()`                                            | Returns the total number of entities in the repository.       | `repo.count();`                       |
| **deleteById**          | `void deleteById(ID id)`                                  | Deletes the entity with the given ID.                         | `repo.deleteById(3L);`                |
| **delete**              | `void delete(T entity)`                                   | Deletes the given entity.                                     | `repo.delete(emp);`                   |
| **deleteAllById**       | `void deleteAllById(Iterable<? extends ID> ids)`          | Deletes all entities for the given IDs.                       | `repo.deleteAllById(List.of(1L,2L));` |
| **deleteAll(entities)** | `void deleteAll(Iterable<? extends T> entities)`          | Deletes all given entities in batch.                          | `repo.deleteAll(listOfEmployees);`    |
| **deleteAll()**         | `void deleteAll()`                                        | Deletes **all entities** in the repository. Use with caution. | `repo.deleteAll();`                   |

🔹 Notes:
save():If entity ID is null or not in DB → insert.(First Select Query then insert query)-->Polymorphic method
If entity ID exists in DB → update.
findById() returns Optional<T> → helps avoid NullPointerException.
findAll() and count() → useful for pagination & reporting.
Deletion methods are safe, but deleteAll() removes everything — be careful.
While executing findAll()-->It executing select query
                            Retrieving records in form of ResultSet
							Moving Cursor of ResultSet
							Taking each row from ResultSet and setting it to Entity Object
							Adding Entity object to Collection and Returning
							
Requirement:-->Retrieve books whose price>=200-->Non Primary key columns
Solution--> findBy methods
        --> Custom Quries
		
findBy methods	
| Method                         | Generated SQL      | Description               |
| :----------------------------- | :----------------- | :------------------------ |
| `findByName(String name)`      | `WHERE name = ?`   | Finds all with exact name |
| `findByRole(String role)`      | `WHERE role = ?`   | Finds by role             |
| `findById(Long id)`            | `WHERE id = ?`     | Finds by ID               |
| `findBySalary(Double salary)`  | `WHERE salary = ?` | Finds by salary           |
| `findByActive(boolean active)` | `WHERE active = ?` | Finds by boolean column   |
----------------------------------------------------------------------------------
| Interface                      | Extends From                                       | Purpose                                                                               |
| ------------------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **Repository**                 | —                                                  | Marker interface (root of Spring Data hierarchy).                                     |
| **CrudRepository**             | Repository                                         | Provides CRUD operations like `save()`, `findById()`, `delete()`, etc. (≈12 methods). |
| **PagingAndSortingRepository** | CrudRepository                                     | Adds pagination and sorting support (`findAll(Pageable)`, `findAll(Sort)`).           |
| **JpaRepository**              | PagingAndSortingRepository, QueryByExampleExecutor | Adds JPA-specific methods like `flush()`, `saveAndFlush()`, and batch operations.     |
| **QueryByExampleExecutor**     | —                                                  | Provides methods for Query by Example (QBE) functionality.                            |
--findBy methods are used to perfrom only select operations
--Using non primary key columns we can select records
--In findBy methods, method name is very important-->based on method name JPA will construct the query for execution
Note:findBy method should represent Entity class variables

Custom Queries--> If we want to execute our own query, we can write in 2 ways-->@Query annotation
-HQL Queries(Hibernate Query Language)--->Independent of db i.e can't execute on db directly
-Native SQL Queries(Ex--> select * from book)
Note:-->We can write custom query to update and delete,but not insert(direct insert not supported). Insert from one table to other table is supported.
| Type            | Annotation                      | Description                         | Example                                              |
| --------------- | ------------------------------- | ----------------------------------- | ---------------------------------------------------- |
| Derived Query   | —                               | Auto-generated based on method name | `findByName(String name)`                            |
| JPQL Query      | `@Query`                        | Uses entity and field names         | `@Query("SELECT e FROM Employee e WHERE e.id=:id")`  |
| Native Query    | `@Query(..., nativeQuery=true)` | Uses table and column names         | `@Query("SELECT * FROM employee", nativeQuery=true)` |
| Modifying Query | `@Modifying` + `@Transactional` | For UPDATE/DELETE/INSERT            | `@Query("DELETE FROM Employee e WHERE e.id=:id")`    |
| Named Query     | `@NamedQuery`                   | Predefined query inside Entity      | Defined in entity, used in repo                      |
| Projection      | `@Query` with interface         | Select specific columns only        | `SELECT e.name, e.salary`                            |
| Dynamic Query   | SpEL + `@Query`                 | Evaluate expressions at runtime     | `:#{#param}`                                         |
| Joins           | `@Query`                        | For relational fetching             | `JOIN e.department d`                                |
--------------------------------------------------------------------------------------------------------------------------------------------------
--HQL vs SQL
| **Feature**                      | **HQL (Hibernate Query Language)**                    | **SQL (Structured Query Language)**                      |
| -------------------------------- | ----------------------------------------------------- | -------------------------------------------------------- |
| **Full Form**                    | Hibernate Query Language                              | Structured Query Language                                |
| **Works On**                     | Java **entities and their properties**                | **Database tables and columns**                          |
| **Abstraction Level**            | Object-oriented (ORM layer)                           | Relational (Database layer)                              |
| **Language Type**                | Object-based query language                           | Database query language                                  |
| **Dependency on Database**       | Independent (portable across databases)               | Dependent (vendor-specific syntax may vary)              |
| **Return Type**                  | Entity objects or projections                         | ResultSet (raw database rows)                            |
| **Mapping**                      | Automatically mapped to entity classes                | Manual mapping needed (unless ORM used)                  |
| **Case Sensitivity**             | Entity names and field names are case-sensitive       | Table/column names depend on DB vendor                   |
| **Joins**                        | Uses entity relationships (e.g., `JOIN e.department`) | Uses explicit joins (e.g., `JOIN department ON ...`)     |
| **Data Retrieval**               | Returns persistent objects                            | Returns raw data (rows and columns)                      |
| **Query Example**                | `FROM Employee e WHERE e.salary > 50000`              | `SELECT * FROM employee WHERE salary > 50000`            |
| **Updates & Deletes**            | Supported (`UPDATE`, `DELETE`) but on entities        | Fully supported (`UPDATE`, `DELETE`) on tables           |
| **Aggregations**                 | Supported (`COUNT`, `SUM`, etc.)                      | Supported (`COUNT`, `SUM`, etc.)                         |
| **Named Parameters**             | Supported (`:paramName`)                              | Positional parameters (`?`) mostly used                  |
| **Automatic Conversion**         | Yes — Hibernate converts HQL to SQL internally        | No — SQL executes as written                             |
| **Portability**                  | High — works with any DB supported by Hibernate       | Low — syntax may differ across DBs                       |
| **Performance Tuning**           | Controlled by Hibernate                               | Controlled by database directly                          |
| **Use Case**                     | Ideal for standard CRUD, entity-based queries         | Ideal for complex, DB-specific queries and optimizations |
| **Supports Native DB Functions** | Limited                                               | Fully supported                                          |
| **Relationship Navigation**      | Easy (uses mapped associations)                       | Manual joins required                                    |
| **Ease of Use**                  | Easier and cleaner for ORM-based apps                 | Requires SQL and schema knowledge                        |
| **Example in Hibernate**         | `session.createQuery("FROM Employee").list();`        | `session.createNativeQuery("SELECT * FROM employee");`   |

--When to use
| **Scenario**                                       | **Recommended Query Type** |
| -------------------------------------------------- | -------------------------- |
| CRUD operations using entities                     | HQL                        |
| Complex joins using entity relationships           | HQL                        |
| Vendor-specific SQL functions or stored procedures | SQL                        |
| Reporting and analytics queries                    | SQL                        |
| Cross-database portability required                | HQL                        |
| Heavy performance tuning or DB optimizations       | SQL                        |


public interface BookRepository extends CrudRepository<Book, Integer> {
	
	public List<Book> findByBookPriceGreaterThan(Double price);
	
	//nateive query
	@Query(value="select * from book", nativeQuery=true)
	public List<Book> getAllBooks();
	
	//HQL Query
	@Query("from Book")
	public List<Book> getBooks();

}
-Dialect class converts HQL queries to SQL Queries i.e maintenance wise HQL queries are good-->Every DB have it's own dialect class
Ex:==OracleDialect,MySQLDialect,DB2Dialect,PostgresDialect etc...
Note: Dialect class will be loaded along with DB driver class
1000 HQL Queries--->MysQL dialect-->MysQLDB
1000 HQL Queries--->Oracle dialect-->OracleDB
i.e we can change db effortlessely.
Example
=======
select * from book(Table in db)==========from Book(Entity Class)
select * from book where book_price=200(book_price is column name)====from book where bookPrice=200(here bookPrice is variable)
selct book_name from book=====select bookName form Book
| **Term**       | **Meaning**                                  | **Affects**       | **SQL Clause** | **Example**                         |
| -------------- | -------------------------------------------- | ----------------- | -------------- | ----------------------------------- |
| **Selection**  | Filters specific **rows** based on condition | Number of rows    | `WHERE`        | `SELECT * FROM emp WHERE dept='HR'` |
| **Projection** | Selects specific **columns** from a table    | Number of columns | `SELECT`       | `SELECT name, salary FROM emp`      |

--JpaRepository:-->
| **Aspect**                    | **Description / Example**                                                                                                                                                                                                                                                                                                                   |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Definition**                | `JpaRepository` is an interface in Spring Data JPA that provides **CRUD operations + JPA-specific methods**. It extends `PagingAndSortingRepository` and CrudRepository`.                                                                                                                                                                  |
| **Basic Syntax**              | `java<br>@Repository<br>public interface BookRepository extends JpaRepository<Book, Integer> { }<br>`<br>Book = entity class, Integer = primary key type                                                                                                                                                                                    |
| **Built-in Methods**          | `save(entity)`, `findById(id)`, `findAll()`, `delete(entity)`, `count()`, `existsById(id)`                                                                                                                                                                                                                                                  |
| **Derived Query Methods**     | Spring generates queries from method names:<br>`List<Book> findByBookName(String name);`<br>`List<Book> findByBookPriceGreaterThan(Double price);`<br>`List<Book> findByBookNameContaining(String keyword);`                                                                                                                                |
| **Custom Queries (`@Query`)** | JPQL: <br>`java<br>@Query("SELECT b FROM Book b WHERE b.bookPrice > :price")<br>List<Book> findExpensiveBooks(@Param("price") Double price);<br>`<br>Native SQL: <br>`java<br>@Query(value = "SELECT * FROM book WHERE book_price > :price", nativeQuery = true)<br>List<Book> findExpensiveBooksNative(@Param("price") Double price);<br>` |
| **Paging & Sorting**          | Inherited from `PagingAndSortingRepository`:<br>`Page<Book> findAll(Pageable pageable);`<br>`List<Book> findAll(Sort sort);`<br>Example:<br>`Pageable pageable = PageRequest.of(0, 5, Sort.by("bookPrice").descending());`<br>`Page<Book> page = bookRepository.findAll(pageable);`                                                         |
| **Key Interfaces**            | `CrudRepository` → basic CRUD<br>`PagingAndSortingRepository` → pagination & sorting<br>`JpaRepository` → JPA-specific methods + all above                                                                                                                                                                                                  |
| **Advantages**                | ✅ No implementation needed — Spring generates it<br>✅ Supports derived queries<br>✅ Supports custom JPQL/native queries<br>✅ Built-in pagination and sorting                                                                                                                                                                                |

Note:
findAll()---->Retrieves all the records
Page<Book> findAll(Pageable pageable)------>Retrieves record with pagination
List<Book> findAll(Sort sort)----->Retrieves records wit sorting

Example.of() lets you build dynamic queries without writing JPQL or method names.
You create a probe (sample entity) with some fields set, and Spring Data JPA finds matching records.

@SpringBootApplication
public class Application {

    private final EmpRepository empRepository;

    Application(EmpRepository empRepository) {
        this.empRepository = empRepository;
    }

	public static void main(String[] args) {
		ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
		EmpRepository empRepo = context.getBean(EmpRepository.class);
		System.out.println("EmpRepository Bean is: " + empRepo.getClass().getName());

		/*
		 * Employee e1 = new Employee();
		 * 
		 * e1.setEmpName("John Doe"); e1.setEmpSalary(50000.0); e1.setEmpGender("Male");
		 * e1.setEmpDept("IT"); empRepo.save(e1);--------------------------------------------->when save() executed ID and create_Date field in the db gets updated
		 * 
		 * e1.setEmpName("Jane Smith"); e1.setEmpSalary(30000.0);
		 * e1.setEmpGender("Female"); e1.setEmpDept("HR");
		 * 
		 * Employee e2 = new Employee(); e2.setEmpName("Alice Johnson");
		 * e2.setEmpSalary(35000.0); e2.setEmpGender("Female"); e2.setEmpDept("HR");
		 * 
		 * Employee e3 = new Employee(); e3.setEmpName("Bob Brown");
		 * e3.setEmpSalary(40000.0); e3.setEmpGender("Male"); e3.setEmpDept("IT");
		 * 
		 * empRepo.saveAll( java.util.List.of(e1, e2, e3) );
		 * System.out.println("Employees saved successfully!");
		 */

		List<Employee> listbySalaryDesc = empRepo.getEmployeeBySalaryDesc();
		listbySalaryDesc.forEach(System.out::println);
		System.out.println("-----------------------------------------------------");
		
		// ascending order by bookName
		Sort sortByNameAsc = Sort.by("empName").ascending();
		//List<Employee> empAsc = empRepo.findAll(Sort.by("empName").ascending());
		List<Employee> empAsc = empRepo.findAll(sortByNameAsc);
		empAsc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//Sort sortByDeptDesc = Sort.by("empDept").descending();
		Sort sortByDeptDesc = Sort.by(Sort.Direction.DESC, "empDept");
		List<Employee> empDeptDesc = empRepo.findAll(sortByDeptDesc);
		empDeptDesc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//sorting based on multiple fields
		//Sort sortByDeptAscAndSalaryDesc = Sort.by("empDept","empSalary").ascending();
		Sort sortByDeptAscAndSalaryDesc = Sort.by("empDept").ascending()
                .and(Sort.by("empSalary").descending());
		List<Employee> empDeptAscAndSalaryDesc = empRepo.findAll(sortByDeptAscAndSalaryDesc);
		empDeptAscAndSalaryDesc.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		int pageNumber = 0; // first page
		PageRequest page = PageRequest.of(pageNumber, 2);
		Page<Employee> empPage = empRepo.findAll(page);
		List<Employee> empList = empPage.getContent();
		empList.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		int peNum = 0; // first page
		PageRequest pg = PageRequest.of(peNum, 3, Sort.by("empName").ascending());
		Page<Employee> empPg = empRepo.findAll(pg);
		List<Employee> empLst = empPg.getContent();
		empLst.forEach(System.out::println);
		System.out.println("------------------------------------------------------");
		
		//to filter according to the column name--->i.e where clause
		 Employee emp = new Employee();
		 emp.setEmpDept("IT");   // We want to find all employees from IT dept
		 Example<Employee> example = Example.of(emp);
		 List<Employee> result = empRepo.findAll(example);
		 result.forEach(System.out::println);
		 System.out.println("------------------------------------------------------");
		 
		 Employee e =new Employee();
		 e.setEmpDept("HR");
		 e.setEmpGender("Male");
		 Example ex = Example.of(e);
		 List<Employee> res = empRepo.findAll(ex);
		 res.forEach(System.out::println);
		 System.out.println("------------------------------------------------------");
		 
		 ExampleMatcher matcher = ExampleMatcher.matching()
			        .withIgnoreCase("empName")
			        .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);
			Employee e2 = new Employee();
			e2.setEmpName("swapnil"); // will match "Swaobuk", "Swapnila", "Mr. Swapnil" etc.
			Example<Employee> exemp = Example.of(e2, matcher);
			List<Employee> output = empRepo.findAll(exemp);
			output.forEach(System.out::println);
	
	}

}
------------------------------------------------------
	@CreationTimestamp
	@Column(name="date_created",updatable = false)
	private LocalDateTime dateCreated;
	
	@Column(name="last_updated", insertable = false)
	@UpdateTimestamp
	private LocalDateTime lastUpdated;
------------------------------------------------------
--Primary Key constraint is combination of following 2 constraints--->(Without Pk-->IdentifierGenerationException)
Unique
Not Null

Note: User should only enter Non Primary key value, Primary key should be generated by us i.e application. That is when Generator comes into picture

--IdentifierGenerationException occurs when Hibernate fails to generate a primary key (ID) for an entity during the persist() or save() operation.
| **Cause**                              | **Description**                                                                    | **Example**                                                                                  | **Fix / Solution**                                                                                                |
| -------------------------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **1. Missing @GeneratedValue**         | You annotated the ID with `@Id` but didn’t tell Hibernate *how* to generate it.    | `java @Id private Integer id; `                                                              | Add a generation strategy:<br>`java @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; ` |
| **2. Unsupported Generation Strategy** | The chosen strategy doesn’t match your DB capabilities.                            | Using `SEQUENCE` in MySQL (which doesn’t support sequences).                                 | Use `IDENTITY` for MySQL.<br>Use `SEQUENCE` for Oracle/PostgreSQL.                                                |
| **3. Manually assigned ID not set**    | If you didn’t use `@GeneratedValue`, Hibernate expects you to set the ID manually. | `java @Id private Integer id;` and not setting `id`.                                         | Either set the ID manually or use `@GeneratedValue`.                                                              |
| **4. Sequence/Table not found**        | The sequence or table used for ID generation doesn’t exist in the DB.              | `java @SequenceGenerator(name="seq", sequenceName="user_seq")` but `user_seq` doesn’t exist. | Manually create the sequence in DB, or let Hibernate create it using `spring.jpa.hibernate.ddl-auto=update`.      |
| **5. Wrong column mapping**            | The ID column name doesn’t match the actual DB column.                             | DB column is `book_id`, but entity says `id`.                                                | Add `@Column(name="book_id")` above your ID field.                                                                |
| **6. Embeddable ID issues**            | When using `@EmbeddedId` or `@IdClass`, Hibernate can’t determine ID properly.     | Incorrectly mapped composite key.                                                            | Ensure all key fields are properly annotated and present in both ID class and entity.                             |


## 🧩 JPA Built-in Generation Strategies

| STRATEGY        | DATABASE SUPPORT                     | PERFORMANCE | BATCH INSERT | CODE EXAMPLE                                                                                                          | USE CASES                                   | PROS                              | CONS                             |
|-----------------|--------------------------------------|-------------|---------------|----------------------------------------------------------------------------------------------------------------------|---------------------------------------------|-----------------------------------|----------------------------------|
| **AUTO (Default)** | All databases                      | Varies      | Varies        | `@GeneratedValue(strategy = GenerationType.AUTO)`                                                                    | Database portability, simple projects       | Database agnostic, easy setup     | Unpredictable behavior across DBs |
| **IDENTITY**    | MySQL, SQL Server, PostgreSQL, H2, DB2 | Good        | ❌             | `@GeneratedValue(strategy = GenerationType.IDENTITY)`                                                                | Simple auto-increment fields, small apps    | Simple, widely supported          | No batch inserts, pre-insert select |
| **SEQUENCE**    | Oracle, PostgreSQL, H2, DB2          | Excellent   | ✅             | ```java                                                                                                              |
|                 |                                      |             |               | @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "seq")                                              |
|                 |                                      |             |               | @SequenceGenerator(name = "seq", sequenceName = "user_seq")                                                         |
|                 |                                      |             |               | ```                                                                                                                 | High-performance enterprise apps            | Best performance, batch supported | Database-specific                 |
| **TABLE**       | All databases                        | Fair        | ✅             | ```java                                                                                                              |
|                 |                                      |             |               | @GeneratedValue(strategy = GenerationType.TABLE, generator = "tab")                                                 |
|                 |                                      |             |               | @TableGenerator(name = "tab", table = "id_gen")                                                                     |
|                 |                                      |             |               | ```                                                                                                                 | Legacy systems, no sequence support         | Database independent              | Slower, table locking issues      |

Note: For SEQUENCE, the table will be created for storing next_val. and IDNTITY support for AUTO-INCREMENT(in console query contains auto_increment).TABLE maintains seperate table for PK
see console for TABLE-->same way check for other --->3 queries for each operation-->degrades the performance
Hibernate: select tbl.next_val from hibernate_sequences tbl where tbl.sequence_name=? for update
Hibernate: update hibernate_sequences set next_val=?  where next_val=? and sequence_name=?
Hibernate: insert into book (book_name,book_price,book_id) values (?,?,
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Why Use Wrapper Classes Instead of Primitive Types
| **Aspect**          | **Primitive Type (`int`, `long`)**   | **Wrapper Type (`Integer`, `Long`)**   | **Explanation**                                                                                                                               |
| ------------------- | ------------------------------------ | -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| **Default Value**   | Always has a default (e.g. `0`)      | Can be `null`                          | Hibernate uses `null` to detect *new (unsaved)* entities. If ID = 0, Hibernate gets confused and may try to **update** instead of **insert**. |
| **Nullability**     | Cannot be `null`                     | Can be `null`                          | Database columns are often nullable — primitives cannot represent null.                                                                       |
| **ID Generation**   | Causes issues with `@GeneratedValue` | Works perfectly with `@GeneratedValue` | Hibernate expects the ID to be `null` before insert, so it can generate one.                                                                  |
| **Optional Values** | Always initialized                   | Can be optional                        | Some business fields may not always have a value at creation time.                                                                            |
| **Boxing/Unboxing** | Not needed                           | Automatic                              | Negligible impact, but safer for ORM frameworks.                                                                                              |

Custom Generator---->We should implement Generator interface which has generate().
eg:-->OD1,OD2,OD3,....--->Prefix(Fixed=OD) + Suffix(Number-->Variable and increment by 1)

public class OrderIdGenerator implements IdentifierGenerator{

	@Override
	public Serializable generate(SharedSessionContractImplementor session, Object object) {
		
		String prefix = "OD";
		String suffix = "";
		try {
			Connection connection = session.getJdbcConnectionAccess().obtainConnection();
			Statement statement = connection.createStatement();
			String query = "SELECT ORDER_ID_SEQ.NEXTVAL as nextval FROM DUAL";
			ResultSet result = statement.executeQuery(query);
			if(result.next()) {
				int seqVal = result.getInt(1);
				suffix = String.valueOf(seqVal);
			}
		}catch (Exception e) {
			e.printStackTrace();
		}
		return prefix + suffix;
	}

}

Composite Primary Key--->
@Data
@Embeddable
public class AccountPK {
	
	private String accNum;
	
	private String accType;

}

@Entity
@Table(name = "account_tbl")
@Data
public class Account {
	
	private String holderName;
	
	private String branch;
	
	@EmbeddedId
	private AccountPK accountPK;

}

public interface AccountRepository extends JpaRepository<Account, AccountPK> {

}

Note:Generators are not applicable for composite primary key. If you have composite primary key, you have to set values manually.
The Class which is representing composite keys should implement Serializable interface(Marker interface-->Used to give special instructions to JVM)

Profiles in Spring Boot-->
Every project will have multiple environments(Platform which used to run our application)-->DEV ENV,STG ENV, SIT ENV, PROD ENV
Environment contains-->Server(Linux VM),DB Server,Log Server etc. Every environment has its own DB and every DB will have seperate configuartion properties(uname,password,url etc)
If we want to deploy our code to multiple environments then we have to change datasource properties in the application.prooperties file-->Chance of mistake
So to avoid mistakes, concept of profile comes in spring boot-->Profiles are used to configure environment specific properties
application.properties contains--->DB Properties,SMTP properties,Kafka properties,Redis properties,REST API endpoint URLs
src/main/resources/
 ├── application.properties              # Default (active if no profile set)
 ├── application-dev.properties           # For dev
 ├── application-test.properties          # For testing
 └── application-prod.properties          # For production
 
--->Spring WebMVC----->simplifies Web Application Development process
 Dependency--->spring-boot-starter-web-->provides support for MVC based web application, RESTFul Services, Embedded container(Tomcat)
 Advantages-->It supports form binding(Form Data binds to Java Object)
              Flexibility in Form Binding(Type conversion-->convert data in particular data type)
			  Multiple presentation technologies(JSP and Thymeleaf)
			  Form tag library(Ready Made tag supports)
			  
MVC Architecture Flow
Client Request → DispatcherServlet → Controller → Service → DAO → Database
       ↑                                              ↓
Client Response ← View ← Model ← Controller ← Service ←

---->Detailed Flow
CLIENT REQUEST
    ↓
DispatcherServlet (Front Controller/Framework Servelet)---->Responsible for performing Pre-Processing and Post-Processing
    ↓
Handler Mapping (Finds appropriate controller)---->As multiple controllers, DispatcherServlet doesn't know which method responsible to handle request, so it will give request to HandlerMapper it will scans url mapping and give that detail back to DispatcherServlet. DispatcherServelet will go to that Controller class and Controller method
    ↓
Controller (Processes request)
    ↓
Service Layer (Business logic)
    ↓
DAO/Repository (Data access)
    ↓
Database
    ↑
Controller ← Service ← DAO (Return data)
    ↓
Model (Adds data)
    ↓
View Resolver (Finds view template)
    ↓
View (JSP/Thymeleaf) + Model
    ↓
CLIENT RESPONSE

┌─────────────────────────────────────────────────────────────────────────┐
│                            CLIENT BROWSER                               │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ HTTP Request (URL, Form Data, Parameters)
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                        DispatcherServlet                                │
│  (Front Controller - Single entry point for all requests)               │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │
                                ↓ Delegates to appropriate components
┌─────────────────────────────────────────────────────────────────────────┐
│                         Handler Mapping                                 │
│  (Maps request to appropriate Controller)                               │
│  - @RequestMapping, @GetMapping, @PostMapping etc.                     │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Returns HandlerExecutionChain
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                         Controller                                      │
│  (Processes business logic)                                             │
│  - @Controller, @RestController                                         │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Calls Service Layer
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                         Service Layer                                   │
│  (Business logic implementation)                                        │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Calls DAO/Repository
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                    DAO/Repository Layer                                 │
│  (Data access operations)                                               │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Interacts with Database
                                ↓
                          ┌───────────┐
                          │ DATABASE  │
                          └───────────┘
                                ↑
                                │ Returns data
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                         Controller                                      │
│  (Prepares Model data)                                                  │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Returns ModelAndView or ResponseEntity(Model-->Represents data in key-value format, View-->Logical File Name)
								|(Note -->Controllers are loosely coupled with Presentation technology as Multiple presentation techniques are their-->To identify presentation technology it will talk to view resolver)
								| (ViewResolver identifies where is the view file in the project and what is the view technology(i.e Presentation Technology)
                                ↓
								
┌─────────────────────────────────────────────────────────────────────────┐
│                         View Resolver                                   │
│  (Resolves view name to actual view template)                           │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Returns View object
								| (After Identifying it will give that info to DispatcherServelet, which will send model data to View Component)
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                            View                                         │
│  (Renders response using template + model data)                         │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ Rendered HTML/JSON/XML(i.e render model data in the view file and give it to DispatcherServelet)
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                        DispatcherServlet                                │
│  (Sends response to client)                                             │
└───────────────────────────────┬─────────────────────────────────────────┘
                                │ HTTP Response
                                ↓
┌─────────────────────────────────────────────────────────────────────────┐
│                            CLIENT BROWSER                               │
└─────────────────────────────────────────────────────────────────────────┘
-------------------------------------------------------------------------------------
┌─────────────────────────────────────────────────────────────┐
│                        CLIENT                               │
│                                                             │
│                    HTTP Request  →→→→→→→→→→→→→→→→→→→→→→→→   │
│                                                             │
│                    ←←←←←←←←←←←←←←←←←←←← HTTP Response       │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                    DispatcherServlet                        │
│                                                             │
│          ↗ Pre-processing                                   │
│          ↖ Post-processing                                  │
└─────────────────────────┬───────────────────────────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
          ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   Handler       │ │    Controller    │ │   View Resolver │
│   Mapping       │ │                 │ │                 │
└─────────────────┘ └─────────────────┘ └─────────────────┘
          │               │                       │
          │               │                       │
          ▼               ▼                       ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  URL to Controller│ │  Business Logic │ │ Logical to     │
│   Mapping        │ │   Processing    │ │ Physical View  │
└─────────────────┘ └─────────────────┘ └─────────────────┘
                                          │
                                          │
                                          ▼
                                 ┌─────────────────┐
                                 │      View       │
                                 │  (JSP/HTML/etc) │
                                 └─────────────────┘
								 
To Create Spring MVC app we need to add following dependencies-->
--spring-boot-starter-web
--spring-boot-devtools
--tomcat-embed-jasper(Only when using JSP as Presentation Technology, but spring supports Thymeleaf)<----Add externally

-Application.java          ← Main Spring Boot app
-ServletInitializer.java   ← WAR entry point--->i.e Required for Web Application Execution
configure(): Entry point for servlet container
application.sources(): Specifies the main configuration class

--How ServletInitializer Works
Deployment Flow:
External Tomcat Startup
        ↓
Servlet Container looks for web.xml or ServletInitializer
        ↓
ServletInitializer.configure() method is called
        ↓
Spring Application Context is created
        ↓
Your Spring Boot Application starts
        ↓
Controllers and Services are initialized

--Form Tag Library
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>

+---------------------+--------------------------------------+------------------------------------------------------------+
| Tag                 | Description                          | Syntax Example                                             |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:form>         | Main form container, binds to        | <form:form method="POST" modelAttribute="book">            |
|                     | command object                       |                                                            |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:input>        | Text input field                     | <form:input path="bookName"/>                              |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:password>     | Password input field                 | <form:password path="password"/>                            |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:textarea>     | Multi-line text input                | <form:textarea path="description" rows="5"/>                |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:select>       | Dropdown select box                  | <form:select path="category">                              |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:option>       | Single option in select              | <form:option value="FICTION">Fiction</form:option>          |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:options>      | Multiple options from collection     | <form:options items="${categories}"/>                       |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:radiobutton>  | Radio button input                   | <form:radiobutton path="type" value="EBOOK"/>               |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:checkbox>     | Checkbox input                       | <form:checkbox path="features" value="HARDBACK"/>           |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:errors>       | Display validation errors            | <form:errors path="bookName" cssClass="error"/>             |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:hidden>       | Hidden input field                   | <form:hidden path="bookId"/>                                |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:label>        | Form field label                     | <form:label path="bookName">Book Name</form:label>          |
+---------------------+--------------------------------------+------------------------------------------------------------+
| <form:button>       | Button element                       | <form:button type="submit">Save</form:button>               |
+---------------------+--------------------------------------+------------------------------------------------------------+

modelAttribute--->maps form data to class mapping(Entity class is different)
Path Attribute--->Map fields to class variables

When you first load the page, you don’t have user input yet. So, you give Spring an empty object — like a placeholder — for the form to bind to.
@Controller
public class StudentController {
	
	@GetMapping("/")
	public String loadIndexPage(Model model) {
		Student sObj = new Student();
		model.addAttribute("student",sObj);
		return null;
	}

}

For every HTTP request, Spring MVC creates a new Model object.
This is by design for thread safety and request isolation
Static data (like dropdown options) should be reused via constants
Dynamic data (like form objects) should be created fresh each time
HTTP Request → DispatcherServlet → Controller Method → NEW Model → Response
      ↓               ↓                   ↓            ↓         ↓
   Request 1       HandlerMapping      @GetMapping   Model 1   Response 1
   Request 2       HandlerMapping      @GetMapping   Model 2   Response 2
   Request 3       HandlerMapping      @GetMapping   Model 3   Response 3
   
Model is map(key-value pair). From first method once, whatever data you passing to model, view will be accessing that data in view page, once view page is 
loaded, that model object will be deleted from container. so we have to set those 3 lines of code in 2nd method. But it is not recommended to write it in 
2 places. so write it in 1 method and call it in two places

@Controller
public class StudentController {
	@Autowired
	private StudentService service;
	
	@GetMapping("/")
	public String loadIndexPage(Model model) {
		init(model);
		return "index";
	}
	
	//@InitBinder-->not working
	@ModelAttribute
	public void init(Model model) {
		model.addAttribute("student",new Student());
		model.addAttribute("courses", service.getCourses());
		model.addAttribute("prefTimings", service.getTimings());
	}
	
	//Endpoint to save student record	
	@PostMapping("/save")
	public String handSubmitBtm(Student s, Model model) {
		boolean isSaved = service.saveStudent(s);
		if(isSaved) {
			model.addAttribute("msg", "Data Saved....");
		}
		init(model);
		return "index";	
	}

}

@Controller
public class ProductController {
	
	@Autowired
	private ProductRepository repo;
	
	@GetMapping("/")
	public String loadForm(Model model) {
		model.addAttribute("p",new ProductEntity());
		return "index";	
	}
	
	@PostMapping("/product")
	public String handleSave(@ModelAttribute("p") ProductEntity p,Model model) {
		p = repo.save(p);
		if(p.getPid()!=null) {
		model.addAttribute("msg","Data Saved....");
		}
		return "index";
	}
}
-----------------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Home Page</title>
	</head>
	<body>
		<h2>Product Info</h2>
		<p><font color="green">${msg}</font></p>
		<form:form action="product" modelAttribute="p" method="POST">
			<table>
				<tr>
					<td>Name:</td>
					<td><form:input path="name"/></td>
				</tr>
				<tr>
					<td>Price:</td>
					<td><form:input path="price"/></td>
				</tr>
				<tr>
					<td>Quantity:</td>
					<td><form:input path="qty"/></td>
				</tr>
				<tr>
					<td></td>
					<td><input type="submit" value="save"></td>
				</tr>
			</table>
		</form:form>
		<a href="products">View Products</a>
	</bdoy>
</html>
--------------------------------------------------------------------------------------
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form"%>
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Products Page</title>
	</head>
	<body>
		<table>
			<thead>
				<tr>
					<th>S.NO</th>
					<th>Name</th>
					<th>Price</th>
					<th>Quantity</th>
				</tr>
			</thead>
			<tbody>
				<c:forEach items="${products}" var="product" varStatus="status">
					<tr>
						<td>${status.count}</td>
						<td>${product.name}</td>
						<td>${product.price}</td>
						<td>${product.qty}</td>
					</tr>
				</c:forEach>
			</tbody>
	 </body>
</html>
-------------------------------------------------------------------------------------------
# JSTL forEach Tag Breakdown

| Part                | Meaning          | Description                                           |
|---------------------|------------------|-------------------------------------------------------|
| <c:forEach          | JSTL Loop Tag    | Starts the loop iteration                             |
| items="${products}" | Collection to iterate | Refers to products attribute from Spring controller |
| var="product"       | Loop variable    | Each item in collection is assigned to product         |
| varStatus="index"   | Loop status      | Provides loop information (counter, index, etc.)       |


Embedded Databasee(i.e In Memory database/Temporary Database)-->Starts when app starts and Stops when app stops
Ex:H2 DB,HSQLDB,Derby
Note -->don't add devtools dependency otherwise it will restart server upon changes and data will be lost
JSTL:-->Whatever data we are inserting in the db table, we need to display in the another page. so need to iterate the list of records in jsp

---Thymeleaf vs JSP
JSP can't send response directly to browser, so it is converted to servelet(Takes more time)
HTML is faster than jsp, but HTML is only for static pages. so we are going to use Thymeleaf inside HTML, to support dynamic webpages
Thymeleaf is the template engine that can be integrated into HTML
create HTML pages in src/resources/templates
| **Feature**              | **Thymeleaf**                  | **JSP (Java Server Pages)**            | 
| ------------------------ | ------------------------------ | ---------------------------------------|
| **Natural Templates**    | ✅ Yes – works as static HTML   | ❌ No – requires server to render     |
| **Spring Integration**   | ✅ Excellent native support     | ⚠️ Requires additional configuration  |
| **Syntax**               | ✅ HTML5-compliant, clean       | ❌ Mixes Java code with HTML          |
| **Learning Curve**       | ✅ Easy for frontend developers | ❌ Steeper, requires Java knowledge   |
| **Performance**          | ✅ Good (compiled templates)    | ✅ Good (compiled to servlets)        |
| **Internationalization** | ✅ Excellent support            | ✅ Good support                       |
| **Fragment Reuse**       | ✅ Layouts and fragments        | ✅ Includes and taglibs               |
| **Tooling**              | ✅ Good IDE support             | ✅ Mature tooling                     |
------------------------------------------------------------------------------------------------------
--need to add thymeleaf-starter in pom.xml(tomcat-embed-jasper is not needed now and no need to configure view resolver)

| Tag                                            | Description                         |
| ---------------------------------------------- | ----------------------------------- |
| `<form th:action="@{/product}" method="post">` | Submits form to `/product` endpoint |
| `th:object="${p}"`                             | Binds form inputs to Product object |
| `th:field="*{name}"`                           | Maps field to `Product.name`        |
| `th:if` / `th:text`                            | Used to show messages dynamically   |


index.html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>Home Page</title>
</head>
<body>
	<div class="container">
		<h3>
			<p th:text="${msg}" class="text-success"></p>
		</h3>
	</div>

	<form th:action="@{/product}" th:object="${p}" method="post">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" th:field="*{name}" ></td>
			</tr>
			<tr>
				<td>Price:</td>
				<td><input type="number" th:field="*{price}" ></td>
			</tr>
			<tr>
				<td>Quantity:</td>
				<td><input type="number" th:field="*{quantity}" ></td>
			</tr>
			<tr>
				<td><a href="/">Reset</a></td>
				<td><input type="submit" value="Save" class="btn btn-primary" /></td>
			</tr>
		</table>
	</form>

	<div class="pt-3 pb-3">
		<a href="/products">View All Products</a>
	</div>
</body>
</html>

data.html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
	<meta charset="UTF-8">
	<title>Product Page</title>
	<script type="text/javascript">
		function deleteConfirm() {
			return confirm("Are you sure you want to delete this product?");
		}
	</script>
</head>

<body>
	<div class="container">
		<h1>View Products</h1>
		<p th:text="${msg}" class="text-danger">
		<a href="/" class="btn btn-primary">+Add New Product</a>
	</div>
	<table>
		<thead>
			<tr>
				<th>Product ID</th>
				<th>Product Name</th>
				<th>Product Price</th>
				<th>Product Quantity</th>
				<th>Action</th>
			</tr>
		</thead>
		<tbody>
			<tr th:if="${list == null or list.empty}">
				<td colspan="5" style="text-align: center;">
					No Records found
				</td>
			</tr>
			<tr th:each="product : ${list}" th:if="${list != null and !list.empty}">
				<td th:text="${product.pid}"></td>
				<td th:text="${product.name}"></td>
				<td th:text="${product.price}"></td>
				<td th:text="${product.quantity}"></td>
				<td>
					<a th:href="@{/delete(pid=${product.pid})}" class="btn btn-danger"
						onclick="return deleteConfirm()">Delete</a>
				</td>
			</tr>
		</tbody>
	</table>
</body>

Form Validation-->As record should be inserted only when the data is available
--Client Side Validation: Validations executes on browser
--Server Side Validation:---for this we have to add spring-boot-starter-validation, we will write validation on binding object
@Validated---->To tell the spring boot, that we are getting form data in form of binding object, you verify that form data ,
store into binding object satisfying validation rule or not
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>Home Page</title>
</head>
<body>
	<div class="container">
		<h3>
			<p th:text="${msg}" class="text-success"></p>
		</h3>
	</div>

	<form th:action="@{/product}" th:object="${p}" method="post">
		<table>
			<tr>
				<td>Name:</td>
				<td><input type="text" th:field="*{name}" ></td>
				<td th:if="${#fields.hasErrors('name')}" th:errors="*{name}" class="text-danger"></td>
			</tr>
			<tr>
				<td>Price:</td>
				<td><input type="number" th:field="*{price}" ></td>
				<td th:if="${#fields.hasErrors('price')}" th:errors="*{price}" class="text-danger"></td>
			</tr>
			<tr>
				<td>Quantity:</td>
				<td><input type="number" th:field="*{quantity}" ></td>
				<td th:if="${#fields.hasErrors('quantity')}" th:errors="*{quantity}" class="text-danger"></td>
			</tr>
			<tr>
				<td><a href="/">Reset</a></td>
				<td><input type="submit" value="Save" class="btn btn-primary" /></td>
			</tr>
		</table>
	</form>

	<div class="pt-3 pb-3">
		<a href="/products">View All Products</a>
	</div>
</body>
</html>

@Entity
@Data
public class Product {
	
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	private Integer pid;
	
	@Size(min = 3, max = 15, message = "Name must have between {min} and {max} characters")
	@NotBlank(message="Name is mandatory")
	private String name;
	
	@NotNull(message="Price should be not null")
	private Double price;
	
	@NotNull(message="Quantity should be entered")
	private Integer quantity;

}

	@PostMapping("/product")
	public String saveProduct(@Validated @ModelAttribute("p") Product p,BindingResult result,Model model) {
		if(result.hasErrors()) {
			System.out.println(p);
			return "index";
		}
		Product savedProduct = repo.save(p);
		System.out.println(savedProduct);
		if(savedProduct.getPid()!=null) {
			model.addAttribute("msg", "Product is saved in DB");
		}
		return "index";
	}